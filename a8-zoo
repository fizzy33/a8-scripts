#!/usr/bin/env python3
# Generated by Haxe 4.0.5
# coding: utf-8
import sys

import math as python_lib_Math
import math as Math
from os import path as python_lib_os_Path
import inspect as python_lib_Inspect
import os as python_lib_Os
import sched as a8_PySched
import sys as python_lib_Sys
from threading import Thread as python_lib_threading_Thread
import time as python_lib_Time
import shutil as a8_PyShutil2
import os as a8_PyOs2
import builtins as python_lib_Builtins
import functools as python_lib_Functools
import io as python_lib_Io
import json as python_lib_Json
import random as python_lib_Random
import re as python_lib_Re
import socket as python_lib_Socket
import ssl as python_lib_Ssl
import subprocess as python_lib_Subprocess
import timeit as python_lib_Timeit
import traceback as python_lib_Traceback
from datetime import datetime as python_lib_datetime_Datetime
from datetime import timezone as python_lib_datetime_Timezone
from io import StringIO as python_lib_io_StringIO
from socket import socket as python_lib_socket_Socket
from ssl import SSLContext as python_lib_ssl_SSLContext
from subprocess import Popen as python_lib_subprocess_Popen
import urllib.parse as python_lib_urllib_Parse


class _hx_AnonObject:
    _hx_disable_getattr = False
    def __init__(self, fields):
        self.__dict__ = fields
    def __repr__(self):
        return repr(self.__dict__)
    def __getattr__(self, name):
        if (self._hx_disable_getattr):
            raise AttributeError('field does not exist')
        else:
            return None
    def _hx_hasattr(self,field):
        self._hx_disable_getattr = True
        try:
            getattr(self, field)
            self._hx_disable_getattr = False
            return True
        except AttributeError:
            self._hx_disable_getattr = False
            return False



class Enum:
    _hx_class_name = "Enum"
    _hx_is_interface = "False"
    __slots__ = ("tag", "index", "params")
    _hx_fields = ["tag", "index", "params"]
    _hx_methods = ["__str__"]

    def __init__(self,tag,index,params):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/internal/EnumImpl.hx:39
        self.tag = tag
        # /Users/glen/tools-a8/packages/haxe/current/std/python/internal/EnumImpl.hx:40
        self.index = index
        # /Users/glen/tools-a8/packages/haxe/current/std/python/internal/EnumImpl.hx:41
        self.params = params

    def __str__(self):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/internal/EnumImpl.hx:46
        if (self.params is None):
            return self.tag
        else:
            return self.tag + '(' + (', '.join(str(v) for v in self.params)) + ')'

Enum._hx_class = Enum


class Class: pass


class Date:
    _hx_class_name = "Date"
    _hx_is_interface = "False"
    __slots__ = ("date", "dateUTC")
    _hx_fields = ["date", "dateUTC"]
    _hx_methods = ["toString"]
    _hx_statics = ["now", "fromTime", "makeLocal"]

    def __init__(self,year,month,day,hour,_hx_min,sec):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Date.hx:30
        self.dateUTC = None
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Date.hx:33
        if (year < python_lib_datetime_Datetime.min.year):
            year = python_lib_datetime_Datetime.min.year
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Date.hx:35
        if (day == 0):
            day = 1
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Date.hx:37
        self.date = Date.makeLocal(python_lib_datetime_Datetime(year,(month + 1),day,hour,_hx_min,sec,0))
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Date.hx:38
        self.dateUTC = self.date.astimezone(python_lib_datetime_Timezone.utc)

    def toString(self):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Date.hx:106
        return self.date.strftime("%Y-%m-%d %H:%M:%S")

    @staticmethod
    def now():
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Date.hx:110
        d = Date(2000,0,1,0,0,0)
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Date.hx:111
        d.date = Date.makeLocal(python_lib_datetime_Datetime.now())
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Date.hx:112
        d.dateUTC = d.date.astimezone(python_lib_datetime_Timezone.utc)
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Date.hx:113
        return d

    @staticmethod
    def fromTime(t):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Date.hx:117
        d = Date(2000,0,1,0,0,0)
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Date.hx:118
        d.date = Date.makeLocal(python_lib_datetime_Datetime.fromtimestamp((t / 1000.0)))
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Date.hx:119
        d.dateUTC = d.date.astimezone(python_lib_datetime_Timezone.utc)
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Date.hx:120
        return d

    @staticmethod
    def makeLocal(date):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Date.hx:124
        try:
            return date.astimezone()
        except Exception as _hx_e:
            _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
            e = _hx_e1
            # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Date.hx:129
            tzinfo = python_lib_datetime_Datetime.now(python_lib_datetime_Timezone.utc).astimezone().tzinfo
            # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Date.hx:130
            return date.replace(**python__KwArgs_KwArgs_Impl_.fromT(_hx_AnonObject({'tzinfo': tzinfo})))

Date._hx_class = Date


class EReg:
    _hx_class_name = "EReg"
    _hx_is_interface = "False"
    __slots__ = ("pattern", "matchObj", "_hx_global")
    _hx_fields = ["pattern", "matchObj", "global"]

    def __init__(self,r,opt):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/EReg.hx:31
        self.matchObj = None
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/EReg.hx:35
        self._hx_global = False
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/EReg.hx:36
        options = 0
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/EReg.hx:37
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/EReg.hx:37
        _g = 0
        _g1 = len(opt)
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/EReg.hx:38
            c = (-1 if ((i >= len(opt))) else ord(opt[i]))
            # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/EReg.hx:39
            if (c == 109):
                options = (options | python_lib_Re.M)
            # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/EReg.hx:41
            if (c == 105):
                options = (options | python_lib_Re.I)
            # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/EReg.hx:43
            if (c == 115):
                options = (options | python_lib_Re.S)
            # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/EReg.hx:45
            if (c == 117):
                options = (options | python_lib_Re.U)
            # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/EReg.hx:47
            if (c == 103):
                self._hx_global = True
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/EReg.hx:50
        self.pattern = python_lib_Re.compile(r,options)

EReg._hx_class = EReg


class Lambda:
    _hx_class_name = "Lambda"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["array", "exists", "iter", "find"]

    @staticmethod
    def array(it):
        # /Users/glen/tools-a8/packages/haxe/current/std/Lambda.hx:46
        a = list()
        # /Users/glen/tools-a8/packages/haxe/current/std/Lambda.hx:47
        # /Users/glen/tools-a8/packages/haxe/current/std/Lambda.hx:47
        i = HxOverrides.iterator(it)
        while i.hasNext():
            i1 = i.next()
            # /Users/glen/tools-a8/packages/haxe/current/std/Lambda.hx:48
            a.append(i1)
        # /Users/glen/tools-a8/packages/haxe/current/std/Lambda.hx:49
        return a

    @staticmethod
    def exists(it,f):
        # /Users/glen/tools-a8/packages/haxe/current/std/Lambda.hx:126
        # /Users/glen/tools-a8/packages/haxe/current/std/Lambda.hx:126
        x = HxOverrides.iterator(it)
        while x.hasNext():
            x1 = x.next()
            # /Users/glen/tools-a8/packages/haxe/current/std/Lambda.hx:127
            if f(x1):
                return True
        # /Users/glen/tools-a8/packages/haxe/current/std/Lambda.hx:129
        return False

    @staticmethod
    def iter(it,f):
        # /Users/glen/tools-a8/packages/haxe/current/std/Lambda.hx:157
        x = HxOverrides.iterator(it)
        while x.hasNext():
            x1 = x.next()
            # /Users/glen/tools-a8/packages/haxe/current/std/Lambda.hx:158
            f(x1)

    @staticmethod
    def find(it,f):
        # /Users/glen/tools-a8/packages/haxe/current/std/Lambda.hx:242
        # /Users/glen/tools-a8/packages/haxe/current/std/Lambda.hx:242
        v = HxOverrides.iterator(it)
        while v.hasNext():
            v1 = v.next()
            # /Users/glen/tools-a8/packages/haxe/current/std/Lambda.hx:243
            if f(v1):
                return v1
        # /Users/glen/tools-a8/packages/haxe/current/std/Lambda.hx:246
        return None
Lambda._hx_class = Lambda


class Reflect:
    _hx_class_name = "Reflect"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["field", "setField", "isFunction", "compareMethods", "copy"]

    @staticmethod
    def field(o,field):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Reflect.hx:43
        return python_Boot.field(o,field)

    @staticmethod
    def setField(o,field,value):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Reflect.hx:48
        setattr(o,(("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field)),value)

    @staticmethod
    def isFunction(f):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Reflect.hx:84
        if (not ((python_lib_Inspect.isfunction(f) or python_lib_Inspect.ismethod(f)))):
            return python_Boot.hasField(f,"func_code")
        else:
            return True

    @staticmethod
    def compareMethods(f1,f2):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Reflect.hx:98
        if HxOverrides.eq(f1,f2):
            return True
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Reflect.hx:100
        if (isinstance(f1,python_internal_MethodClosure) and isinstance(f2,python_internal_MethodClosure)):
            # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Reflect.hx:101
            m1 = f1
            # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Reflect.hx:102
            m2 = f2
            # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Reflect.hx:103
            if HxOverrides.eq(m1.obj,m2.obj):
                return (m1.func == m2.func)
            else:
                return False
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Reflect.hx:105
        if ((not Reflect.isFunction(f1)) or (not Reflect.isFunction(f2))):
            return False
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Reflect.hx:108
        return False

    @staticmethod
    def copy(o):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Reflect.hx:131
        if (o is None):
            return None
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Reflect.hx:133
        o2 = _hx_AnonObject({})
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Reflect.hx:134
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Reflect.hx:134
        _g = 0
        _g1 = python_Boot.fields(o)
        while (_g < len(_g1)):
            f = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Reflect.hx:135
            # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Reflect.hx:135
            value = Reflect.field(o,f)
            setattr(o2,(("_hx_" + f) if ((f in python_Boot.keywords)) else (("_hx_" + f) if (((((len(f) > 2) and ((ord(f[0]) == 95))) and ((ord(f[1]) == 95))) and ((ord(f[(len(f) - 1)]) != 95)))) else f)),value)
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Reflect.hx:136
        return o2
Reflect._hx_class = Reflect


class Std:
    _hx_class_name = "Std"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["downcast", "is", "string", "parseInt"]

    @staticmethod
    def downcast(value,c):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Std.hx:35
        try:
            # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Std.hx:36
            tmp = None
            if (not isinstance(value,c)):
                if c._hx_is_interface:
                    cls = c
                    loop = None
                    def _hx_local_1(intf):
                        f = (intf._hx_interfaces if (hasattr(intf,"_hx_interfaces")) else [])
                        if (f is not None):
                            _g = 0
                            while (_g < len(f)):
                                i = (f[_g] if _g >= 0 and _g < len(f) else None)
                                _g = (_g + 1)
                                if (i == cls):
                                    return True
                                else:
                                    l = loop(i)
                                    if l:
                                        return True
                            return False
                        else:
                            return False
                    loop = _hx_local_1
                    currentClass = value.__class__
                    result = False
                    while (currentClass is not None):
                        if loop(currentClass):
                            result = True
                            break
                        currentClass = python_Boot.getSuperClass(currentClass)
                    tmp = result
                else:
                    tmp = False
            else:
                tmp = True
            if tmp:
                return value
            else:
                return None
        except Exception as _hx_e:
            _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
            e = _hx_e1
            return None

    @staticmethod
    def _hx_is(v,t):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Std.hx:55
        if ((v is None) and ((t is None))):
            return False
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Std.hx:58
        if (t is None):
            return False
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Std.hx:61
        if (t == Dynamic):
            return (v is not None)
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Std.hx:64
        isBool = isinstance(v,bool)
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Std.hx:66
        if ((t == Bool) and isBool):
            return True
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Std.hx:69
        if ((((not isBool) and (not (t == Bool))) and (t == Int)) and isinstance(v,int)):
            return True
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Std.hx:72
        vIsFloat = isinstance(v,float)
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Std.hx:74
        tmp = None
        tmp1 = None
        if (((not isBool) and vIsFloat) and (t == Int)):
            f = v
            tmp1 = (((f != Math.POSITIVE_INFINITY) and ((f != Math.NEGATIVE_INFINITY))) and (not python_lib_Math.isnan(f)))
        else:
            tmp1 = False
        if tmp1:
            tmp2 = None
            try:
                tmp2 = int(v)
            except Exception as _hx_e:
                _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
                e = _hx_e1
                tmp2 = None
            tmp = (v == tmp2)
        else:
            tmp = False
        if ((tmp and ((v <= 2147483647))) and ((v >= -2147483648))):
            return True
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Std.hx:78
        if (((not isBool) and (t == Float)) and isinstance(v,(float, int))):
            return True
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Std.hx:82
        if (t == str):
            return isinstance(v,str)
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Std.hx:85
        isEnumType = (t == Enum)
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Std.hx:86
        if ((isEnumType and python_lib_Inspect.isclass(v)) and hasattr(v,"_hx_constructs")):
            return True
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Std.hx:89
        if isEnumType:
            return False
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Std.hx:92
        isClassType = (t == Class)
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Std.hx:93
        if ((((isClassType and (not isinstance(v,Enum))) and python_lib_Inspect.isclass(v)) and hasattr(v,"_hx_class_name")) and (not hasattr(v,"_hx_constructs"))):
            return True
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Std.hx:100
        if isClassType:
            return False
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Std.hx:103
        tmp3 = None
        try:
            tmp3 = isinstance(v,t)
        except Exception as _hx_e:
            _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
            e1 = _hx_e1
            tmp3 = False
        if tmp3:
            return True
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Std.hx:107
        if python_lib_Inspect.isclass(t):
            # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Std.hx:108
            cls = t
            loop = None
            def _hx_local_1(intf):
                f1 = (intf._hx_interfaces if (hasattr(intf,"_hx_interfaces")) else [])
                if (f1 is not None):
                    _g = 0
                    while (_g < len(f1)):
                        i = (f1[_g] if _g >= 0 and _g < len(f1) else None)
                        _g = (_g + 1)
                        if (i == cls):
                            return True
                        else:
                            l = loop(i)
                            if l:
                                return True
                    return False
                else:
                    return False
            loop = _hx_local_1
            currentClass = v.__class__
            result = False
            while (currentClass is not None):
                if loop(currentClass):
                    result = True
                    break
                currentClass = python_Boot.getSuperClass(currentClass)
            return result
        else:
            return False

    @staticmethod
    def string(s):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Std.hx:116
        return python_Boot.toString1(s,"")

    @staticmethod
    def parseInt(x):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Std.hx:128
        if (x is None):
            return None
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Std.hx:130
        try:
            return int(x)
        except Exception as _hx_e:
            _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
            e = _hx_e1
            # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Std.hx:133
            base = 10
            # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Std.hx:134
            _hx_len = len(x)
            # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Std.hx:135
            foundCount = 0
            # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Std.hx:136
            sign = 0
            # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Std.hx:137
            firstDigitIndex = 0
            # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Std.hx:138
            lastDigitIndex = -1
            # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Std.hx:139
            previous = 0
            # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Std.hx:141
            # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Std.hx:141
            _g = 0
            _g1 = _hx_len
            while (_g < _g1):
                i = _g
                _g = (_g + 1)
                # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Std.hx:142
                c = (-1 if ((i >= len(x))) else ord(x[i]))
                # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Std.hx:143
                if (((c > 8) and ((c < 14))) or ((c == 32))):
                    # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Std.hx:145
                    if (foundCount > 0):
                        return None
                    # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Std.hx:148
                    continue
                else:
                    # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Std.hx:143
                    c1 = c
                    # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Std.hx:151
                    if (c1 == 43):
                        if (foundCount == 0):
                            sign = 1
                        elif (not (((48 <= c) and ((c <= 57))))):
                            if (not (((base == 16) and ((((97 <= c) and ((c <= 122))) or (((65 <= c) and ((c <= 90))))))))):
                                break
                    elif (c1 == 45):
                        if (foundCount == 0):
                            sign = -1
                        elif (not (((48 <= c) and ((c <= 57))))):
                            if (not (((base == 16) and ((((97 <= c) and ((c <= 122))) or (((65 <= c) and ((c <= 90))))))))):
                                break
                    elif (c1 == 48):
                        if (not (((foundCount == 0) or (((foundCount == 1) and ((sign != 0))))))):
                            if (not (((48 <= c) and ((c <= 57))))):
                                if (not (((base == 16) and ((((97 <= c) and ((c <= 122))) or (((65 <= c) and ((c <= 90))))))))):
                                    break
                    elif ((c1 == 120) or ((c1 == 88))):
                        if ((previous == 48) and ((((foundCount == 1) and ((sign == 0))) or (((foundCount == 2) and ((sign != 0))))))):
                            base = 16
                        elif (not (((48 <= c) and ((c <= 57))))):
                            if (not (((base == 16) and ((((97 <= c) and ((c <= 122))) or (((65 <= c) and ((c <= 90))))))))):
                                break
                    elif (not (((48 <= c) and ((c <= 57))))):
                        if (not (((base == 16) and ((((97 <= c) and ((c <= 122))) or (((65 <= c) and ((c <= 90))))))))):
                            break
                # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Std.hx:161
                if (((foundCount == 0) and ((sign == 0))) or (((foundCount == 1) and ((sign != 0))))):
                    firstDigitIndex = i
                # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Std.hx:164
                foundCount = (foundCount + 1)
                # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Std.hx:165
                lastDigitIndex = i
                # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Std.hx:166
                previous = c
            # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Std.hx:168
            if (firstDigitIndex <= lastDigitIndex):
                # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Std.hx:169
                digits = HxString.substring(x,firstDigitIndex,(lastDigitIndex + 1))
                # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Std.hx:170
                try:
                    return (((-1 if ((sign == -1)) else 1)) * int(digits,base))
                except Exception as _hx_e:
                    _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
                    e1 = _hx_e1
                    return None
            # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Std.hx:176
            return None
Std._hx_class = Std


class Float: pass


class Int: pass


class Bool: pass


class Dynamic: pass


class StringBuf:
    _hx_class_name = "StringBuf"
    _hx_is_interface = "False"
    __slots__ = ("b",)
    _hx_fields = ["b"]
    _hx_methods = ["get_length"]

    def __init__(self):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/StringBuf.hx:31
        self.b = python_lib_io_StringIO()

    def get_length(self):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/StringBuf.hx:37
        pos = self.b.tell()
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/StringBuf.hx:38
        self.b.seek(0,2)
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/StringBuf.hx:39
        _hx_len = self.b.tell()
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/StringBuf.hx:40
        self.b.seek(pos,0)
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/StringBuf.hx:41
        return _hx_len

StringBuf._hx_class = StringBuf


class StringTools:
    _hx_class_name = "StringTools"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["isSpace", "ltrim", "rtrim", "lpad", "rpad"]

    @staticmethod
    def isSpace(s,pos):
        # /Users/glen/tools-a8/packages/haxe/current/std/StringTools.hx:290
        if (((len(s) == 0) or ((pos < 0))) or ((pos >= len(s)))):
            return False
        # /Users/glen/tools-a8/packages/haxe/current/std/StringTools.hx:293
        c = HxString.charCodeAt(s,pos)
        # /Users/glen/tools-a8/packages/haxe/current/std/StringTools.hx:294
        if (not (((c > 8) and ((c < 14))))):
            return (c == 32)
        else:
            return True

    @staticmethod
    def ltrim(s):
        # /Users/glen/tools-a8/packages/haxe/current/std/StringTools.hx:310
        l = len(s)
        # /Users/glen/tools-a8/packages/haxe/current/std/StringTools.hx:311
        r = 0
        # /Users/glen/tools-a8/packages/haxe/current/std/StringTools.hx:312
        while ((r < l) and StringTools.isSpace(s,r)):
            r = (r + 1)
        # /Users/glen/tools-a8/packages/haxe/current/std/StringTools.hx:315
        if (r > 0):
            return HxString.substr(s,r,(l - r))
        else:
            return s

    @staticmethod
    def rtrim(s):
        # /Users/glen/tools-a8/packages/haxe/current/std/StringTools.hx:335
        l = len(s)
        # /Users/glen/tools-a8/packages/haxe/current/std/StringTools.hx:336
        r = 0
        # /Users/glen/tools-a8/packages/haxe/current/std/StringTools.hx:337
        while ((r < l) and StringTools.isSpace(s,((l - r) - 1))):
            r = (r + 1)
        # /Users/glen/tools-a8/packages/haxe/current/std/StringTools.hx:340
        if (r > 0):
            return HxString.substr(s,0,(l - r))
        else:
            return s

    @staticmethod
    def lpad(s,c,l):
        # /Users/glen/tools-a8/packages/haxe/current/std/StringTools.hx:376
        if (len(c) <= 0):
            return s
        # /Users/glen/tools-a8/packages/haxe/current/std/StringTools.hx:379
        buf = StringBuf()
        # /Users/glen/tools-a8/packages/haxe/current/std/StringTools.hx:380
        l = (l - len(s))
        # /Users/glen/tools-a8/packages/haxe/current/std/StringTools.hx:381
        while (buf.get_length() < l):
            # /Users/glen/tools-a8/packages/haxe/current/std/StringTools.hx:382
            s1 = Std.string(c)
            buf.b.write(s1)
        # /Users/glen/tools-a8/packages/haxe/current/std/StringTools.hx:384
        # /Users/glen/tools-a8/packages/haxe/current/std/StringTools.hx:384
        s2 = Std.string(s)
        buf.b.write(s2)
        # /Users/glen/tools-a8/packages/haxe/current/std/StringTools.hx:385
        return buf.b.getvalue()

    @staticmethod
    def rpad(s,c,l):
        # /Users/glen/tools-a8/packages/haxe/current/std/StringTools.hx:401
        if (len(c) <= 0):
            return s
        # /Users/glen/tools-a8/packages/haxe/current/std/StringTools.hx:404
        buf = StringBuf()
        # /Users/glen/tools-a8/packages/haxe/current/std/StringTools.hx:405
        # /Users/glen/tools-a8/packages/haxe/current/std/StringTools.hx:405
        s1 = Std.string(s)
        buf.b.write(s1)
        # /Users/glen/tools-a8/packages/haxe/current/std/StringTools.hx:406
        while (buf.get_length() < l):
            # /Users/glen/tools-a8/packages/haxe/current/std/StringTools.hx:407
            s2 = Std.string(c)
            buf.b.write(s2)
        # /Users/glen/tools-a8/packages/haxe/current/std/StringTools.hx:409
        return buf.b.getvalue()
StringTools._hx_class = StringTools


class sys_FileSystem:
    _hx_class_name = "sys.FileSystem"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["exists", "fullPath", "isDirectory", "createDirectory", "deleteFile", "readDirectory"]

    @staticmethod
    def exists(path):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/sys/FileSystem.hx:31
        return python_lib_os_Path.exists(path)

    @staticmethod
    def fullPath(relPath):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/sys/FileSystem.hx:56
        return python_lib_os_Path.realpath(relPath)

    @staticmethod
    def isDirectory(path):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/sys/FileSystem.hx:66
        return python_lib_os_Path.isdir(path)

    @staticmethod
    def createDirectory(path):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/sys/FileSystem.hx:70
        python_lib_Os.makedirs(path,511,True)

    @staticmethod
    def deleteFile(path):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/sys/FileSystem.hx:74
        python_lib_Os.remove(path)

    @staticmethod
    def readDirectory(path):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/sys/FileSystem.hx:82
        return python_lib_Os.listdir(path)
sys_FileSystem._hx_class = sys_FileSystem


class haxe_IMap:
    _hx_class_name = "haxe.IMap"
    _hx_is_interface = "True"
    __slots__ = ()
    _hx_methods = ["get", "keys"]
haxe_IMap._hx_class = haxe_IMap


class haxe_ds_StringMap:
    _hx_class_name = "haxe.ds.StringMap"
    _hx_is_interface = "False"
    __slots__ = ("h",)
    _hx_fields = ["h"]
    _hx_methods = ["get", "keys"]
    _hx_interfaces = [haxe_IMap]

    def __init__(self):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/haxe/ds/StringMap.hx:32
        self.h = dict()

    def get(self,key):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/haxe/ds/StringMap.hx:40
        return self.h.get(key,None)

    def keys(self):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/haxe/ds/StringMap.hx:55
        return python_HaxeIterator(iter(self.h.keys()))

haxe_ds_StringMap._hx_class = haxe_ds_StringMap


class python_HaxeIterator:
    _hx_class_name = "python.HaxeIterator"
    _hx_is_interface = "False"
    __slots__ = ("it", "x", "has", "checked")
    _hx_fields = ["it", "x", "has", "checked"]
    _hx_methods = ["next", "hasNext"]

    def __init__(self,it):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/HaxeIterator.hx:32
        self.checked = False
        # /Users/glen/tools-a8/packages/haxe/current/std/python/HaxeIterator.hx:31
        self.has = False
        # /Users/glen/tools-a8/packages/haxe/current/std/python/HaxeIterator.hx:30
        self.x = None
        # /Users/glen/tools-a8/packages/haxe/current/std/python/HaxeIterator.hx:35
        self.it = it

    def next(self):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/HaxeIterator.hx:39
        if (not self.checked):
            self.hasNext()
        # /Users/glen/tools-a8/packages/haxe/current/std/python/HaxeIterator.hx:41
        self.checked = False
        # /Users/glen/tools-a8/packages/haxe/current/std/python/HaxeIterator.hx:42
        return self.x

    def hasNext(self):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/HaxeIterator.hx:46
        if (not self.checked):
            # /Users/glen/tools-a8/packages/haxe/current/std/python/HaxeIterator.hx:47
            try:
                # /Users/glen/tools-a8/packages/haxe/current/std/python/HaxeIterator.hx:48
                self.x = self.it.__next__()
                # /Users/glen/tools-a8/packages/haxe/current/std/python/HaxeIterator.hx:49
                self.has = True
            except Exception as _hx_e:
                _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
                if isinstance(_hx_e1, StopIteration):
                    s = _hx_e1
                    # /Users/glen/tools-a8/packages/haxe/current/std/python/HaxeIterator.hx:51
                    self.has = False
                    # /Users/glen/tools-a8/packages/haxe/current/std/python/HaxeIterator.hx:52
                    self.x = None
                else:
                    raise _hx_e
            # /Users/glen/tools-a8/packages/haxe/current/std/python/HaxeIterator.hx:54
            self.checked = True
        # /Users/glen/tools-a8/packages/haxe/current/std/python/HaxeIterator.hx:56
        return self.has

python_HaxeIterator._hx_class = python_HaxeIterator


class Sys:
    _hx_class_name = "Sys"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["environ", "exit", "environment", "systemName", "_programPath", "programPath"]

    @staticmethod
    def exit(code):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Sys.hx:44
        python_lib_Sys.exit(code)

    @staticmethod
    def environment():
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Sys.hx:70
        return Sys.environ

    @staticmethod
    def systemName():
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Sys.hx:90
        _g = python_lib_Sys.platform
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Sys.hx:91
        x = _g
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Sys.hx:90
        if x.startswith("linux"):
            return "Linux"
        else:
            # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Sys.hx:90
            _g1 = _g
            _hx_local_0 = len(_g1)
            # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Sys.hx:94
            if (_hx_local_0 == 5):
                if (_g1 == "win32"):
                    return "Windows"
                else:
                    raise _HxException("not supported platform")
            elif (_hx_local_0 == 6):
                if (_g1 == "cygwin"):
                    return "Windows"
                elif (_g1 == "darwin"):
                    return "Mac"
                else:
                    raise _HxException("not supported platform")
            else:
                raise _HxException("not supported platform")

    @staticmethod
    def programPath():
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Sys.hx:119
        return Sys._programPath
Sys._hx_class = Sys

class ValueType(Enum):
    __slots__ = ()
    _hx_class_name = "ValueType"
    _hx_constructs = ["TNull", "TInt", "TFloat", "TBool", "TObject", "TFunction", "TClass", "TEnum", "TUnknown"]

    @staticmethod
    def TClass(c):
        return ValueType("TClass", 6, (c,))

    @staticmethod
    def TEnum(e):
        return ValueType("TEnum", 7, (e,))
ValueType.TNull = ValueType("TNull", 0, ())
ValueType.TInt = ValueType("TInt", 1, ())
ValueType.TFloat = ValueType("TFloat", 2, ())
ValueType.TBool = ValueType("TBool", 3, ())
ValueType.TObject = ValueType("TObject", 4, ())
ValueType.TFunction = ValueType("TFunction", 5, ())
ValueType.TUnknown = ValueType("TUnknown", 8, ())
ValueType._hx_class = ValueType


class Type:
    _hx_class_name = "Type"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["getClass", "typeof"]

    @staticmethod
    def getClass(o):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Type.hx:44
        if (o is None):
            return None
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Type.hx:47
        o1 = o
        if ((o1 is not None) and ((HxOverrides.eq(o1,str) or python_lib_Inspect.isclass(o1)))):
            return None
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Type.hx:50
        if isinstance(o,_hx_AnonObject):
            return None
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Type.hx:53
        if hasattr(o,"_hx_class"):
            return o._hx_class
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Type.hx:56
        if hasattr(o,"__class__"):
            return o.__class__
        else:
            return None

    @staticmethod
    def typeof(v):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Type.hx:180
        if (v is None):
            return ValueType.TNull
        elif isinstance(v,bool):
            return ValueType.TBool
        elif isinstance(v,int):
            return ValueType.TInt
        elif isinstance(v,float):
            return ValueType.TFloat
        elif isinstance(v,str):
            return ValueType.TClass(str)
        elif isinstance(v,list):
            return ValueType.TClass(list)
        elif (isinstance(v,_hx_AnonObject) or python_lib_Inspect.isclass(v)):
            return ValueType.TObject
        elif isinstance(v,Enum):
            return ValueType.TEnum(v.__class__)
        elif (isinstance(v,type) or hasattr(v,"_hx_class")):
            return ValueType.TClass(v.__class__)
        elif callable(v):
            return ValueType.TFunction
        else:
            return ValueType.TUnknown
Type._hx_class = Type


class a8_DateOps:
    _hx_class_name = "a8.DateOps"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["midnight"]

    @staticmethod
    def midnight():
        # src/a8/DateOps.hx:7
        now = Date.now()
        # src/a8/DateOps.hx:8
        oneSecondBeforeMidnight = Date(now.date.year,(now.date.month - 1),now.date.day,23,59,59)
        # src/a8/DateOps.hx:9
        return Date.fromTime(((oneSecondBeforeMidnight.date.timestamp() * 1000) + 1000))
a8_DateOps._hx_class = a8_DateOps


class a8_Exception:
    _hx_class_name = "a8.Exception"
    _hx_is_interface = "False"
    __slots__ = ("message", "causedBy", "callStack", "posInfos")
    _hx_fields = ["message", "causedBy", "callStack", "posInfos"]
    _hx_methods = ["toString", "rethrow"]
    _hx_statics = ["thro"]

    def __init__(self,message,causedBy = None,posInfos = None):
        # src/a8/Exception.hx:19
        self.message = message
        # src/a8/Exception.hx:20
        self.causedBy = a8_OptionOps.toOption(causedBy)
        # src/a8/Exception.hx:21
        self.callStack = haxe_CallStack.callStack()
        # src/a8/Exception.hx:22
        self.posInfos = posInfos

    def toString(self):
        # src/a8/Exception.hx:26
        return ((((((HxOverrides.stringOrNull(self.posInfos.fileName) + ":") + Std.string(self.posInfos.lineNumber)) + " ") + HxOverrides.stringOrNull(self.message)) + "\n") + HxOverrides.stringOrNull(a8_HaxeOps2.asString(self.callStack,"    ")))

    def rethrow(self,context,posInfos = None):
        # src/a8/Exception.hx:35
        raise _HxException(a8_Exception(context,self,posInfos))

    @staticmethod
    def thro(message):
        # src/a8/Exception.hx:10
        raise _HxException(a8_Exception(message,None,_hx_AnonObject({'fileName': "src/a8/Exception.hx", 'lineNumber': 10, 'className': "a8.Exception", 'methodName': "thro"})))

a8_Exception._hx_class = a8_Exception


class a8_Exec:
    _hx_class_name = "a8.Exec"
    _hx_is_interface = "False"
    __slots__ = ("args", "cwd", "env", "failOnNonZeroExitCode", "executable")
    _hx_fields = ["args", "cwd", "env", "failOnNonZeroExitCode", "executable"]
    _hx_methods = ["asCommandLine", "execInline", "execCapture"]

    def __init__(self):
        # src/a8/Exec.hx:16
        self.failOnNonZeroExitCode = True
        # src/a8/Exec.hx:13
        self.args = []
        # src/a8/Exec.hx:14
        self.cwd = haxe_ds_Option._hx_None
        # src/a8/Exec.hx:15
        self.env = haxe_ds_Option._hx_None
        # src/a8/Exec.hx:17
        self.executable = haxe_ds_Option._hx_None

    def asCommandLine(self):
        # src/a8/Exec.hx:23
        _this = self.args
        return " ".join([python_Boot.toString1(x1,'') for x1 in _this])

    def execInline(self):
        # src/a8/Exec.hx:31
        a8_Logger.trace(("running -- " + HxOverrides.stringOrNull(self.asCommandLine())),_hx_AnonObject({'fileName': "src/a8/Exec.hx", 'lineNumber': 31, 'className': "a8.Exec", 'methodName': "execInline"}))
        # src/a8/Exec.hx:32
        exitCode = python_lib_Subprocess.call(self.args,**python__KwArgs_KwArgs_Impl_.fromT(_hx_AnonObject({'cwd': a8_OptionOps.getOrElse(self.cwd,None)})))
        # src/a8/Exec.hx:39
        if ((exitCode != 0) and self.failOnNonZeroExitCode):
            a8_Exception.thro(((("non-zero exit code of " + Std.string(exitCode)) + " while executing -- ") + HxOverrides.stringOrNull(self.asCommandLine())))
        # src/a8/Exec.hx:42
        return exitCode

    def execCapture(self):
        # src/a8/Exec.hx:49
        a8_Logger.trace(("running -- " + HxOverrides.stringOrNull(self.asCommandLine())),_hx_AnonObject({'fileName': "src/a8/Exec.hx", 'lineNumber': 49, 'className': "a8.Exec", 'methodName': "execCapture"}))
        # src/a8/Exec.hx:52
        popen = self.args
        # src/a8/Exec.hx:54
        popen1 = a8_OptionOps.getOrElse(self.executable,(self.args[0] if 0 < len(self.args) else None))
        # src/a8/Exec.hx:56
        popen2 = python_lib_Subprocess.PIPE
        # src/a8/Exec.hx:57
        popen3 = python_lib_Subprocess.PIPE
        # src/a8/Exec.hx:61
        popen4 = a8_OptionOps.getOrElse(self.cwd,None)
        # src/a8/Exec.hx:62
        o = self.env
        popen5 = None
        if (o.index == 0):
            v = o.params[0]
            popen5 = haxe_ds_Option.Some(a8_PyOps.toDict(v))
        else:
            popen5 = haxe_ds_Option._hx_None
        # src/a8/Exec.hx:50
        popen6 = python_lib_subprocess_Popen(popen,None,popen1,None,popen2,popen3,None,False,False,popen4,a8_OptionOps.getOrElse(popen5,None))
        # src/a8/Exec.hx:65
        def _hx_local_0(out):
            pass
        firstIO = _hx_local_0
        # src/a8/Exec.hx:68
        timestampStr = a8_PathOps.timestampStr()
        # src/a8/Exec.hx:70
        stdoutCapture = haxe_io_BytesOutput()
        # src/a8/Exec.hx:71
        stderrCapture = haxe_io_BytesOutput()
        # src/a8/Exec.hx:73
        pipedStdout = a8_Pipe(a8_StreamOps.asInputStream(popen6.stdout),a8_StreamOps2.asOutputStream(stdoutCapture),firstIO)
        # src/a8/Exec.hx:74
        pipedStderr = a8_Pipe(a8_StreamOps.asInputStream(popen6.stderr),a8_StreamOps2.asOutputStream(stderrCapture),firstIO)
        # src/a8/Exec.hx:76
        pipedStdout.run()
        # src/a8/Exec.hx:77
        pipedStderr.run()
        # src/a8/Exec.hx:79
        popen6.wait()
        # src/a8/Exec.hx:81
        result = _hx_AnonObject({'exitCode': popen6.returncode, 'stderr': a8_HaxeOps.asString(stderrCapture.getBytes()), 'stdout': a8_HaxeOps.asString(stdoutCapture.getBytes())})
        # src/a8/Exec.hx:88
        a8_Logger.trace(("" + Std.string(result.exitCode)),_hx_AnonObject({'fileName': "src/a8/Exec.hx", 'lineNumber': 88, 'className': "a8.Exec", 'methodName': "execCapture"}))
        # src/a8/Exec.hx:89
        if ((result.exitCode != 0) and self.failOnNonZeroExitCode):
            a8_Exception.thro(((("non-zero exit code of " + Std.string(result.exitCode)) + " while executing -- ") + HxOverrides.stringOrNull(self.asCommandLine())))
        # src/a8/Exec.hx:93
        return result

a8_Exec._hx_class = a8_Exec


class a8_PyOps:
    _hx_class_name = "a8.PyOps"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["toDict", "spawn"]

    @staticmethod
    def toDict(_hx_map):
        # src/a8/PyOps.hx:53
        _hx_dict = dict()
        # src/a8/PyOps.hx:54
        # src/a8/PyOps.hx:54
        k = _hx_map.keys()
        while k.hasNext():
            k1 = k.next()
            # src/a8/PyOps.hx:55
            _hx_dict[k1] = _hx_map.get(k1)
        # src/a8/PyOps.hx:57
        return _hx_dict

    @staticmethod
    def spawn(fn):
        # src/a8/PyOps.hx:62
        th = python_lib_threading_Thread(**python__KwArgs_KwArgs_Impl_.fromT(_hx_AnonObject({'target': fn})))
        # src/a8/PyOps.hx:63
        th.daemon = True
        # src/a8/PyOps.hx:64
        th.start()
        # src/a8/PyOps.hx:66
        return th
a8_PyOps._hx_class = a8_PyOps


class python__KwArgs_KwArgs_Impl_:
    _hx_class_name = "python._KwArgs.KwArgs_Impl_"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["fromT"]

    @staticmethod
    def fromT(d):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/KwArgs.hx:59
        this1 = python_Lib.anonAsDict(d)
        return this1
python__KwArgs_KwArgs_Impl_._hx_class = python__KwArgs_KwArgs_Impl_


class python_Lib:
    _hx_class_name = "python.Lib"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["lineEnd", "printString", "dictToAnon", "anonToDict", "anonAsDict"]
    __name__ = None

    @staticmethod
    def printString(_hx_str):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/Lib.hx:51
        encoding = "utf-8"
        # /Users/glen/tools-a8/packages/haxe/current/std/python/NativeStringTools.hx:33
        if (encoding is None):
            encoding = "utf-8"
        # /Users/glen/tools-a8/packages/haxe/current/std/python/Lib.hx:51
        python_lib_Sys.stdout.buffer.write(_hx_str.encode(encoding, "strict"))
        # /Users/glen/tools-a8/packages/haxe/current/std/python/Lib.hx:52
        python_lib_Sys.stdout.flush()

    @staticmethod
    def dictToAnon(v):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/Lib.hx:67
        return _hx_AnonObject(v.copy())

    @staticmethod
    def anonToDict(o):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/Lib.hx:75
        if isinstance(o,_hx_AnonObject):
            return o.__dict__.copy()
        else:
            return None

    @staticmethod
    def anonAsDict(o):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/Lib.hx:86
        if isinstance(o,_hx_AnonObject):
            return o.__dict__
        else:
            return None
python_Lib._hx_class = python_Lib


class a8_GlobalScheduler:
    _hx_class_name = "a8.GlobalScheduler"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["scheduler", "schedule", "submit"]

    @staticmethod
    def schedule(delayInSeconds,fn):
        # src/a8/GlobalScheduler.hx:22
        a8_GlobalScheduler.scheduler.enter(delayInSeconds,1.0,fn)

    @staticmethod
    def submit(fn):
        # src/a8/GlobalScheduler.hx:26
        a8_GlobalScheduler.schedule(0,fn)
a8_GlobalScheduler._hx_class = a8_GlobalScheduler


class a8_HaxeOps:
    _hx_class_name = "a8.HaxeOps"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["asString", "toMap", "isDigit", "isAlpha", "isWhitespace", "isHaxeIdentifierFirstChar", "isHaxeIdentifierSecondChar"]

    @staticmethod
    def asString(_hx_bytes):
        # src/a8/HaxeOps.hx:12
        return _hx_bytes.getString(0,_hx_bytes.length)

    @staticmethod
    def toMap(iterable,keyFn):
        # src/a8/HaxeOps.hx:16
        _hx_map = haxe_ds_StringMap()
        # src/a8/HaxeOps.hx:17
        def _hx_local_0(a):
            # src/a8/HaxeOps.hx:17
            key = keyFn(a)
            _hx_map.h[key] = a
        Lambda.iter(iterable,_hx_local_0)
        # src/a8/HaxeOps.hx:18
        return _hx_map

    @staticmethod
    def isDigit(ch):
        # src/a8/HaxeOps.hx:23
        if ((len(ch) == 1) and ((ch >= "0"))):
            return (ch <= "0")
        else:
            return False

    @staticmethod
    def isAlpha(ch):
        # src/a8/HaxeOps.hx:29
        if (len(ch) == 1):
            if (not (((ch >= "A") and ((ch <= "Z"))))):
                if (ch >= "a"):
                    return (ch <= "z")
                else:
                    return False
            else:
                return True
        else:
            return False

    @staticmethod
    def isWhitespace(ch):
        # src/a8/HaxeOps.hx:37
        ch1 = ch
        # src/a8/HaxeOps.hx:39
        if ((((ch1 == " ") or ((ch1 == "\r"))) or ((ch1 == "\n"))) or ((ch1 == "\t"))):
            return True
        else:
            return False

    @staticmethod
    def isHaxeIdentifierFirstChar(ch):
        # src/a8/HaxeOps.hx:47
        if (len(ch) == 1):
            if (not a8_HaxeOps.isAlpha(ch)):
                return (ch == "_")
            else:
                return True
        else:
            return False

    @staticmethod
    def isHaxeIdentifierSecondChar(ch):
        # src/a8/HaxeOps.hx:56
        if (not a8_HaxeOps.isHaxeIdentifierFirstChar(ch)):
            return a8_HaxeOps.isDigit(ch)
        else:
            return True
a8_HaxeOps._hx_class = a8_HaxeOps


class a8_HaxeOps2:
    _hx_class_name = "a8.HaxeOps2"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["asString", "toMap"]

    @staticmethod
    def asString(stack,indent = None):
        # src/a8/HaxeOps.hx:67
        if (indent is None):
            indent = ""
        # src/a8/HaxeOps.hx:71
        def _hx_local_0(si):
            # src/a8/HaxeOps.hx:71
            _this1 = Std.string(si)
            return (("null" if indent is None else indent) + ("null" if _this1 is None else _this1))
        # src/a8/HaxeOps.hx:70
        _this = list(map(_hx_local_0,stack))
        s = "\n".join([python_Boot.toString1(x1,'') for x1 in _this])
        # src/a8/HaxeOps.hx:73
        return s

    @staticmethod
    def toMap(iterable):
        # src/a8/HaxeOps.hx:77
        _hx_map = haxe_ds_StringMap()
        # src/a8/HaxeOps.hx:78
        # src/a8/HaxeOps.hx:78
        t = HxOverrides.iterator(iterable)
        while t.hasNext():
            t1 = t.next()
            # src/a8/HaxeOps.hx:79
            _hx_map.h[python_internal_ArrayImpl._get(t1, 0)] = python_internal_ArrayImpl._get(t1, 1)
        # src/a8/HaxeOps.hx:81
        return _hx_map
a8_HaxeOps2._hx_class = a8_HaxeOps2


class a8_Logger:
    _hx_class_name = "a8.Logger"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["traceEnabled", "trace", "warn"]

    @staticmethod
    def trace(msg,posInfo = None):
        # src/a8/Logger.hx:12
        if a8_Logger.traceEnabled:
            haxe_Log.trace(("TRACE - " + ("null" if msg is None else msg)),posInfo)

    @staticmethod
    def warn(msg,posInfo = None):
        # src/a8/Logger.hx:18
        haxe_Log.trace(("WARN - " + ("null" if msg is None else msg)),posInfo)
a8_Logger._hx_class = a8_Logger


class a8_OptionOps:
    _hx_class_name = "a8.OptionOps"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["toOption", "nonEmpty", "isEmpty", "getOrError", "getOrElse", "getOrElseFn", "get", "iter"]

    @staticmethod
    def toOption(a):
        # src/a8/OptionOps.hx:14
        if (a is None):
            return haxe_ds_Option._hx_None
        else:
            return haxe_ds_Option.Some(a)

    @staticmethod
    def nonEmpty(o):
        # src/a8/OptionOps.hx:20
        tmp = o.index
        # src/a8/OptionOps.hx:21
        if (tmp == 0):
            # src/a8/OptionOps.hx:21
            _g = o.params[0]
            return True
        elif (tmp == 1):
            return False
        else:
            pass

    @staticmethod
    def isEmpty(o):
        # src/a8/OptionOps.hx:27
        return (not a8_OptionOps.nonEmpty(o))

    @staticmethod
    def getOrError(o,msg):
        # src/a8/OptionOps.hx:33
        tmp = o.index
        # src/a8/OptionOps.hx:34
        if (tmp == 0):
            # src/a8/OptionOps.hx:34
            i = o.params[0]
            return i
        elif (tmp == 1):
            raise _HxException(a8_Exception(msg,None,_hx_AnonObject({'fileName': "src/a8/OptionOps.hx", 'lineNumber': 35, 'className': "a8.OptionOps", 'methodName': "getOrError"})))
        else:
            pass

    @staticmethod
    def getOrElse(o,_hx_def):
        # src/a8/OptionOps.hx:41
        tmp = o.index
        # src/a8/OptionOps.hx:42
        if (tmp == 0):
            # src/a8/OptionOps.hx:42
            i = o.params[0]
            return i
        elif (tmp == 1):
            return _hx_def
        else:
            pass

    @staticmethod
    def getOrElseFn(o,_hx_def):
        # src/a8/OptionOps.hx:49
        tmp = o.index
        # src/a8/OptionOps.hx:50
        if (tmp == 0):
            # src/a8/OptionOps.hx:50
            i = o.params[0]
            return i
        elif (tmp == 1):
            return _hx_def()
        else:
            pass

    @staticmethod
    def get(o):
        # src/a8/OptionOps.hx:56
        return a8_OptionOps.getOrError(o,"expected a Some")

    @staticmethod
    def iter(o,fn):
        # src/a8/OptionOps.hx:61
        tmp = o.index
        # src/a8/OptionOps.hx:62
        if (tmp == 0):
            # src/a8/OptionOps.hx:62
            a = o.params[0]
            fn(a)
        elif (tmp == 1):
            pass
        else:
            pass
        # src/a8/OptionOps.hx:60
        return
a8_OptionOps._hx_class = a8_OptionOps


class a8_PathOps:
    _hx_class_name = "a8.PathOps"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["timestampStr", "path", "symlinkChain", "executablePath", "userHome", "absPath", "name", "programPath", "readText", "readLines", "makeDirectories", "readBytes", "exists", "isAbsolute", "files", "basename", "moveTo", "deleteFile", "entries", "isFile", "isDir", "realPathStr", "writeBytes", "writeText", "parent", "entry", "outputStream", "readProperties"]

    @staticmethod
    def timestampStr():
        # src/a8/PathOps.hx:14
        now = Date.now()
        # src/a8/PathOps.hx:16
        def _hx_local_0(i):
            # src/a8/PathOps.hx:16
            return StringTools.lpad(("" + Std.string(i)),"0",2)
        # src/a8/PathOps.hx:15
        pad = _hx_local_0
        # src/a8/PathOps.hx:18
        return ((((((Std.string(now.date.year) + HxOverrides.stringOrNull(pad((now.date.month - 1)))) + HxOverrides.stringOrNull(pad(now.date.day))) + "_") + HxOverrides.stringOrNull(pad(now.date.hour))) + HxOverrides.stringOrNull(pad(now.date.minute))) + HxOverrides.stringOrNull(pad(now.date.second)))

    @staticmethod
    def path(p):
        # src/a8/PathOps.hx:22
        return haxe_io_Path(p)

    @staticmethod
    def symlinkChain(p):
        # src/a8/PathOps.hx:26
        paths = []
        # src/a8/PathOps.hx:27
        impl = None
        def _hx_local_0(thePath):
            # src/a8/PathOps.hx:28
            # src/a8/PathOps.hx:28
            x = a8_PathOps.absPath(thePath)
            paths.append(x)
            # src/a8/PathOps.hx:29
            if python_lib_os_Path.islink(thePath.toString()):
                # src/a8/PathOps.hx:30
                relativeLink = a8_PyOs2.readlink(thePath.toString())
                # src/a8/PathOps.hx:31
                absoluteLink = (relativeLink if (python_lib_os_Path.isabs(relativeLink)) else python_lib_os_Path.join(a8_PathOps.parent(thePath).toString(),relativeLink))
                # src/a8/PathOps.hx:36
                p1 = a8_PathOps.path(absoluteLink)
                # src/a8/PathOps.hx:37
                impl(p1)
        impl = _hx_local_0
        # src/a8/PathOps.hx:40
        impl(p)
        # src/a8/PathOps.hx:41
        return paths

    @staticmethod
    def executablePath():
        # src/a8/PathOps.hx:49
        return a8_PlatformOps.instance.executablePath()

    @staticmethod
    def userHome():
        # src/a8/PathOps.hx:53
        return haxe_io_Path(Sys.environment().h.get("HOME",None))

    @staticmethod
    def absPath(p):
        # src/a8/PathOps.hx:57
        return a8_PlatformOps.instance.absPath(p)

    @staticmethod
    def name(p):
        # src/a8/PathOps.hx:62
        if (p.ext is None):
            return p.file
        else:
            return ((HxOverrides.stringOrNull(p.file) + ".") + HxOverrides.stringOrNull(p.ext))

    @staticmethod
    def programPath():
        # src/a8/PathOps.hx:74
        return haxe_io_Path(Sys.programPath())

    @staticmethod
    def readText(path):
        # src/a8/PathOps.hx:78
        return sys_io_File.getContent(path.toString())

    @staticmethod
    def readLines(path):
        # src/a8/PathOps.hx:82
        _this = a8_PathOps.readText(path)
        return _this.split("\n")

    @staticmethod
    def makeDirectories(path):
        # src/a8/PathOps.hx:86
        sys_FileSystem.createDirectory(path.toString())

    @staticmethod
    def readBytes(path):
        # src/a8/PathOps.hx:90
        return sys_io_File.getBytes(path.toString())

    @staticmethod
    def exists(path):
        # src/a8/PathOps.hx:94
        return sys_FileSystem.exists(path.toString())

    @staticmethod
    def isAbsolute(path):
        # src/a8/PathOps.hx:98
        return haxe_io_Path.isAbsolute(path.toString())

    @staticmethod
    def files(parentDir):
        # src/a8/PathOps.hx:103
        def _hx_local_1():
            # src/a8/PathOps.hx:105
            def _hx_local_0(e):
                # src/a8/PathOps.hx:105
                return a8_PathOps.isFile(e)
            # src/a8/PathOps.hx:103
            return list(filter(_hx_local_0,a8_PathOps.entries(parentDir)))
        return _hx_local_1()

    @staticmethod
    def basename(path):
        # src/a8/PathOps.hx:113
        suffix = ("" if ((path.ext is None)) else ("." + HxOverrides.stringOrNull(path.ext)))
        # src/a8/PathOps.hx:114
        return (HxOverrides.stringOrNull(path.file) + ("null" if suffix is None else suffix))

    @staticmethod
    def moveTo(source,target):
        # src/a8/PathOps.hx:118
        a8_PlatformOps.instance.moveTo(source,target)

    @staticmethod
    def deleteFile(source):
        # src/a8/PathOps.hx:122
        if a8_PathOps.exists(source):
            sys_FileSystem.deleteFile(source.toString())

    @staticmethod
    def entries(parentDir):
        # src/a8/PathOps.hx:128
        sep = ("" if (parentDir.backslash) else "/")
        # src/a8/PathOps.hx:130
        if a8_PathOps.exists(parentDir):
            # src/a8/PathOps.hx:131
            def _hx_local_1():
                # src/a8/PathOps.hx:134
                def _hx_local_0(e):
                    # src/a8/PathOps.hx:134
                    return haxe_io_Path(((HxOverrides.stringOrNull(parentDir.toString()) + ("null" if sep is None else sep)) + ("null" if e is None else e)))
                # src/a8/PathOps.hx:131
                return list(map(_hx_local_0,sys_FileSystem.readDirectory(a8_PathOps.realPathStr(parentDir))))
            return _hx_local_1()
        else:
            return []

    @staticmethod
    def isFile(path):
        # src/a8/PathOps.hx:141
        return a8_PlatformOps.instance.isFile(path)

    @staticmethod
    def isDir(path):
        # src/a8/PathOps.hx:145
        return sys_FileSystem.isDirectory(path.toString())

    @staticmethod
    def realPathStr(path):
        # src/a8/PathOps.hx:149
        return sys_FileSystem.fullPath(path.toString())

    @staticmethod
    def writeBytes(path,_hx_bytes):
        # src/a8/PathOps.hx:153
        sys_io_File.saveBytes(path.toString(),_hx_bytes)

    @staticmethod
    def writeText(path,text):
        # src/a8/PathOps.hx:157
        sys_io_File.saveContent(path.toString(),text)

    @staticmethod
    def parent(path):
        # src/a8/PathOps.hx:161
        _g = path.dir
        # src/a8/PathOps.hx:162
        if (_g is None):
            if a8_PathOps.isAbsolute(path):
                return None
            else:
                return haxe_io_Path(sys_FileSystem.fullPath("."))
        else:
            # src/a8/PathOps.hx:168
            d = _g
            # src/a8/PathOps.hx:169
            return haxe_io_Path(d)

    @staticmethod
    def entry(dir,name):
        # src/a8/PathOps.hx:174
        separator = ("" if (dir.backslash) else "/")
        # src/a8/PathOps.hx:175
        return haxe_io_Path(((HxOverrides.stringOrNull(dir.toString()) + ("null" if separator is None else separator)) + ("null" if name is None else name)))

    @staticmethod
    def outputStream(p):
        # src/a8/PathOps.hx:179
        return a8_StreamOps.fileOutputStream(a8_PathOps.realPathStr(p))

    @staticmethod
    def readProperties(p,failOnNotFound = None):
        # src/a8/PathOps.hx:183
        rf = a8_OptionOps.getOrElse(a8_OptionOps.toOption(failOnNotFound),False)
        # src/a8/PathOps.hx:184
        exists = a8_PathOps.exists(p)
        # src/a8/PathOps.hx:186
        if ((not exists) and (not rf)):
            return haxe_ds_StringMap()
        else:
            # src/a8/PathOps.hx:189
            _g = []
            x = HxOverrides.iterator(a8_PathOps.readLines(p))
            while x.hasNext():
                x1 = x.next()
                # src/a8/PathOps.hx:191
                a = x1.split("=")
                # src/a8/PathOps.hx:189
                x2 = None
                # src/a8/PathOps.hx:193
                if (len(a) == 2):
                    # src/a8/PathOps.hx:194
                    this1 = [(a[0] if 0 < len(a) else None), (a[1] if 1 < len(a) else None)]
                    # src/a8/PathOps.hx:189
                    x2 = [this1]
                else:
                    x2 = []
                # src/a8/PathOps.hx:189
                _g.append(x2)
            _g1 = []
            e = HxOverrides.iterator(_g)
            while e.hasNext():
                e1 = e.next()
                x3 = HxOverrides.iterator(e1)
                while x3.hasNext():
                    x4 = x3.next()
                    _g1.append(x4)
            return a8_HaxeOps2.toMap(_g1)
a8_PathOps._hx_class = a8_PathOps


class a8_AbstractPlatform:
    _hx_class_name = "a8.AbstractPlatform"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_methods = ["isFile", "spawn", "moveTo"]

    def isFile(self,path):
        # src/a8/Platform.hx:42
        e = sys_FileSystem.exists(path.toString())
        # src/a8/Platform.hx:43
        d = sys_FileSystem.isDirectory(path.toString())
        # src/a8/Platform.hx:44
        if e:
            return (not d)
        else:
            return False

    def spawn(self,threadName,fn):
        # src/a8/Platform.hx:48
        raise _HxException(a8_Exception("TODO ??? implement me",None,_hx_AnonObject({'fileName': "src/a8/Platform.hx", 'lineNumber': 48, 'className': "a8.AbstractPlatform", 'methodName': "spawn"})))

    def moveTo(self,source,target):
        # src/a8/Platform.hx:52
        raise _HxException(a8_Exception("TODO ??? implement me",None,_hx_AnonObject({'fileName': "src/a8/Platform.hx", 'lineNumber': 52, 'className': "a8.AbstractPlatform", 'methodName': "moveTo"})))

a8_AbstractPlatform._hx_class = a8_AbstractPlatform


class a8_Platform:
    _hx_class_name = "a8.Platform"
    _hx_is_interface = "True"
    __slots__ = ()
    _hx_methods = ["executablePath", "isFile", "spawn", "moveTo", "absPath"]
a8_Platform._hx_class = a8_Platform


class a8_PythonPlatform(a8_AbstractPlatform):
    _hx_class_name = "a8.PythonPlatform"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_fields = []
    _hx_methods = ["absPath", "executablePath", "isFile", "spawn", "moveTo"]
    _hx_statics = []
    _hx_interfaces = [a8_Platform]
    _hx_super = a8_AbstractPlatform


    def __init__(self):
        pass

    def absPath(self,path):
        # src/a8/Platform.hx:77
        return a8_PathOps.path(python_lib_os_Path.normpath(python_lib_os_Path.abspath(path.toString())))

    def executablePath(self):
        # src/a8/Platform.hx:81
        return haxe_io_Path(python_internal_ArrayImpl._get(python_lib_Sys.argv, 0))

    def isFile(self,path):
        # src/a8/Platform.hx:85
        return python_lib_os_Path.isfile(path.toString())

    def spawn(self,threadName,fn):
        # src/a8/Platform.hx:89
        th = python_lib_threading_Thread(**python__KwArgs_KwArgs_Impl_.fromT(_hx_AnonObject({'target': fn})))
        # src/a8/Platform.hx:90
        th.start()

    def moveTo(self,source,target):
        # src/a8/Platform.hx:94
        a8_PyShutil2.move(source.toString(),target.toString())

a8_PythonPlatform._hx_class = a8_PythonPlatform


class a8_PlatformOps:
    _hx_class_name = "a8.PlatformOps"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["instance"]
a8_PlatformOps._hx_class = a8_PlatformOps


class a8_StreamOps:
    _hx_class_name = "a8.StreamOps"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["asInputStream", "asOutputStream", "fileOutputStream"]

    @staticmethod
    def asInputStream(fileIO):
        # src/a8/StreamOps.hx:12
        return a8_FileIOInputStream(fileIO)

    @staticmethod
    def asOutputStream(io):
        # src/a8/StreamOps.hx:16
        return a8_TextIOBaseOutputStream(io)

    @staticmethod
    def fileOutputStream(filename):
        # src/a8/StreamOps.hx:20
        return a8_StreamOps.asOutputStream(python_lib_Io.open(filename,"wt"))
a8_StreamOps._hx_class = a8_StreamOps


class a8_StreamOps2:
    _hx_class_name = "a8.StreamOps2"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["asOutputStream"]

    @staticmethod
    def asOutputStream(output):
        # src/a8/StreamOps.hx:28
        return a8_OutputOutputStream(output)
a8_StreamOps2._hx_class = a8_StreamOps2


class a8_OutputStream:
    _hx_class_name = "a8.OutputStream"
    _hx_is_interface = "True"
    __slots__ = ()
    _hx_methods = ["write", "flush", "close"]
a8_OutputStream._hx_class = a8_OutputStream


class a8_InputStream:
    _hx_class_name = "a8.InputStream"
    _hx_is_interface = "True"
    __slots__ = ()
    _hx_methods = ["readLine", "close"]
a8_InputStream._hx_class = a8_InputStream


class a8_FileIOInputStream:
    _hx_class_name = "a8.FileIOInputStream"
    _hx_is_interface = "False"
    __slots__ = ("delegate",)
    _hx_fields = ["delegate"]
    _hx_methods = ["readLine", "close"]
    _hx_interfaces = [a8_InputStream]

    def __init__(self,delegate):
        # src/a8/Streams.hx:29
        self.delegate = delegate

    def readLine(self):
        # src/a8/Streams.hx:32
        _hx_bytes = self.delegate.readline()
        # src/a8/Streams.hx:33
        line = _hx_bytes.decode()
        # src/a8/Streams.hx:36
        if line.endswith("\n"):
            return HxString.substr(line,0,(len(line) - 1))
        else:
            return None

    def close(self):
        pass

a8_FileIOInputStream._hx_class = a8_FileIOInputStream


class a8_TextIOBaseOutputStream:
    _hx_class_name = "a8.TextIOBaseOutputStream"
    _hx_is_interface = "False"
    __slots__ = ("delegate",)
    _hx_fields = ["delegate"]
    _hx_methods = ["write", "flush", "close"]
    _hx_interfaces = [a8_OutputStream]

    def __init__(self,delegate):
        # src/a8/Streams.hx:53
        self.delegate = delegate

    def write(self,s):
        # src/a8/Streams.hx:56
        self.delegate.write(s)

    def flush(self):
        # src/a8/Streams.hx:60
        self.delegate.flush()

    def close(self):
        # src/a8/Streams.hx:64
        self.delegate.close()

a8_TextIOBaseOutputStream._hx_class = a8_TextIOBaseOutputStream


class a8_OutputOutputStream:
    _hx_class_name = "a8.OutputOutputStream"
    _hx_is_interface = "False"
    __slots__ = ("delegate",)
    _hx_fields = ["delegate"]
    _hx_methods = ["write", "flush", "close"]
    _hx_interfaces = [a8_OutputStream]

    def __init__(self,delegate):
        # src/a8/Streams.hx:73
        self.delegate = delegate

    def write(self,s):
        # src/a8/Streams.hx:76
        self.delegate.writeString(s)

    def flush(self):
        # src/a8/Streams.hx:80
        self.delegate.flush()

    def close(self):
        # src/a8/Streams.hx:84
        self.delegate.close()

a8_OutputOutputStream._hx_class = a8_OutputOutputStream


class a8_FileIOOutputStream:
    _hx_class_name = "a8.FileIOOutputStream"
    _hx_is_interface = "False"
    __slots__ = ("delegate",)
    _hx_fields = ["delegate"]
    _hx_methods = ["write", "flush", "close"]
    _hx_interfaces = [a8_OutputStream]

    def __init__(self,delegate):
        # src/a8/Streams.hx:92
        self.delegate = delegate

    def write(self,s):
        # src/a8/Streams.hx:95
        self.delegate.write(bytes(s,"utf-8"))

    def flush(self):
        # src/a8/Streams.hx:99
        self.delegate.flush()

    def close(self):
        # src/a8/Streams.hx:103
        self.delegate.close()

a8_FileIOOutputStream._hx_class = a8_FileIOOutputStream


class a8_TeeOutputStream:
    _hx_class_name = "a8.TeeOutputStream"
    _hx_is_interface = "False"
    __slots__ = ("outputs",)
    _hx_fields = ["outputs"]
    _hx_methods = ["write", "flush", "close"]
    _hx_interfaces = [a8_OutputStream]

    def __init__(self,outputs):
        # src/a8/Streams.hx:115
        self.outputs = outputs

    def write(self,s):
        # src/a8/Streams.hx:120
        def _hx_local_0(os):
            # src/a8/Streams.hx:120
            os.write(s)
        # src/a8/Streams.hx:119
        Lambda.iter(self.outputs,_hx_local_0)

    def flush(self):
        # src/a8/Streams.hx:126
        def _hx_local_0(os):
            # src/a8/Streams.hx:126
            os.flush()
        # src/a8/Streams.hx:125
        Lambda.iter(self.outputs,_hx_local_0)

    def close(self):
        # src/a8/Streams.hx:132
        def _hx_local_0(os):
            # src/a8/Streams.hx:132
            os.close()
        # src/a8/Streams.hx:131
        Lambda.iter(self.outputs,_hx_local_0)

a8_TeeOutputStream._hx_class = a8_TeeOutputStream


class a8_Pipe:
    _hx_class_name = "a8.Pipe"
    _hx_is_interface = "False"
    __slots__ = ("input", "output", "firstIO", "byteCount", "replaceOutput")
    _hx_fields = ["input", "output", "firstIO", "byteCount", "replaceOutput"]
    _hx_methods = ["run"]

    def __init__(self,input,output,firstIO):
        # src/a8/Streams.hx:148
        self.replaceOutput = None
        # src/a8/Streams.hx:151
        self.input = input
        # src/a8/Streams.hx:152
        self.output = output
        # src/a8/Streams.hx:153
        self.firstIO = firstIO
        # src/a8/Streams.hx:154
        self.byteCount = 0

    def run(self):
        # src/a8/Streams.hx:160
        _gthis = self
        # src/a8/Streams.hx:162
        def _hx_local_1():
            # src/a8/Streams.hx:163
            first = True
            # src/a8/Streams.hx:164
            cont = True
            # src/a8/Streams.hx:165
            while cont:
                # src/a8/Streams.hx:166
                line = _gthis.input.readLine()
                # src/a8/Streams.hx:167
                if (_gthis.replaceOutput is not None):
                    # src/a8/Streams.hx:168
                    _gthis.output = _gthis.replaceOutput(_gthis.output)
                    # src/a8/Streams.hx:169
                    first = True
                # src/a8/Streams.hx:171
                if (line is None):
                    cont = False
                else:
                    # src/a8/Streams.hx:174
                    if first:
                        # src/a8/Streams.hx:175
                        _gthis.firstIO(_gthis.output)
                        # src/a8/Streams.hx:176
                        first = False
                    # src/a8/Streams.hx:178
                    _gthis.output.write(line)
                    # src/a8/Streams.hx:179
                    _gthis.output.write("\n")
                    # src/a8/Streams.hx:180
                    _gthis.output.flush()
                    # src/a8/Streams.hx:181
                    _gthis.byteCount = (_gthis.byteCount + ((len(line) + 1)))
            # src/a8/Streams.hx:184
            _gthis.output.close()
        impl = _hx_local_1
        # src/a8/Streams.hx:187
        a8_PlatformOps.instance.spawn("pipe",impl)

a8_Pipe._hx_class = a8_Pipe


class a8__Tuple2_Tuple2_Impl_:
    _hx_class_name = "a8._Tuple2.Tuple2_Impl_"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["_new", "_1", "_2", "toString"]

    @staticmethod
    def _new(a,b):
        # src/a8/Tuple2.hx:6
        this1 = [a, b]
        return this1

    @staticmethod
    def _1(this1):
        # src/a8/Tuple2.hx:11
        return (this1[0] if 0 < len(this1) else None)

    @staticmethod
    def _2(this1):
        # src/a8/Tuple2.hx:15
        return (this1[1] if 1 < len(this1) else None)

    @staticmethod
    def toString(this1):
        # src/a8/Tuple2.hx:19
        return haxe_format_JsonPrinter.print(this1,None,None)
a8__Tuple2_Tuple2_Impl_._hx_class = a8__Tuple2_Tuple2_Impl_

class haxe_ds_Option(Enum):
    __slots__ = ()
    _hx_class_name = "haxe.ds.Option"
    _hx_constructs = ["Some", "None"]

    @staticmethod
    def Some(v):
        return haxe_ds_Option("Some", 0, (v,))
haxe_ds_Option._hx_None = haxe_ds_Option("None", 1, ())
haxe_ds_Option._hx_class = haxe_ds_Option


class sys_io_File:
    _hx_class_name = "sys.io.File"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["getContent", "saveContent", "getBytes", "saveBytes"]

    @staticmethod
    def getContent(path):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/sys/io/File.hx:31
        f = python_lib_Builtins.open(path,"r",-1,"utf-8",None,"")
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/sys/io/File.hx:32
        content = f.read(-1)
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/sys/io/File.hx:33
        f.close()
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/sys/io/File.hx:34
        return content

    @staticmethod
    def saveContent(path,content):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/sys/io/File.hx:38
        f = python_lib_Builtins.open(path,"w",-1,"utf-8",None,"")
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/sys/io/File.hx:39
        f.write(content)
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/sys/io/File.hx:40
        f.close()

    @staticmethod
    def getBytes(path):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/sys/io/File.hx:44
        f = python_lib_Builtins.open(path,"rb",-1)
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/sys/io/File.hx:45
        size = f.read(-1)
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/sys/io/File.hx:46
        b = haxe_io_Bytes.ofData(size)
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/sys/io/File.hx:47
        f.close()
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/sys/io/File.hx:48
        return b

    @staticmethod
    def saveBytes(path,_hx_bytes):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/sys/io/File.hx:52
        f = python_lib_Builtins.open(path,"wb",-1)
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/sys/io/File.hx:53
        f.write(_hx_bytes.b)
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/sys/io/File.hx:54
        f.close()
sys_io_File._hx_class = sys_io_File


class haxe_io_Path:
    _hx_class_name = "haxe.io.Path"
    _hx_is_interface = "False"
    __slots__ = ("dir", "file", "ext", "backslash")
    _hx_fields = ["dir", "file", "ext", "backslash"]
    _hx_methods = ["toString"]
    _hx_statics = ["isAbsolute"]

    def __init__(self,path):
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/io/Path.hx:68
        self.backslash = None
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/io/Path.hx:63
        self.ext = None
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/io/Path.hx:53
        self.file = None
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/io/Path.hx:43
        self.dir = None
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/io/Path.hx:77
        path1 = path
        _hx_local_0 = len(path1)
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/io/Path.hx:78
        if (_hx_local_0 == 1):
            if (path1 == "."):
                # /Users/glen/tools-a8/packages/haxe/current/std/haxe/io/Path.hx:79
                self.dir = path
                # /Users/glen/tools-a8/packages/haxe/current/std/haxe/io/Path.hx:80
                self.file = ""
                # /Users/glen/tools-a8/packages/haxe/current/std/haxe/io/Path.hx:81
                return
        elif (_hx_local_0 == 2):
            if (path1 == ".."):
                # /Users/glen/tools-a8/packages/haxe/current/std/haxe/io/Path.hx:79
                self.dir = path
                # /Users/glen/tools-a8/packages/haxe/current/std/haxe/io/Path.hx:80
                self.file = ""
                # /Users/glen/tools-a8/packages/haxe/current/std/haxe/io/Path.hx:81
                return
        else:
            pass
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/io/Path.hx:83
        startIndex = None
        c1 = None
        if (startIndex is None):
            c1 = path.rfind("/", 0, len(path))
        else:
            i = path.rfind("/", 0, (startIndex + 1))
            startLeft = (max(0,((startIndex + 1) - len("/"))) if ((i == -1)) else (i + 1))
            check = path.find("/", startLeft, len(path))
            c1 = (check if (((check > i) and ((check <= startIndex)))) else i)
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/io/Path.hx:84
        startIndex1 = None
        c2 = None
        if (startIndex1 is None):
            c2 = path.rfind("\\", 0, len(path))
        else:
            i1 = path.rfind("\\", 0, (startIndex1 + 1))
            startLeft1 = (max(0,((startIndex1 + 1) - len("\\"))) if ((i1 == -1)) else (i1 + 1))
            check1 = path.find("\\", startLeft1, len(path))
            c2 = (check1 if (((check1 > i1) and ((check1 <= startIndex1)))) else i1)
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/io/Path.hx:85
        if (c1 < c2):
            # /Users/glen/tools-a8/packages/haxe/current/std/haxe/io/Path.hx:86
            self.dir = HxString.substr(path,0,c2)
            # /Users/glen/tools-a8/packages/haxe/current/std/haxe/io/Path.hx:87
            path = HxString.substr(path,(c2 + 1),None)
            # /Users/glen/tools-a8/packages/haxe/current/std/haxe/io/Path.hx:88
            self.backslash = True
        elif (c2 < c1):
            # /Users/glen/tools-a8/packages/haxe/current/std/haxe/io/Path.hx:90
            self.dir = HxString.substr(path,0,c1)
            # /Users/glen/tools-a8/packages/haxe/current/std/haxe/io/Path.hx:91
            path = HxString.substr(path,(c1 + 1),None)
        else:
            self.dir = None
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/io/Path.hx:94
        startIndex2 = None
        cp = None
        if (startIndex2 is None):
            cp = path.rfind(".", 0, len(path))
        else:
            i2 = path.rfind(".", 0, (startIndex2 + 1))
            startLeft2 = (max(0,((startIndex2 + 1) - len("."))) if ((i2 == -1)) else (i2 + 1))
            check2 = path.find(".", startLeft2, len(path))
            cp = (check2 if (((check2 > i2) and ((check2 <= startIndex2)))) else i2)
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/io/Path.hx:95
        if (cp != -1):
            # /Users/glen/tools-a8/packages/haxe/current/std/haxe/io/Path.hx:96
            self.ext = HxString.substr(path,(cp + 1),None)
            # /Users/glen/tools-a8/packages/haxe/current/std/haxe/io/Path.hx:97
            self.file = HxString.substr(path,0,cp)
        else:
            # /Users/glen/tools-a8/packages/haxe/current/std/haxe/io/Path.hx:99
            self.ext = None
            # /Users/glen/tools-a8/packages/haxe/current/std/haxe/io/Path.hx:100
            self.file = path

    def toString(self):
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/io/Path.hx:115
        return ((HxOverrides.stringOrNull((("" if ((self.dir is None)) else (HxOverrides.stringOrNull(self.dir) + HxOverrides.stringOrNull((("\\" if (self.backslash) else "/"))))))) + HxOverrides.stringOrNull(self.file)) + HxOverrides.stringOrNull((("" if ((self.ext is None)) else ("." + HxOverrides.stringOrNull(self.ext))))))

    @staticmethod
    def isAbsolute(path):
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/io/Path.hx:315
        if path.startswith("/"):
            return True
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/io/Path.hx:317
        if ((("" if ((1 >= len(path))) else path[1])) == ":"):
            return True
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/io/Path.hx:319
        if path.startswith("\\\\"):
            return True
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/io/Path.hx:321
        return False

haxe_io_Path._hx_class = haxe_io_Path


class HxString:
    _hx_class_name = "HxString"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["split", "charCodeAt", "charAt", "lastIndexOf", "toUpperCase", "toLowerCase", "indexOf", "toString", "substring", "substr"]

    @staticmethod
    def split(s,d):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/internal/StringImpl.hx:31
        if (d == ""):
            return list(s)
        else:
            return s.split(d)

    @staticmethod
    def charCodeAt(s,index):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/internal/StringImpl.hx:36
        if ((((s is None) or ((len(s) == 0))) or ((index < 0))) or ((index >= len(s)))):
            return None
        else:
            return ord(s[index])

    @staticmethod
    def charAt(s,index):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/internal/StringImpl.hx:41
        if ((index < 0) or ((index >= len(s)))):
            return ""
        else:
            return s[index]

    @staticmethod
    def lastIndexOf(s,_hx_str,startIndex = None):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/internal/StringImpl.hx:46
        if (startIndex is None):
            return s.rfind(_hx_str, 0, len(s))
        else:
            # /Users/glen/tools-a8/packages/haxe/current/std/python/internal/StringImpl.hx:49
            i = s.rfind(_hx_str, 0, (startIndex + 1))
            # /Users/glen/tools-a8/packages/haxe/current/std/python/internal/StringImpl.hx:50
            startLeft = (max(0,((startIndex + 1) - len(_hx_str))) if ((i == -1)) else (i + 1))
            # /Users/glen/tools-a8/packages/haxe/current/std/python/internal/StringImpl.hx:51
            check = s.find(_hx_str, startLeft, len(s))
            # /Users/glen/tools-a8/packages/haxe/current/std/python/internal/StringImpl.hx:52
            if ((check > i) and ((check <= startIndex))):
                return check
            else:
                return i

    @staticmethod
    def toUpperCase(s):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/internal/StringImpl.hx:62
        return s.upper()

    @staticmethod
    def toLowerCase(s):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/internal/StringImpl.hx:67
        return s.lower()

    @staticmethod
    def indexOf(s,_hx_str,startIndex = None):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/internal/StringImpl.hx:72
        if (startIndex is None):
            return s.find(_hx_str)
        else:
            return s.find(_hx_str, startIndex)

    @staticmethod
    def toString(s):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/internal/StringImpl.hx:80
        return s

    @staticmethod
    def substring(s,startIndex,endIndex = None):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/internal/StringImpl.hx:99
        if (startIndex < 0):
            startIndex = 0
        # /Users/glen/tools-a8/packages/haxe/current/std/python/internal/StringImpl.hx:101
        if (endIndex is None):
            return s[startIndex:]
        else:
            # /Users/glen/tools-a8/packages/haxe/current/std/python/internal/StringImpl.hx:104
            if (endIndex < 0):
                endIndex = 0
            # /Users/glen/tools-a8/packages/haxe/current/std/python/internal/StringImpl.hx:106
            if (endIndex < startIndex):
                return s[endIndex:startIndex]
            else:
                return s[startIndex:endIndex]

    @staticmethod
    def substr(s,startIndex,_hx_len = None):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/internal/StringImpl.hx:116
        if (_hx_len is None):
            return s[startIndex:]
        else:
            # /Users/glen/tools-a8/packages/haxe/current/std/python/internal/StringImpl.hx:119
            if (_hx_len == 0):
                return ""
            # /Users/glen/tools-a8/packages/haxe/current/std/python/internal/StringImpl.hx:121
            if (startIndex < 0):
                # /Users/glen/tools-a8/packages/haxe/current/std/python/internal/StringImpl.hx:122
                startIndex = (len(s) + startIndex)
                # /Users/glen/tools-a8/packages/haxe/current/std/python/internal/StringImpl.hx:123
                if (startIndex < 0):
                    startIndex = 0
            # /Users/glen/tools-a8/packages/haxe/current/std/python/internal/StringImpl.hx:126
            return s[startIndex:(startIndex + _hx_len)]
HxString._hx_class = HxString


class a8_UserConfig:
    _hx_class_name = "a8.UserConfig"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["repoConfig", "getRepoProp", "repo_url", "versionsVersion", "versionsVersionFromRepo"]

    @staticmethod
    def getRepoProp(name):
        # src/a8/UserConfig.hx:26
        v = a8_UserConfig.repoConfig.h.get(name,None)
        # src/a8/UserConfig.hx:27
        if (v is None):
            raise _HxException((("no " + ("null" if name is None else name)) + " defined in ~/.a8/repo.properties"))
        # src/a8/UserConfig.hx:30
        return v

    @staticmethod
    def versionsVersion():
        # src/a8/UserConfig.hx:47
        version = a8_UserConfig.repoConfig.h.get("versions_version",None)
        # src/a8/UserConfig.hx:48
        if (version is None):
            version = a8_UserConfig.versionsVersionFromRepo()
        # src/a8/UserConfig.hx:51
        return version

    @staticmethod
    def versionsVersionFromRepo():
        # src/a8/UserConfig.hx:55
        v = a8_UserConfig.getRepoProp("repo_url")
        # src/a8/UserConfig.hx:56
        startIndex = None
        startIndex1 = (((v.find("://") if ((startIndex is None)) else v.find("://", startIndex))) + 1)
        url = (HxOverrides.stringOrNull(HxString.substring(v,0,(v.find("/") if ((startIndex1 is None)) else v.find("/", startIndex1)))) + "/versionsVersion")
        # src/a8/UserConfig.hx:57
        return sys_Http.requestUrl(url)
a8_UserConfig._hx_class = a8_UserConfig


class a8_launcher_CommandLineProcessor:
    _hx_class_name = "a8.launcher.CommandLineProcessor"
    _hx_is_interface = "False"
    __slots__ = ("lazy_argDefs",)
    _hx_fields = ["lazy_argDefs"]
    _hx_methods = ["apply", "get_argDefs"]

    def __init__(self):
        # src/a8/launcher/CommandLineProcessor.hx:9
        self.lazy_argDefs = None
        def _hx_local_5():
            def _hx_local_4():
                # src/a8/launcher/CommandLineProcessor.hx:14
                def _hx_local_0(config,args):
                    # src/a8/launcher/CommandLineProcessor.hx:14
                    Reflect.setField(config,"explicitVersion",args)
                # src/a8/launcher/CommandLineProcessor.hx:21
                def _hx_local_1(config1,args1):
                    # src/a8/launcher/CommandLineProcessor.hx:21
                    Reflect.setField(config1,"quiet",a8_OptionOps.isEmpty(args1))
                # src/a8/launcher/CommandLineProcessor.hx:28
                def _hx_local_2(config2,args2):
                    # src/a8/launcher/CommandLineProcessor.hx:28
                    Reflect.setField(config2,"resolveOnly",a8_OptionOps.nonEmpty(args2))
                # src/a8/launcher/CommandLineProcessor.hx:35
                def _hx_local_3(config3,args3):
                    # src/a8/launcher/CommandLineProcessor.hx:35
                    Reflect.setField(config3,"showHelp",a8_OptionOps.nonEmpty(args3))
                # src/a8/launcher/CommandLineProcessor.hx:9
                return [_hx_AnonObject({'name': "--l-version", 'parmCount': 1, 'apply': _hx_local_0, 'processed': False}), _hx_AnonObject({'name': "--l-verbose", 'parmCount': 0, 'apply': _hx_local_1, 'processed': False}), _hx_AnonObject({'name': "--l-resolveOnly", 'parmCount': 0, 'apply': _hx_local_2, 'processed': False}), _hx_AnonObject({'name': "--l-help", 'parmCount': 0, 'apply': _hx_local_3, 'processed': False})]
            return _hx_local_4()
        self.lazy_argDefs = tink_core__Lazy_LazyFunc(_hx_local_5)

    def apply(self,initialConfig):
        # src/a8/launcher/CommandLineProcessor.hx:44
        config = Reflect.copy(initialConfig)
        # src/a8/launcher/CommandLineProcessor.hx:46
        newArgs = []
        # src/a8/launcher/CommandLineProcessor.hx:47
        Reflect.setField(config,"resolvedCommandLineArgs",newArgs)
        # src/a8/launcher/CommandLineProcessor.hx:48
        temp = list(Reflect.field(initialConfig,"rawCommandLineArgs"))
        # src/a8/launcher/CommandLineProcessor.hx:51
        temp.reverse()
        # src/a8/launcher/CommandLineProcessor.hx:52
        if (len(temp) != 0):
            temp.pop()
        # src/a8/launcher/CommandLineProcessor.hx:54
        while (len(temp) > 0):
            # src/a8/launcher/CommandLineProcessor.hx:55
            a = [(None if ((len(temp) == 0)) else temp.pop())]
            # src/a8/launcher/CommandLineProcessor.hx:56
            def _hx_local_1(a1):
                # src/a8/launcher/CommandLineProcessor.hx:56
                def _hx_local_0(ad):
                    # src/a8/launcher/CommandLineProcessor.hx:56
                    return (ad.name == (a1[0] if 0 < len(a1) else None))
                return _hx_local_0
            argDef = Lambda.find(self.get_argDefs(),_hx_local_1(a))
            # src/a8/launcher/CommandLineProcessor.hx:57
            if (argDef is None):
                # src/a8/launcher/CommandLineProcessor.hx:58
                if (a[0] if 0 < len(a) else None).startswith("--l-"):
                    raise _HxException(a8_Exception(("don't know how to handle arg -- " + HxOverrides.stringOrNull((a[0] if 0 < len(a) else None))),None,_hx_AnonObject({'fileName': "src/a8/launcher/CommandLineProcessor.hx", 'lineNumber': 59, 'className': "a8.launcher.CommandLineProcessor", 'methodName': "apply"})))
                # src/a8/launcher/CommandLineProcessor.hx:61
                newArgs.append((a[0] if 0 < len(a) else None))
            else:
                # src/a8/launcher/CommandLineProcessor.hx:63
                parms = None
                # src/a8/launcher/CommandLineProcessor.hx:64
                if (argDef.parmCount == 0):
                    parms = haxe_ds_Option.Some(argDef.name)
                elif (argDef.parmCount == 1):
                    parms = haxe_ds_Option.Some((None if ((len(temp) == 0)) else temp.pop()))
                else:
                    raise _HxException(a8_Exception("can only handle parmCount of 0 or 1",None,_hx_AnonObject({'fileName': "src/a8/launcher/CommandLineProcessor.hx", 'lineNumber': 66, 'className': "a8.launcher.CommandLineProcessor", 'methodName': "apply"})))
                # src/a8/launcher/CommandLineProcessor.hx:67
                argDef.apply(config,parms)
                # src/a8/launcher/CommandLineProcessor.hx:68
                Reflect.setField(argDef,"processed",True)
        # src/a8/launcher/CommandLineProcessor.hx:74
        def _hx_local_2(ad1):
            # src/a8/launcher/CommandLineProcessor.hx:74
            if (not Reflect.field(ad1,"processed")):
                ad1.apply(config,haxe_ds_Option._hx_None)
        # src/a8/launcher/CommandLineProcessor.hx:73
        Lambda.iter(self.get_argDefs(),_hx_local_2)
        # src/a8/launcher/CommandLineProcessor.hx:81
        return config

    def get_argDefs(self):
        # src/a8/launcher/CommandLineProcessor.hx:9
        return self.lazy_argDefs.get()

a8_launcher_CommandLineProcessor._hx_class = a8_launcher_CommandLineProcessor


class a8_launcher_Launcher:
    _hx_class_name = "a8.launcher.Launcher"
    _hx_is_interface = "False"
    __slots__ = ("lazy_logArchivesDir", "lazy_logsDir", "lazy_installDir", "lazy_a8VersionsCache", "config", "appName", "initialArgs", "pipedStdout", "pipedStderr", "logRollers")
    _hx_fields = ["lazy_logArchivesDir", "lazy_logsDir", "lazy_installDir", "lazy_a8VersionsCache", "config", "appName", "initialArgs", "pipedStdout", "pipedStderr", "logRollers"]
    _hx_methods = ["logTrace", "logWarn", "_log", "archiveOldLogs", "archiveLogFiles", "resolveStandardArgs", "resolveJvmCliLaunchArgs", "resolveJvmLaunchArgs", "runAndWait", "initializeLogRollers", "get_a8VersionsCache", "get_installDir", "get_logsDir", "get_logArchivesDir"]
    _hx_statics = ["initDirectory"]

    def __init__(self,config,appName,initialArgs):
        # src/a8/launcher/Launcher.hx:34
        self.logRollers = None
        # src/a8/launcher/Launcher.hx:33
        self.pipedStderr = None
        # src/a8/launcher/Launcher.hx:32
        self.pipedStdout = None
        # src/a8/launcher/Launcher.hx:22
        self.initialArgs = None
        # src/a8/launcher/Launcher.hx:20
        self.appName = None
        # src/a8/launcher/Launcher.hx:19
        self.config = None
        # src/a8/launcher/Launcher.hx:25
        self.lazy_a8VersionsCache = None
        # src/a8/launcher/Launcher.hx:28
        self.lazy_installDir = None
        # src/a8/launcher/Launcher.hx:29
        self.lazy_logsDir = None
        # src/a8/launcher/Launcher.hx:30
        self.lazy_logArchivesDir = None
        # /usr/local/lib/haxe/lib/tink_syntaxhub/0,4,3/src/tink/SyntaxHub.hx:30
        _gthis = self
        # src/a8/launcher/Launcher.hx:30
        def _hx_local_0():
            # src/a8/launcher/Launcher.hx:30
            return a8_launcher_Launcher.initDirectory("archives",None,_gthis.get_logsDir(),Reflect.field(_gthis.config,"logFiles"))
        self.lazy_logArchivesDir = tink_core__Lazy_LazyFunc(_hx_local_0)
        # src/a8/launcher/Launcher.hx:29
        def _hx_local_1():
            # src/a8/launcher/Launcher.hx:29
            return a8_launcher_Launcher.initDirectory(Reflect.field(config,"logsDir"),"logs",_gthis.get_installDir())
        self.lazy_logsDir = tink_core__Lazy_LazyFunc(_hx_local_1)
        # src/a8/launcher/Launcher.hx:28
        def _hx_local_2():
            # src/a8/launcher/Launcher.hx:28
            return a8_launcher_Launcher.initDirectory(Reflect.field(config,"installDir"),None,a8_PathOps.path(python_lib_Os.getcwd()))
        self.lazy_installDir = tink_core__Lazy_LazyFunc(_hx_local_2)
        # src/a8/launcher/Launcher.hx:25
        def _hx_local_3():
            # src/a8/launcher/Launcher.hx:25
            return a8_launcher_Launcher.initDirectory(".a8/versions/cache",None,a8_PathOps.userHome())
        self.lazy_a8VersionsCache = tink_core__Lazy_LazyFunc(_hx_local_3)
        # src/a8/launcher/Launcher.hx:19
        self.config = config
        # src/a8/launcher/Launcher.hx:20
        self.appName = appName
        # src/a8/launcher/Launcher.hx:22
        self.initialArgs = initialArgs

    def logTrace(self,msg,posInfo = None):
        # src/a8/launcher/Launcher.hx:58
        if (not Reflect.field(self.config,"quiet")):
            if (self.pipedStdout is not None):
                self.pipedStdout.log(("TRACE - " + ("null" if msg is None else msg)))
            else:
                a8_Logger.trace(msg,posInfo)

    def logWarn(self,msg,posInfo = None):
        # src/a8/launcher/Launcher.hx:68
        if (self.pipedStderr is not None):
            self.pipedStderr.log(("WARN - " + ("null" if msg is None else msg)))
        else:
            a8_Logger.warn(msg,posInfo)

    def _log(self,msg,pipe):
        pass

    def archiveOldLogs(self):
        # src/a8/launcher/Launcher.hx:80
        prefix = (HxOverrides.stringOrNull(self.appName) + ".")
        # src/a8/launcher/Launcher.hx:81
        suffix1 = ".details"
        # src/a8/launcher/Launcher.hx:82
        suffix2 = ".errors"
        # src/a8/launcher/Launcher.hx:87
        def _hx_local_0(f):
            # src/a8/launcher/Launcher.hx:88
            filename = a8_PathOps.basename(f)
            # src/a8/launcher/Launcher.hx:89
            if filename.startswith(prefix):
                if (not filename.endswith(suffix1)):
                    return filename.endswith(suffix2)
                else:
                    return True
            else:
                return False
        # src/a8/launcher/Launcher.hx:84
        filesToArchive = list(filter(_hx_local_0,a8_PathOps.files(self.get_logsDir())))
        # src/a8/launcher/Launcher.hx:94
        self.archiveLogFiles(filesToArchive)

    def archiveLogFiles(self,files):
        # src/a8/launcher/Launcher.hx:98
        _gthis = self
        # src/a8/launcher/Launcher.hx:102
        def _hx_local_0(f):
            # src/a8/launcher/Launcher.hx:103
            target = a8_PathOps.entry(_gthis.get_logArchivesDir(),a8_PathOps.basename(f))
            # src/a8/launcher/Launcher.hx:104
            a8_PathOps.deleteFile(target)
            # src/a8/launcher/Launcher.hx:105
            a8_PathOps.moveTo(f,target)
            # src/a8/launcher/Launcher.hx:106
            return target
        # src/a8/launcher/Launcher.hx:100
        archivedFiles = list(map(_hx_local_0,files))
        # src/a8/launcher/Launcher.hx:109
        self.logTrace(("archiving log files -- " + Std.string(archivedFiles)),_hx_AnonObject({'fileName': "src/a8/launcher/Launcher.hx", 'lineNumber': 109, 'className': "a8.launcher.Launcher", 'methodName': "archiveLogFiles"}))
        # src/a8/launcher/Launcher.hx:112
        def _hx_local_2():
            # src/a8/launcher/Launcher.hx:113
            def _hx_local_1(f1):
                # src/a8/launcher/Launcher.hx:113
                python_lib_Subprocess.call(["gzip", "-f", a8_PathOps.realPathStr(f1)])
            # src/a8/launcher/Launcher.hx:112
            Lambda.iter(archivedFiles,_hx_local_1)
        # src/a8/launcher/Launcher.hx:111
        gzipFiles = _hx_local_2
        # src/a8/launcher/Launcher.hx:117
        a8_PyOps.spawn(gzipFiles)

    def resolveStandardArgs(self,stdlauncher):
        # src/a8/launcher/Launcher.hx:122
        launchConfig = stdlauncher
        # src/a8/launcher/Launcher.hx:123
        return _hx_AnonObject({'kind': "popen", 'args': stdlauncher.args, 'env': None, 'cwd': None, 'executable': None})

    def resolveJvmCliLaunchArgs(self,jvmlauncher):
        # src/a8/launcher/Launcher.hx:133
        versionFile = None
        # src/a8/launcher/Launcher.hx:134
        if a8_OptionOps.nonEmpty(Reflect.field(self.config,"explicitVersion")):
            versionFile = (HxOverrides.stringOrNull(a8_OptionOps.getOrError(Reflect.field(self.config,"explicitVersion"),"")) + ".json")
        elif (Reflect.field(jvmlauncher,"branch") is not None):
            versionFile = (("latest_" + HxOverrides.stringOrNull(Reflect.field(jvmlauncher,"branch"))) + ".json")
        elif (Reflect.field(jvmlauncher,"version") is not None):
            versionFile = (HxOverrides.stringOrNull(Reflect.field(jvmlauncher,"version")) + ".json")
        else:
            raise _HxException(a8_Exception("must provide a config with branch or version",None,_hx_AnonObject({'fileName': "src/a8/launcher/Launcher.hx", 'lineNumber': 141, 'className': "a8.launcher.Launcher", 'methodName': "resolveJvmCliLaunchArgs"})))
        # src/a8/launcher/Launcher.hx:143
        inventoryFile = a8_PathOps.entry(self.get_a8VersionsCache(),((((HxOverrides.stringOrNull(jvmlauncher.organization) + "/") + HxOverrides.stringOrNull(jvmlauncher.artifact)) + "/") + ("null" if versionFile is None else versionFile)))
        # src/a8/launcher/Launcher.hx:144
        a8_Logger.trace(("using inventory file - " + HxOverrides.stringOrNull(inventoryFile.toString())),_hx_AnonObject({'fileName': "src/a8/launcher/Launcher.hx", 'lineNumber': 144, 'className': "a8.launcher.Launcher", 'methodName': "resolveJvmCliLaunchArgs"}))
        # src/a8/launcher/Launcher.hx:145
        if ((not a8_PathOps.exists(inventoryFile)) or Reflect.field(self.config,"resolveOnly")):
            # src/a8/launcher/Launcher.hx:146
            _hx_exec = a8_Exec()
            # src/a8/launcher/Launcher.hx:152
            version = a8_OptionOps.getOrElse(a8_OptionOps.toOption(a8_UserConfig.repoConfig.h.get("versions_version",None)),"1.0.0-20200616_1516_master")
            # src/a8/launcher/Launcher.hx:154
            repoUrl = a8_UserConfig.repo_url
            # src/a8/launcher/Launcher.hx:156
            def _hx_local_0():
                # src/a8/launcher/Launcher.hx:156
                _hx_exec.args = [(Std.string(a8_PathOps.parent(a8_PathOps.programPath())) + "/coursier"), "launch", "--repository", repoUrl, ("a8:a8-versions_2.12:" + ("null" if version is None else version)), "-M", "a8.versions.apps.Main", "--", "resolve", "--organization", jvmlauncher.organization, "--artifact", jvmlauncher.artifact]
                return _hx_exec.args
            args = _hx_local_0()
            # src/a8/launcher/Launcher.hx:157
            if a8_OptionOps.nonEmpty(Reflect.field(self.config,"explicitVersion")):
                # src/a8/launcher/Launcher.hx:158
                args.append("--version")
                # src/a8/launcher/Launcher.hx:159
                # src/a8/launcher/Launcher.hx:159
                x = a8_OptionOps.get(Reflect.field(self.config,"explicitVersion"))
                args.append(x)
            elif (Reflect.field(jvmlauncher,"branch") is not None):
                # src/a8/launcher/Launcher.hx:161
                args.append("--branch")
                # src/a8/launcher/Launcher.hx:162
                # src/a8/launcher/Launcher.hx:162
                x1 = Reflect.field(jvmlauncher,"branch")
                args.append(x1)
            elif (Reflect.field(jvmlauncher,"version") is not None):
                # src/a8/launcher/Launcher.hx:164
                args.append("--version")
                # src/a8/launcher/Launcher.hx:165
                # src/a8/launcher/Launcher.hx:165
                x2 = Reflect.field(jvmlauncher,"version")
                args.append(x2)
            # src/a8/launcher/Launcher.hx:167
            _hx_exec.execInline()
        # src/a8/launcher/Launcher.hx:169
        la = self.resolveJvmLaunchArgs(jvmlauncher,inventoryFile,False)
        # src/a8/launcher/Launcher.hx:171
        la.kind = "exec"
        # src/a8/launcher/Launcher.hx:172
        la.cwd = None
        # src/a8/launcher/Launcher.hx:174
        return la

    def resolveJvmLaunchArgs(self,jvmlauncher,installInventoryFile,createAppNameSymlink):
        # src/a8/launcher/Launcher.hx:180
        if (not a8_PathOps.exists(installInventoryFile)):
            raise _HxException(a8_Exception(("inventory file does not exist " + HxOverrides.stringOrNull(installInventoryFile.toString())),None,_hx_AnonObject({'fileName': "src/a8/launcher/Launcher.hx", 'lineNumber': 181, 'className': "a8.launcher.Launcher", 'methodName': "resolveJvmLaunchArgs"})))
        # src/a8/launcher/Launcher.hx:184
        launchConfig = jvmlauncher
        # src/a8/launcher/Launcher.hx:186
        config = python_lib_Json.loads(a8_PathOps.readText(installInventoryFile),**python__KwArgs_KwArgs_Impl_.fromT(_hx_AnonObject({'object_hook': python_Lib.dictToAnon})))
        # src/a8/launcher/Launcher.hx:188
        launcherD = jvmlauncher
        # src/a8/launcher/Launcher.hx:190
        def _hx_local_0(e):
            # src/a8/launcher/Launcher.hx:191
            p = a8_PathOps.realPathStr(e)
            # src/a8/launcher/Launcher.hx:192
            if (p.endswith(".jar") or a8_PathOps.isDir(e)):
                # src/a8/launcher/Launcher.hx:193
                _this = config.classpath
                _this.append(p)
        Lambda.iter(a8_PathOps.entries(a8_PathOps.entry(self.get_installDir(),"lib")),_hx_local_0)
        # src/a8/launcher/Launcher.hx:196
        _this1 = config.classpath
        classpath = ":".join([python_Boot.toString1(x1,'') for x1 in _this1])
        # src/a8/launcher/Launcher.hx:198
        args = list()
        # src/a8/launcher/Launcher.hx:200
        if createAppNameSymlink:
            # src/a8/launcher/Launcher.hx:201
            symlinkName = ("j_" + HxOverrides.stringOrNull(self.appName))
            # src/a8/launcher/Launcher.hx:202
            symlinkParent = self.get_installDir()
            # src/a8/launcher/Launcher.hx:203
            javaAppNameSymLink = ((HxOverrides.stringOrNull(a8_PathOps.realPathStr(symlinkParent)) + "/") + ("null" if symlinkName is None else symlinkName))
            # src/a8/launcher/Launcher.hx:204
            javaAppNameSymLinkPath = a8_PathOps.path(javaAppNameSymLink)
            # src/a8/launcher/Launcher.hx:205
            cmd = None
            # src/a8/launcher/Launcher.hx:206
            if (not a8_PathOps.isFile(javaAppNameSymLinkPath)):
                # src/a8/launcher/Launcher.hx:207
                javaExec = a8_PyShutil2.which("java")
                # src/a8/launcher/Launcher.hx:208
                a8_Logger.trace(((("creating symlink " + ("null" if javaExec is None else javaExec)) + " --> ") + ("null" if javaAppNameSymLink is None else javaAppNameSymLink)),_hx_AnonObject({'fileName': "src/a8/launcher/Launcher.hx", 'lineNumber': 208, 'className': "a8.launcher.Launcher", 'methodName': "resolveJvmLaunchArgs"}))
                # src/a8/launcher/Launcher.hx:209
                a8_PyOs2.symlink(javaExec,javaAppNameSymLink)
                # src/a8/launcher/Launcher.hx:205
                cmd = (("./" + ("null" if symlinkName is None else symlinkName)) if (a8_PathOps.isFile(javaAppNameSymLinkPath)) else "java")
            else:
                cmd = ("./" + ("null" if symlinkName is None else symlinkName))
            # src/a8/launcher/Launcher.hx:218
            args.append(cmd)
        else:
            args.append("java")
        # src/a8/launcher/Launcher.hx:223
        # src/a8/launcher/Launcher.hx:223
        x = ("-DappName=" + HxOverrides.stringOrNull(self.appName))
        args.append(x)
        # src/a8/launcher/Launcher.hx:225
        if (Reflect.field(launcherD,"jvmArgs") is not None):
            # src/a8/launcher/Launcher.hx:227
            def _hx_local_1(jvmArg):
                # src/a8/launcher/Launcher.hx:227
                args.append(jvmArg)
            # src/a8/launcher/Launcher.hx:226
            Lambda.iter(Reflect.field(jvmlauncher,"jvmArgs"),_hx_local_1)
        # src/a8/launcher/Launcher.hx:232
        # src/a8/launcher/Launcher.hx:232
        x1 = jvmlauncher.mainClass
        args.append(x1)
        # src/a8/launcher/Launcher.hx:234
        if (Reflect.field(launcherD,"args") is not None):
            # src/a8/launcher/Launcher.hx:236
            def _hx_local_2(arg):
                # src/a8/launcher/Launcher.hx:236
                args.append(arg)
            # src/a8/launcher/Launcher.hx:235
            Lambda.iter(Reflect.field(jvmlauncher,"args"),_hx_local_2)
        # src/a8/launcher/Launcher.hx:240
        def _hx_local_3(arg1):
            # src/a8/launcher/Launcher.hx:240
            args.append(arg1)
        # src/a8/launcher/Launcher.hx:239
        Lambda.iter(Reflect.field(self.config,"resolvedCommandLineArgs"),_hx_local_3)
        # src/a8/launcher/Launcher.hx:243
        env = python_lib_Os.environ
        # src/a8/launcher/Launcher.hx:245
        newEnv = env.copy()
        # src/a8/launcher/Launcher.hx:249
        newEnv["CLASSPATH"] = classpath
        # src/a8/launcher/Launcher.hx:250
        newEnv["LAUNCHER_INSTALL_DIR"] = a8_PathOps.realPathStr(self.get_installDir())
        # src/a8/launcher/Launcher.hx:251
        newEnv["LAUNCHER_WORKING_DIR"] = python_lib_Os.getcwd()
        # src/a8/launcher/Launcher.hx:252
        newEnv["LAUNCHER_EXEC_PATH"] = a8_PathOps.realPathStr(a8_PathOps.executablePath())
        # src/a8/launcher/Launcher.hx:258
        tmp = a8_PathOps.realPathStr(self.get_installDir())
        # src/a8/launcher/Launcher.hx:254
        return _hx_AnonObject({'kind': "popen", 'args': args, 'env': newEnv, 'cwd': tmp, 'executable': (args[0] if 0 < len(args) else None)})

    def runAndWait(self):
        # src/a8/launcher/Launcher.hx:267
        self.logTrace(("installDir = " + Std.string(self.get_installDir())),_hx_AnonObject({'fileName': "src/a8/launcher/Launcher.hx", 'lineNumber': 267, 'className': "a8.launcher.Launcher", 'methodName': "runAndWait"}))
        # src/a8/launcher/Launcher.hx:268
        self.logTrace(("logsDir = " + Std.string(self.get_logsDir())),_hx_AnonObject({'fileName': "src/a8/launcher/Launcher.hx", 'lineNumber': 268, 'className': "a8.launcher.Launcher", 'methodName': "runAndWait"}))
        # src/a8/launcher/Launcher.hx:269
        self.logTrace(("logArchivesDir = " + Std.string(self.get_logArchivesDir())),_hx_AnonObject({'fileName': "src/a8/launcher/Launcher.hx", 'lineNumber': 269, 'className': "a8.launcher.Launcher", 'methodName': "runAndWait"}))
        # src/a8/launcher/Launcher.hx:271
        resolvedLaunch = None
        # src/a8/launcher/Launcher.hx:272
        if (self.config.kind == "jvm"):
            # src/a8/launcher/Launcher.hx:273
            installInventoryFile = a8_PathOps.entry(self.get_installDir(),"install-inventory.json")
            # src/a8/launcher/Launcher.hx:271
            resolvedLaunch = self.resolveJvmLaunchArgs(self.config,installInventoryFile,True)
        elif (self.config.kind == "jvm_cli"):
            resolvedLaunch = self.resolveJvmCliLaunchArgs(self.config)
        elif (self.config.kind == "args"):
            resolvedLaunch = self.resolveStandardArgs(self.config)
        else:
            raise _HxException(a8_Exception(("unable to resolve config kind " + HxOverrides.stringOrNull(self.config.kind)),None,_hx_AnonObject({'fileName': "src/a8/launcher/Launcher.hx", 'lineNumber': 280, 'className': "a8.launcher.Launcher", 'methodName': "runAndWait"})))
        # src/a8/launcher/Launcher.hx:282
        if Reflect.field(self.config,"resolveOnly"):
            return 0
        else:
            # src/a8/launcher/Launcher.hx:286
            if Reflect.field(self.config,"logFiles"):
                self.archiveOldLogs()
            # src/a8/launcher/Launcher.hx:290
            _g = resolvedLaunch.kind
            _hx_local_0 = len(_g)
            # src/a8/launcher/Launcher.hx:291
            if (_hx_local_0 == 4):
                if (_g == "exec"):
                    # src/a8/launcher/Launcher.hx:294
                    if (resolvedLaunch.cwd is not None):
                        python_lib_Os.chdir(resolvedLaunch.cwd)
                    # src/a8/launcher/Launcher.hx:296
                    a8_PyOs2.execvpe(resolvedLaunch.executable,resolvedLaunch.args,resolvedLaunch.env)
                    # src/a8/launcher/Launcher.hx:298
                    raise _HxException(a8_Exception("this never happens",None,_hx_AnonObject({'fileName': "src/a8/launcher/Launcher.hx", 'lineNumber': 298, 'className': "a8.launcher.Launcher", 'methodName': "runAndWait"})))
                else:
                    raise _HxException(a8_Exception("don't know how to handle ResolvedLaunch.kind = ${resolvedLaunch.kind}",None,_hx_AnonObject({'fileName': "src/a8/launcher/Launcher.hx", 'lineNumber': 334, 'className': "a8.launcher.Launcher", 'methodName': "runAndWait"})))
            elif (_hx_local_0 == 5):
                if (_g == "popen"):
                    # src/a8/launcher/Launcher.hx:301
                    self.logTrace(("running -- " + Std.string(resolvedLaunch.args)),_hx_AnonObject({'fileName': "src/a8/launcher/Launcher.hx", 'lineNumber': 301, 'className': "a8.launcher.Launcher", 'methodName': "runAndWait"}))
                    # src/a8/launcher/Launcher.hx:303
                    popen = python_lib_subprocess_Popen(resolvedLaunch.args,None,resolvedLaunch.executable,None,python_lib_Subprocess.PIPE,python_lib_Subprocess.PIPE,None,False,False,resolvedLaunch.cwd,resolvedLaunch.env)
                    # src/a8/launcher/Launcher.hx:306
                    def _hx_local_1(out):
                        # src/a8/launcher/Launcher.hx:306
                        out.write((("first output at " + HxOverrides.stringOrNull(a8_PathOps.timestampStr())) + "\n"))
                    # src/a8/launcher/Launcher.hx:305
                    firstIO = _hx_local_1
                    # src/a8/launcher/Launcher.hx:309
                    timestampStr = a8_PathOps.timestampStr()
                    # src/a8/launcher/Launcher.hx:311
                    self.logTrace("setting up pipes",_hx_AnonObject({'fileName': "src/a8/launcher/Launcher.hx", 'lineNumber': 311, 'className': "a8.launcher.Launcher", 'methodName': "runAndWait"}))
                    # src/a8/launcher/Launcher.hx:312
                    self.pipedStdout = a8_launcher_PipedStream(self,a8_StreamOps.asInputStream(popen.stdout),python_lib_Sys.stdout,"details",firstIO,Reflect.field(self.config,"logFiles"),timestampStr)
                    # src/a8/launcher/Launcher.hx:313
                    self.pipedStderr = a8_launcher_PipedStream(self,a8_StreamOps.asInputStream(popen.stderr),python_lib_Sys.stderr,"errors",firstIO,Reflect.field(self.config,"logFiles"),timestampStr)
                    # src/a8/launcher/Launcher.hx:315
                    self.pipedStdout.start()
                    # src/a8/launcher/Launcher.hx:316
                    self.pipedStderr.start()
                    # src/a8/launcher/Launcher.hx:320
                    self.logTrace("initializeLogRollers",_hx_AnonObject({'fileName': "src/a8/launcher/Launcher.hx", 'lineNumber': 320, 'className': "a8.launcher.Launcher", 'methodName': "runAndWait"}))
                    # src/a8/launcher/Launcher.hx:321
                    self.initializeLogRollers()
                    # src/a8/launcher/Launcher.hx:322
                    self.logTrace("initializeLogRollers complete",_hx_AnonObject({'fileName': "src/a8/launcher/Launcher.hx", 'lineNumber': 322, 'className': "a8.launcher.Launcher", 'methodName': "runAndWait"}))
                    # src/a8/launcher/Launcher.hx:325
                    popen.wait()
                    # src/a8/launcher/Launcher.hx:328
                    self.pipedStdout.close()
                    # src/a8/launcher/Launcher.hx:329
                    self.pipedStdout.close()
                    # src/a8/launcher/Launcher.hx:331
                    return popen.returncode
                else:
                    raise _HxException(a8_Exception("don't know how to handle ResolvedLaunch.kind = ${resolvedLaunch.kind}",None,_hx_AnonObject({'fileName': "src/a8/launcher/Launcher.hx", 'lineNumber': 334, 'className': "a8.launcher.Launcher", 'methodName': "runAndWait"})))
            else:
                raise _HxException(a8_Exception("don't know how to handle ResolvedLaunch.kind = ${resolvedLaunch.kind}",None,_hx_AnonObject({'fileName': "src/a8/launcher/Launcher.hx", 'lineNumber': 334, 'className': "a8.launcher.Launcher", 'methodName': "runAndWait"})))

    def initializeLogRollers(self):
        # src/a8/launcher/Launcher.hx:340
        _gthis = self
        # src/a8/launcher/Launcher.hx:344
        def _hx_local_0(lr):
            # src/a8/launcher/Launcher.hx:344
            return a8_launcher_LogRollerOps.fromConfig(lr,_gthis)
        # src/a8/launcher/Launcher.hx:341
        self.logRollers = list(map(_hx_local_0,Reflect.field(self.config,"logRollers")))
        # src/a8/launcher/Launcher.hx:345
        def _hx_local_1(i):
            # src/a8/launcher/Launcher.hx:345
            i.init()
            return
        Lambda.iter(self.logRollers,_hx_local_1)

    def get_a8VersionsCache(self):
        # src/a8/launcher/Launcher.hx:25
        return self.lazy_a8VersionsCache.get()

    def get_installDir(self):
        # src/a8/launcher/Launcher.hx:28
        return self.lazy_installDir.get()

    def get_logsDir(self):
        # src/a8/launcher/Launcher.hx:29
        return self.lazy_logsDir.get()

    def get_logArchivesDir(self):
        # src/a8/launcher/Launcher.hx:30
        return self.lazy_logArchivesDir.get()

    @staticmethod
    def initDirectory(configEntry,secondEntry,basePath,makeDirectory = None):
        # src/a8/launcher/Launcher.hx:39
        entry = (configEntry if ((configEntry is not None)) else secondEntry)
        # src/a8/launcher/Launcher.hx:40
        d = None
        # src/a8/launcher/Launcher.hx:41
        if (entry is None):
            d = basePath
        else:
            # src/a8/launcher/Launcher.hx:44
            asPath = a8_PathOps.path(entry)
            # src/a8/launcher/Launcher.hx:40
            d = (asPath if (a8_PathOps.isAbsolute(asPath)) else a8_PathOps.entry(basePath,entry))
        # src/a8/launcher/Launcher.hx:51
        if (makeDirectory and (not a8_PathOps.exists(d))):
            a8_PathOps.makeDirectories(d)
        # src/a8/launcher/Launcher.hx:54
        return d

a8_launcher_Launcher._hx_class = a8_launcher_Launcher


class a8_launcher_LogRollerOps:
    _hx_class_name = "a8.launcher.LogRollerOps"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["fromConfig", "scheduleAtMidnight"]

    @staticmethod
    def fromConfig(c,launcher):
        # src/a8/launcher/LogRoller.hx:11
        if (c == "midnight"):
            return a8_launcher_MidnightLogRoller(launcher)
        else:
            return a8_launcher_UnknownLogRoller(c)

    @staticmethod
    def scheduleAtMidnight(fn):
        # src/a8/launcher/LogRoller.hx:18
        now = Date.now()
        # src/a8/launcher/LogRoller.hx:19
        midnight = a8_DateOps.midnight()
        # src/a8/launcher/LogRoller.hx:20
        millisToMidnight = ((midnight.date.timestamp() * 1000) - ((now.date.timestamp() * 1000)))
        # src/a8/launcher/LogRoller.hx:21
        secondsToMidnight = (millisToMidnight / 1000)
        # src/a8/launcher/LogRoller.hx:22
        a8_GlobalScheduler.schedule(secondsToMidnight,fn)
a8_launcher_LogRollerOps._hx_class = a8_launcher_LogRollerOps


class a8_launcher_LogRoller:
    _hx_class_name = "a8.launcher.LogRoller"
    _hx_is_interface = "True"
    __slots__ = ()
    _hx_methods = ["init", "onArchiveLogChanges"]
a8_launcher_LogRoller._hx_class = a8_launcher_LogRoller


class a8_launcher_AbstractLogRoller:
    _hx_class_name = "a8.launcher.AbstractLogRoller"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_methods = ["init", "onArchiveLogChanges"]

    def init(self):
        pass

    def onArchiveLogChanges(self):
        pass

a8_launcher_AbstractLogRoller._hx_class = a8_launcher_AbstractLogRoller


class a8_launcher_MidnightLogRoller(a8_launcher_AbstractLogRoller):
    _hx_class_name = "a8.launcher.MidnightLogRoller"
    _hx_is_interface = "False"
    __slots__ = ("launcher",)
    _hx_fields = ["launcher"]
    _hx_methods = ["init", "schedule", "doMidnightRollover"]
    _hx_statics = []
    _hx_interfaces = [a8_launcher_LogRoller]
    _hx_super = a8_launcher_AbstractLogRoller


    def __init__(self,launcher):
        # src/a8/launcher/LogRoller.hx:42
        self.launcher = launcher

    def init(self):
        # src/a8/launcher/LogRoller.hx:45
        self.schedule()

    def schedule(self):
        # src/a8/launcher/LogRoller.hx:49
        a8_launcher_LogRollerOps.scheduleAtMidnight(self.doMidnightRollover)

    def doMidnightRollover(self):
        # src/a8/launcher/LogRoller.hx:53
        self.launcher.logTrace("running doMidnightRollover",_hx_AnonObject({'fileName': "src/a8/launcher/LogRoller.hx", 'lineNumber': 53, 'className': "a8.launcher.MidnightLogRoller", 'methodName': "doMidnightRollover"}))
        # src/a8/launcher/LogRoller.hx:54
        timestampStr = a8_PathOps.timestampStr()
        # src/a8/launcher/LogRoller.hx:56
        self.launcher.pipedStderr.rollover(timestampStr)
        # src/a8/launcher/LogRoller.hx:57
        self.launcher.pipedStdout.rollover(timestampStr)
        # src/a8/launcher/LogRoller.hx:58
        self.schedule()
        # src/a8/launcher/LogRoller.hx:59
        self.launcher.logTrace("doMidnightRollover complete",_hx_AnonObject({'fileName': "src/a8/launcher/LogRoller.hx", 'lineNumber': 59, 'className': "a8.launcher.MidnightLogRoller", 'methodName': "doMidnightRollover"}))

a8_launcher_MidnightLogRoller._hx_class = a8_launcher_MidnightLogRoller


class a8_launcher_UnknownLogRoller(a8_launcher_AbstractLogRoller):
    _hx_class_name = "a8.launcher.UnknownLogRoller"
    _hx_is_interface = "False"
    __slots__ = ("config",)
    _hx_fields = ["config"]
    _hx_methods = []
    _hx_statics = []
    _hx_interfaces = [a8_launcher_LogRoller]
    _hx_super = a8_launcher_AbstractLogRoller


    def __init__(self,config):
        # src/a8/launcher/LogRoller.hx:67
        self.config = config

a8_launcher_UnknownLogRoller._hx_class = a8_launcher_UnknownLogRoller


class a8_launcher_CullOldArchivesLogRoller(a8_launcher_AbstractLogRoller):
    _hx_class_name = "a8.launcher.CullOldArchivesLogRoller"
    _hx_is_interface = "False"
    __slots__ = ("config", "launcher")
    _hx_fields = ["config", "launcher"]
    _hx_methods = ["init", "cullOldLogs"]
    _hx_statics = []
    _hx_interfaces = [a8_launcher_LogRoller]
    _hx_super = a8_launcher_AbstractLogRoller


    def __init__(self,config,launcher):
        # src/a8/launcher/LogRoller.hx:77
        self.config = config
        # src/a8/launcher/LogRoller.hx:78
        self.launcher = launcher

    def init(self):
        # src/a8/launcher/LogRoller.hx:84
        a8_GlobalScheduler.submit(self.cullOldLogs)

    def cullOldLogs(self):
        # src/a8/launcher/LogRoller.hx:89
        fiveMinutes = 300
        # src/a8/launcher/LogRoller.hx:90
        a8_GlobalScheduler.schedule(fiveMinutes,self.cullOldLogs)

a8_launcher_CullOldArchivesLogRoller._hx_class = a8_launcher_CullOldArchivesLogRoller


class a8_launcher_Main:
    _hx_class_name = "a8.launcher.Main"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["loadConfig", "helpString", "main"]

    @staticmethod
    def loadConfig():
        # src/a8/launcher/Main.hx:17
        execPath = a8_PathOps.executablePath()
        # src/a8/launcher/Main.hx:18
        appName = execPath.file
        # src/a8/launcher/Main.hx:20
        configExtensions = [".json", ".launcher.json"]
        # src/a8/launcher/Main.hx:23
        _g = []
        x = HxOverrides.iterator(a8_PathOps.symlinkChain(execPath))
        while x.hasNext():
            x1 = x.next()
            # src/a8/launcher/Main.hx:25
            l = [x1]
            def _hx_local_1(l1):
                def _hx_local_0(e):
                    return a8_PathOps.entry(a8_PathOps.parent((l1[0] if 0 < len(l1) else None)),(HxOverrides.stringOrNull(a8_PathOps.name((l1[0] if 0 < len(l1) else None))) + ("null" if e is None else e)))
                return _hx_local_0
            # src/a8/launcher/Main.hx:23
            x2 = list(map(_hx_local_1(l),configExtensions))
            _g.append(x2)
        _g1 = []
        e1 = HxOverrides.iterator(_g)
        while e1.hasNext():
            e2 = e1.next()
            x3 = HxOverrides.iterator(e2)
            while x3.hasNext():
                x4 = x3.next()
                _g1.append(x4)
        # src/a8/launcher/Main.hx:22
        possibleConfigFiles = Lambda.array(_g1)
        # src/a8/launcher/Main.hx:33
        def _hx_local_2(f):
            # src/a8/launcher/Main.hx:33
            return a8_PathOps.exists(f)
        # src/a8/launcher/Main.hx:31
        configFile = Lambda.find(possibleConfigFiles,_hx_local_2)
        # src/a8/launcher/Main.hx:36
        config = python_lib_Json.loads(a8_PathOps.readText(configFile),**python__KwArgs_KwArgs_Impl_.fromT(_hx_AnonObject({'object_hook': python_Lib.dictToAnon})))
        # src/a8/launcher/Main.hx:38
        if (Reflect.field(config,"quiet") is None):
            Reflect.setField(config,"quiet",False)
        # src/a8/launcher/Main.hx:41
        if (Reflect.field(config,"logRollers") is None):
            Reflect.setField(config,"logRollers",[])
        # src/a8/launcher/Main.hx:44
        if (Reflect.field(config,"logFiles") is None):
            Reflect.setField(config,"logFiles",True)
        # src/a8/launcher/Main.hx:47
        if (config.kind == "jvm_cli"):
            # src/a8/launcher/Main.hx:48
            jvmLaunchConfig = config
            # src/a8/launcher/Main.hx:49
            Reflect.setField(config,"installDir",None)
            # src/a8/launcher/Main.hx:50
            Reflect.setField(config,"logFiles",False)
            # src/a8/launcher/Main.hx:51
            Reflect.setField(config,"logRollers",[])
        # src/a8/launcher/Main.hx:53
        if ((config.kind == "jvm") or ((config.kind == "jvm_cli"))):
            # src/a8/launcher/Main.hx:54
            jvmLaunchConfig1 = config
            # src/a8/launcher/Main.hx:55
            if (Reflect.field(jvmLaunchConfig1,"jvmArgs") is None):
                Reflect.setField(jvmLaunchConfig1,"jvmArgs",[])
            # src/a8/launcher/Main.hx:57
            if (Reflect.field(jvmLaunchConfig1,"args") is None):
                Reflect.setField(jvmLaunchConfig1,"args",[])
        # src/a8/launcher/Main.hx:62
        return config

    @staticmethod
    def helpString():
        # src/a8/launcher/Main.hx:69
        return "\nAccur8 Launcher Tool\n\n    The launchers job is to make sure the app is installed in the local cache and run the app it is configured to run.  \n\n    It will usually be installed (using Accur8 Recipes ie: a8-recipe install a8-scripts) at ~/tools-a8/packages/a8-scripts/a8-launcher.py\n\nConfiguration:\n    An app being run by the a8-launcher.py (or a copy/symbolic link of the launcher like a8-zoo) is configured by a .json file which will be alongside the command. \n    The base filename of the command needs to be the same as the json file. \n    So if you run the ‘a8-zoo’ launch command it will look for a ‘a8-zoo.json’ sitting alongside the a8-zoo command. \n    An example of a8-zoo.json will look like:\n        {\n            \"kind\": \"jvm_cli\",\n            \"mainClass\": \"a8.zoolander.Main\",\n            \"organization\": \"a8\",\n            \"artifact\": \"a8-zoolander_2.12\",\n            \"branch\": \"master\"\n        }\n\nUsage requirements:\n\n    Python 3.4+ (currently Python versions 3.7+ do not work)\n\n\nUsage:\n    --l-version <version> [<args>]\n        Runs the app with the specific version requested.\n\n    --l-resolveOnly\n        Does not run the app.\n        Sets up the inventory file(s) in a8VersionCache (~/a8/versions/cache) which contain app installer config and classpaths to jars.\n    \n    --l-help\n        Does not run the app.\n        Shows this help text.\n\n    [<args>]\n        Run the app passing through whatever arguments are passed in\n        \n"

    @staticmethod
    def main():
        # src/a8/launcher/Main.hx:114
        exitCode = 0
        # src/a8/launcher/Main.hx:116
        try:
            # src/a8/launcher/Main.hx:118
            execPath = a8_PathOps.executablePath()
            # src/a8/launcher/Main.hx:120
            appName = execPath.file
            # src/a8/launcher/Main.hx:122
            initialConfig = a8_launcher_Main.loadConfig()
            # src/a8/launcher/Main.hx:124
            args = list(python_lib_Sys.argv)
            # src/a8/launcher/Main.hx:125
            Reflect.setField(initialConfig,"rawCommandLineArgs",args)
            # src/a8/launcher/Main.hx:127
            clp = a8_launcher_CommandLineProcessor()
            # src/a8/launcher/Main.hx:128
            config = clp.apply(initialConfig)
            # src/a8/launcher/Main.hx:130
            a8_Logger.traceEnabled = (not Reflect.field(config,"quiet"))
            # src/a8/launcher/Main.hx:132
            if Reflect.field(config,"showHelp"):
                python_Lib.printString(Std.string(a8_launcher_Main.helpString()))
            else:
                # src/a8/launcher/Main.hx:135
                launcher = a8_launcher_Launcher(config,appName,args)
                # src/a8/launcher/Main.hx:141
                exitCode = launcher.runAndWait()
        except Exception as _hx_e:
            _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
            e = _hx_e1
            # src/a8/launcher/Main.hx:145
            stack = haxe_CallStack.exceptionStack()
            # src/a8/launcher/Main.hx:146
            a8_Logger.warn(((("" + Std.string(e)) + "\n") + HxOverrides.stringOrNull(a8_HaxeOps2.asString(stack,"    "))),_hx_AnonObject({'fileName': "src/a8/launcher/Main.hx", 'lineNumber': 146, 'className': "a8.launcher.Main", 'methodName': "main"}))
            # src/a8/launcher/Main.hx:147
            Sys.exit(1)
        # src/a8/launcher/Main.hx:150
        Sys.exit(exitCode)
a8_launcher_Main._hx_class = a8_launcher_Main


class a8_launcher_PipedStream:
    _hx_class_name = "a8.launcher.PipedStream"
    _hx_is_interface = "False"
    __slots__ = ("launcher", "processInput", "stdxxx", "fileExtension", "firstIO", "pipeToLogFiles", "initialTimestampStr", "pipe", "outputFile", "started")
    _hx_fields = ["launcher", "processInput", "stdxxx", "fileExtension", "firstIO", "pipeToLogFiles", "initialTimestampStr", "pipe", "outputFile", "started"]
    _hx_methods = ["start", "newOutputFile", "timestampedOutputFile", "log", "rollover", "close"]

    def __init__(self,launcher,processInput,stdxxx,fileExtension,firstIO,pipeToLogFiles,initialTimestampStr):
        # src/a8/launcher/PipedStream.hx:22
        self.pipe = None
        # src/a8/launcher/PipedStream.hx:26
        self.started = False
        # src/a8/launcher/PipedStream.hx:14
        self.launcher = launcher
        # src/a8/launcher/PipedStream.hx:15
        self.processInput = processInput
        # src/a8/launcher/PipedStream.hx:16
        self.stdxxx = stdxxx
        # src/a8/launcher/PipedStream.hx:17
        self.fileExtension = fileExtension
        # src/a8/launcher/PipedStream.hx:18
        self.firstIO = firstIO
        # src/a8/launcher/PipedStream.hx:19
        self.pipeToLogFiles = pipeToLogFiles
        # src/a8/launcher/PipedStream.hx:20
        self.initialTimestampStr = initialTimestampStr
        # src/a8/launcher/PipedStream.hx:24
        self.outputFile = haxe_ds_Option._hx_None

    def start(self):
        # src/a8/launcher/PipedStream.hx:29
        if (not self.started):
            # src/a8/launcher/PipedStream.hx:30
            self.started = True
            # src/a8/launcher/PipedStream.hx:31
            if self.pipeToLogFiles:
                # src/a8/launcher/PipedStream.hx:32
                of = self.newOutputFile(self.initialTimestampStr)
                # src/a8/launcher/PipedStream.hx:33
                self.outputFile = haxe_ds_Option.Some(of)
                # src/a8/launcher/PipedStream.hx:34
                self.pipe = a8_Pipe(self.processInput,of.teedOut,self.firstIO)
                # src/a8/launcher/PipedStream.hx:35
                self.pipe.run()
            else:
                # src/a8/launcher/PipedStream.hx:37
                self.outputFile = haxe_ds_Option._hx_None
                # src/a8/launcher/PipedStream.hx:38
                self.pipe = a8_Pipe(self.processInput,a8_StreamOps.asOutputStream(self.stdxxx),self.firstIO)
                # src/a8/launcher/PipedStream.hx:39
                self.pipe.run()

    def newOutputFile(self,timesatmpStr):
        # src/a8/launcher/PipedStream.hx:45
        fileOutputPath = self.timestampedOutputFile(timesatmpStr)
        # src/a8/launcher/PipedStream.hx:46
        fileOut = a8_StreamOps.fileOutputStream(a8_PathOps.realPathStr(fileOutputPath))
        # src/a8/launcher/PipedStream.hx:47
        teeOut = a8_TeeOutputStream([fileOut, a8_StreamOps.asOutputStream(self.stdxxx)])
        # src/a8/launcher/PipedStream.hx:48
        return _hx_AnonObject({'path': fileOutputPath, 'outputStream': fileOut, 'teedOut': teeOut})

    def timestampedOutputFile(self,timestampStr):
        # src/a8/launcher/PipedStream.hx:56
        return a8_PathOps.entry(self.launcher.get_logsDir(),((((HxOverrides.stringOrNull(self.launcher.appName) + ".") + ("null" if timestampStr is None else timestampStr)) + ".") + HxOverrides.stringOrNull(self.fileExtension)))

    def log(self,msg):
        # src/a8/launcher/PipedStream.hx:60
        _g = self.outputFile
        if (_g.index == 0):
            # src/a8/launcher/PipedStream.hx:61
            of = _g.params[0]
            # src/a8/launcher/PipedStream.hx:62
            try:
                # src/a8/launcher/PipedStream.hx:63
                of.teedOut.write(msg)
                # src/a8/launcher/PipedStream.hx:64
                of.teedOut.write("\n")
            except Exception as _hx_e:
                _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
                e = _hx_e1
                a8_Logger.warn(("error logging - " + Std.string(e)),_hx_AnonObject({'fileName': "src/a8/launcher/PipedStream.hx", 'lineNumber': 66, 'className': "a8.launcher.PipedStream", 'methodName': "log"}))

    def rollover(self,timestampStr):
        # src/a8/launcher/PipedStream.hx:73
        _g = self.outputFile
        tmp = _g.index
        # src/a8/launcher/PipedStream.hx:74
        if (tmp == 0):
            # src/a8/launcher/PipedStream.hx:74
            existingOutputFile = _g.params[0]
            # src/a8/launcher/PipedStream.hx:77
            newFileOutputPath = self.timestampedOutputFile(timestampStr)
            # src/a8/launcher/PipedStream.hx:78
            newfileOut = a8_PathOps.outputStream(newFileOutputPath)
            # src/a8/launcher/PipedStream.hx:79
            def _hx_local_0(oldOut):
                # src/a8/launcher/PipedStream.hx:80
                oldOut.close()
                # src/a8/launcher/PipedStream.hx:81
                return newfileOut
            self.pipe.replaceOutput = _hx_local_0
            # src/a8/launcher/PipedStream.hx:85
            oldFileoutputPath = existingOutputFile.path
            # src/a8/launcher/PipedStream.hx:86
            existingOutputFile.path = newFileOutputPath
            # src/a8/launcher/PipedStream.hx:87
            existingOutputFile.outputStream = newfileOut
            # src/a8/launcher/PipedStream.hx:88
            self.launcher.archiveLogFiles([oldFileoutputPath])
        elif (tmp == 1):
            raise _HxException(a8_Exception("this should not happen since rollover should never get called when we don't have a Some for outputFile: Option<PipedStreamOutputFile>",None,_hx_AnonObject({'fileName': "src/a8/launcher/PipedStream.hx", 'lineNumber': 92, 'className': "a8.launcher.PipedStream", 'methodName': "rollover"})))
        else:
            pass

    def close(self):
        # src/a8/launcher/PipedStream.hx:98
        def _hx_local_0(f):
            # src/a8/launcher/PipedStream.hx:98
            f.teedOut.close()
            return
        a8_OptionOps.iter(self.outputFile,_hx_local_0)

a8_launcher_PipedStream._hx_class = a8_launcher_PipedStream

class haxe_StackItem(Enum):
    __slots__ = ()
    _hx_class_name = "haxe.StackItem"
    _hx_constructs = ["CFunction", "Module", "FilePos", "Method", "LocalFunction"]

    @staticmethod
    def Module(m):
        return haxe_StackItem("Module", 1, (m,))

    @staticmethod
    def FilePos(s,file,line,column = None):
        return haxe_StackItem("FilePos", 2, (s,file,line,column))

    @staticmethod
    def Method(classname,method):
        return haxe_StackItem("Method", 3, (classname,method))

    @staticmethod
    def LocalFunction(v = None):
        return haxe_StackItem("LocalFunction", 4, (v,))
haxe_StackItem.CFunction = haxe_StackItem("CFunction", 0, ())
haxe_StackItem._hx_class = haxe_StackItem


class haxe_CallStack:
    _hx_class_name = "haxe.CallStack"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["callStack", "exceptionStack"]

    @staticmethod
    def callStack():
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/CallStack.hx:135
        stack = []
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/CallStack.hx:136
        infos = python_lib_Traceback.extract_stack()
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/CallStack.hx:137
        if (len(infos) != 0):
            infos.pop()
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/CallStack.hx:138
        infos.reverse()
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/CallStack.hx:139
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/CallStack.hx:139
        _g = 0
        while (_g < len(infos)):
            elem = (infos[_g] if _g >= 0 and _g < len(infos) else None)
            _g = (_g + 1)
            # /Users/glen/tools-a8/packages/haxe/current/std/haxe/CallStack.hx:140
            # /Users/glen/tools-a8/packages/haxe/current/std/haxe/CallStack.hx:140
            x = haxe_StackItem.FilePos(haxe_StackItem.Method(None,elem[2]),elem[0],elem[1])
            stack.append(x)
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/CallStack.hx:141
        return stack

    @staticmethod
    def exceptionStack():
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/CallStack.hx:238
        stack = []
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/CallStack.hx:239
        exc = python_lib_Sys.exc_info()
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/CallStack.hx:240
        if (exc[2] is not None):
            # /Users/glen/tools-a8/packages/haxe/current/std/haxe/CallStack.hx:241
            infos = python_lib_Traceback.extract_tb(exc[2])
            # /Users/glen/tools-a8/packages/haxe/current/std/haxe/CallStack.hx:242
            infos.reverse()
            # /Users/glen/tools-a8/packages/haxe/current/std/haxe/CallStack.hx:243
            # /Users/glen/tools-a8/packages/haxe/current/std/haxe/CallStack.hx:243
            _g = 0
            while (_g < len(infos)):
                elem = (infos[_g] if _g >= 0 and _g < len(infos) else None)
                _g = (_g + 1)
                # /Users/glen/tools-a8/packages/haxe/current/std/haxe/CallStack.hx:244
                # /Users/glen/tools-a8/packages/haxe/current/std/haxe/CallStack.hx:244
                x = haxe_StackItem.FilePos(haxe_StackItem.Method(None,elem[2]),elem[0],elem[1])
                stack.append(x)
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/CallStack.hx:246
        return stack
haxe_CallStack._hx_class = haxe_CallStack


class haxe_EntryPoint:
    _hx_class_name = "haxe.EntryPoint"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["pending", "threadCount", "processEvents", "run"]

    @staticmethod
    def processEvents():
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/EntryPoint.hx:87
        while True:
            # /Users/glen/tools-a8/packages/haxe/current/std/haxe/EntryPoint.hx:90
            _this = haxe_EntryPoint.pending
            f = (None if ((len(_this) == 0)) else _this.pop(0))
            # /Users/glen/tools-a8/packages/haxe/current/std/haxe/EntryPoint.hx:95
            if (f is None):
                break
            # /Users/glen/tools-a8/packages/haxe/current/std/haxe/EntryPoint.hx:97
            f()
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/EntryPoint.hx:99
        time = haxe_MainLoop.tick()
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/EntryPoint.hx:100
        if ((not haxe_MainLoop.hasEvents()) and ((haxe_EntryPoint.threadCount == 0))):
            return -1
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/EntryPoint.hx:102
        return time

    @staticmethod
    def run():
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/EntryPoint.hx:124
        while True:
            # /Users/glen/tools-a8/packages/haxe/current/std/haxe/EntryPoint.hx:125
            nextTick = haxe_EntryPoint.processEvents()
            # /Users/glen/tools-a8/packages/haxe/current/std/haxe/EntryPoint.hx:126
            if (nextTick < 0):
                break
            # /Users/glen/tools-a8/packages/haxe/current/std/haxe/EntryPoint.hx:128
            tmp = (nextTick > 0)
haxe_EntryPoint._hx_class = haxe_EntryPoint


class haxe_Log:
    _hx_class_name = "haxe.Log"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["formatOutput", "trace"]

    @staticmethod
    def formatOutput(v,infos):
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/Log.hx:34
        _hx_str = Std.string(v)
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/Log.hx:35
        if (infos is None):
            return _hx_str
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/Log.hx:37
        pstr = ((HxOverrides.stringOrNull(infos.fileName) + ":") + Std.string(infos.lineNumber))
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/Log.hx:38
        if (Reflect.field(infos,"customParams") is not None):
            # /Users/glen/tools-a8/packages/haxe/current/std/haxe/Log.hx:39
            _g = 0
            _g1 = Reflect.field(infos,"customParams")
            while (_g < len(_g1)):
                v1 = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
                _g = (_g + 1)
                # /Users/glen/tools-a8/packages/haxe/current/std/haxe/Log.hx:40
                _hx_str = (("null" if _hx_str is None else _hx_str) + ((", " + Std.string(v1))))
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/Log.hx:41
        return ((("null" if pstr is None else pstr) + ": ") + ("null" if _hx_str is None else _hx_str))

    @staticmethod
    def trace(v,infos = None):
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/Log.hx:63
        _hx_str = haxe_Log.formatOutput(v,infos)
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/Log.hx:70
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/Log.hx:70
        str1 = Std.string(_hx_str)
        python_Lib.printString((("" + ("null" if str1 is None else str1)) + HxOverrides.stringOrNull(python_Lib.lineEnd)))
haxe_Log._hx_class = haxe_Log


class haxe_MainEvent:
    _hx_class_name = "haxe.MainEvent"
    _hx_is_interface = "False"
    __slots__ = ("f", "prev", "next", "isBlocking", "nextRun", "priority")
    _hx_fields = ["f", "prev", "next", "isBlocking", "nextRun", "priority"]
    _hx_methods = ["delay", "stop"]

    def __init__(self,f,p):
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/MainLoop.hx:8
        self.next = None
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/MainLoop.hx:7
        self.prev = None
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/MainLoop.hx:13
        self.isBlocking = True
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/MainLoop.hx:19
        self.f = f
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/MainLoop.hx:20
        self.priority = p
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/MainLoop.hx:21
        self.nextRun = Math.NEGATIVE_INFINITY

    def delay(self,t):
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/MainLoop.hx:29
        self.nextRun = (Math.NEGATIVE_INFINITY if ((t is None)) else (python_lib_Timeit.default_timer() + t))

    def stop(self):
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/MainLoop.hx:44
        if (self.f is None):
            return
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/MainLoop.hx:46
        self.f = None
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/MainLoop.hx:47
        self.nextRun = Math.NEGATIVE_INFINITY
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/MainLoop.hx:48
        if (self.prev is None):
            haxe_MainLoop.pending = self.next
        else:
            self.prev.next = self.next
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/MainLoop.hx:52
        if (self.next is not None):
            self.next.prev = self.prev

haxe_MainEvent._hx_class = haxe_MainEvent


class haxe_MainLoop:
    _hx_class_name = "haxe.MainLoop"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["pending", "hasEvents", "add", "sortEvents", "tick"]
    pending = None
    threadCount = None

    @staticmethod
    def hasEvents():
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/MainLoop.hx:67
        p = haxe_MainLoop.pending
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/MainLoop.hx:68
        while (p is not None):
            # /Users/glen/tools-a8/packages/haxe/current/std/haxe/MainLoop.hx:69
            if p.isBlocking:
                return True
            # /Users/glen/tools-a8/packages/haxe/current/std/haxe/MainLoop.hx:71
            p = p.next
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/MainLoop.hx:73
        return False

    @staticmethod
    def add(f,priority = None):
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/MainLoop.hx:87
        if (priority is None):
            priority = 0
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/MainLoop.hx:88
        if (f is None):
            raise _HxException("Event function is null")
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/MainLoop.hx:90
        e = haxe_MainEvent(f,priority)
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/MainLoop.hx:91
        head = haxe_MainLoop.pending
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/MainLoop.hx:92
        if (head is not None):
            head.prev = e
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/MainLoop.hx:94
        e.next = head
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/MainLoop.hx:95
        haxe_MainLoop.pending = e
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/MainLoop.hx:96
        return e

    @staticmethod
    def sortEvents():
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/MainLoop.hx:103
        _hx_list = haxe_MainLoop.pending
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/MainLoop.hx:105
        if (_hx_list is None):
            return
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/MainLoop.hx:108
        insize = 1
        nmerges = None
        psize = 0
        qsize = 0
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/MainLoop.hx:109
        p = None
        q = None
        e = None
        tail = None
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/MainLoop.hx:111
        while True:
            # /Users/glen/tools-a8/packages/haxe/current/std/haxe/MainLoop.hx:112
            p = _hx_list
            # /Users/glen/tools-a8/packages/haxe/current/std/haxe/MainLoop.hx:113
            _hx_list = None
            # /Users/glen/tools-a8/packages/haxe/current/std/haxe/MainLoop.hx:114
            tail = None
            # /Users/glen/tools-a8/packages/haxe/current/std/haxe/MainLoop.hx:115
            nmerges = 0
            # /Users/glen/tools-a8/packages/haxe/current/std/haxe/MainLoop.hx:116
            while (p is not None):
                # /Users/glen/tools-a8/packages/haxe/current/std/haxe/MainLoop.hx:117
                nmerges = (nmerges + 1)
                # /Users/glen/tools-a8/packages/haxe/current/std/haxe/MainLoop.hx:118
                q = p
                # /Users/glen/tools-a8/packages/haxe/current/std/haxe/MainLoop.hx:119
                psize = 0
                # /Users/glen/tools-a8/packages/haxe/current/std/haxe/MainLoop.hx:120
                # /Users/glen/tools-a8/packages/haxe/current/std/haxe/MainLoop.hx:120
                _g = 0
                _g1 = insize
                while (_g < _g1):
                    i = _g
                    _g = (_g + 1)
                    # /Users/glen/tools-a8/packages/haxe/current/std/haxe/MainLoop.hx:121
                    psize = (psize + 1)
                    # /Users/glen/tools-a8/packages/haxe/current/std/haxe/MainLoop.hx:122
                    q = q.next
                    # /Users/glen/tools-a8/packages/haxe/current/std/haxe/MainLoop.hx:123
                    if (q is None):
                        break
                # /Users/glen/tools-a8/packages/haxe/current/std/haxe/MainLoop.hx:126
                qsize = insize
                # /Users/glen/tools-a8/packages/haxe/current/std/haxe/MainLoop.hx:127
                while ((psize > 0) or (((qsize > 0) and ((q is not None))))):
                    # /Users/glen/tools-a8/packages/haxe/current/std/haxe/MainLoop.hx:128
                    if (psize == 0):
                        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/MainLoop.hx:129
                        e = q
                        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/MainLoop.hx:130
                        q = q.next
                        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/MainLoop.hx:131
                        qsize = (qsize - 1)
                    elif (((qsize == 0) or ((q is None))) or (((p.priority > q.priority) or (((p.priority == q.priority) and ((p.nextRun <= q.nextRun))))))):
                        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/MainLoop.hx:135
                        e = p
                        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/MainLoop.hx:136
                        p = p.next
                        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/MainLoop.hx:137
                        psize = (psize - 1)
                    else:
                        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/MainLoop.hx:139
                        e = q
                        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/MainLoop.hx:140
                        q = q.next
                        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/MainLoop.hx:141
                        qsize = (qsize - 1)
                    # /Users/glen/tools-a8/packages/haxe/current/std/haxe/MainLoop.hx:143
                    if (tail is not None):
                        tail.next = e
                    else:
                        _hx_list = e
                    # /Users/glen/tools-a8/packages/haxe/current/std/haxe/MainLoop.hx:147
                    e.prev = tail
                    # /Users/glen/tools-a8/packages/haxe/current/std/haxe/MainLoop.hx:148
                    tail = e
                # /Users/glen/tools-a8/packages/haxe/current/std/haxe/MainLoop.hx:150
                p = q
            # /Users/glen/tools-a8/packages/haxe/current/std/haxe/MainLoop.hx:152
            tail.next = None
            # /Users/glen/tools-a8/packages/haxe/current/std/haxe/MainLoop.hx:153
            if (nmerges <= 1):
                break
            # /Users/glen/tools-a8/packages/haxe/current/std/haxe/MainLoop.hx:155
            insize = (insize * 2)
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/MainLoop.hx:157
        _hx_list.prev = None
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/MainLoop.hx:158
        haxe_MainLoop.pending = _hx_list

    @staticmethod
    def tick():
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/MainLoop.hx:165
        haxe_MainLoop.sortEvents()
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/MainLoop.hx:166
        e = haxe_MainLoop.pending
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/MainLoop.hx:167
        now = python_lib_Timeit.default_timer()
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/MainLoop.hx:168
        wait = 1e9
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/MainLoop.hx:169
        while (e is not None):
            # /Users/glen/tools-a8/packages/haxe/current/std/haxe/MainLoop.hx:170
            next = e.next
            # /Users/glen/tools-a8/packages/haxe/current/std/haxe/MainLoop.hx:171
            wt = (e.nextRun - now)
            # /Users/glen/tools-a8/packages/haxe/current/std/haxe/MainLoop.hx:172
            if (wt <= 0):
                # /Users/glen/tools-a8/packages/haxe/current/std/haxe/MainLoop.hx:173
                wait = 0
                # /Users/glen/tools-a8/packages/haxe/current/std/haxe/MainLoop.hx:174
                if (e.f is not None):
                    e.f()
            elif (wait > wt):
                wait = wt
            # /Users/glen/tools-a8/packages/haxe/current/std/haxe/MainLoop.hx:177
            e = next
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/MainLoop.hx:179
        return wait
haxe_MainLoop._hx_class = haxe_MainLoop


class haxe_Timer:
    _hx_class_name = "haxe.Timer"
    _hx_is_interface = "False"
    _hx_fields = ["event"]
    _hx_methods = ["stop", "run"]
    _hx_statics = ["delay"]

    def __init__(self,time_ms):
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/Timer.hx:46
        self.event = None
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/Timer.hx:60
        _gthis = self
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/Timer.hx:73
        dt = (time_ms / 1000)
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/Timer.hx:74
        def _hx_local_2():
            # /Users/glen/tools-a8/packages/haxe/current/std/haxe/Timer.hx:75
            # /Users/glen/tools-a8/packages/haxe/current/std/haxe/Timer.hx:75
            _hx_local_0 = _gthis.event
            _hx_local_1 = _hx_local_0.nextRun
            _hx_local_0.nextRun = (_hx_local_1 + dt)
            _hx_local_0.nextRun
            # /Users/glen/tools-a8/packages/haxe/current/std/haxe/Timer.hx:76
            _gthis.run()
        self.event = haxe_MainLoop.add(_hx_local_2)
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/Timer.hx:78
        self.event.delay(dt)

    def stop(self):
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/Timer.hx:107
        if (self.event is not None):
            # /Users/glen/tools-a8/packages/haxe/current/std/haxe/Timer.hx:108
            self.event.stop()
            # /Users/glen/tools-a8/packages/haxe/current/std/haxe/Timer.hx:109
            self.event = None

    def run(self):
        pass

    @staticmethod
    def delay(f,time_ms):
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/Timer.hx:140
        t = haxe_Timer(time_ms)
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/Timer.hx:141
        def _hx_local_0():
            # /Users/glen/tools-a8/packages/haxe/current/std/haxe/Timer.hx:142
            t.stop()
            # /Users/glen/tools-a8/packages/haxe/current/std/haxe/Timer.hx:143
            f()
        t.run = _hx_local_0
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/Timer.hx:145
        return t

haxe_Timer._hx_class = haxe_Timer

class haxe_ds_Either(Enum):
    __slots__ = ()
    _hx_class_name = "haxe.ds.Either"
    _hx_constructs = ["Left", "Right"]

    @staticmethod
    def Left(v):
        return haxe_ds_Either("Left", 0, (v,))

    @staticmethod
    def Right(v):
        return haxe_ds_Either("Right", 1, (v,))
haxe_ds_Either._hx_class = haxe_ds_Either


class haxe_ds_ObjectMap:
    _hx_class_name = "haxe.ds.ObjectMap"
    _hx_is_interface = "False"
    __slots__ = ("h",)
    _hx_fields = ["h"]
    _hx_methods = ["get", "keys"]
    _hx_interfaces = [haxe_IMap]

    def __init__(self):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/haxe/ds/ObjectMap.hx:31
        self.h = dict()

    def get(self,key):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/haxe/ds/ObjectMap.hx:39
        return self.h.get(key,None)

    def keys(self):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/haxe/ds/ObjectMap.hx:54
        return python_HaxeIterator(iter(self.h.keys()))

haxe_ds_ObjectMap._hx_class = haxe_ds_ObjectMap


class haxe_format_JsonPrinter:
    _hx_class_name = "haxe.format.JsonPrinter"
    _hx_is_interface = "False"
    __slots__ = ("buf", "replacer", "indent", "pretty", "nind")
    _hx_fields = ["buf", "replacer", "indent", "pretty", "nind"]
    _hx_methods = ["write", "classString", "fieldsString", "quote"]
    _hx_statics = ["print"]

    def __init__(self,replacer,space):
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/format/JsonPrinter.hx:57
        self.replacer = replacer
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/format/JsonPrinter.hx:58
        self.indent = space
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/format/JsonPrinter.hx:59
        self.pretty = (space is not None)
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/format/JsonPrinter.hx:60
        self.nind = 0
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/format/JsonPrinter.hx:67
        self.buf = StringBuf()

    def write(self,k,v):
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/format/JsonPrinter.hx:82
        if (self.replacer is not None):
            v = self.replacer(k,v)
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/format/JsonPrinter.hx:84
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/format/JsonPrinter.hx:84
        _g = Type.typeof(v)
        tmp = _g.index
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/format/JsonPrinter.hx:136
        if (tmp == 0):
            self.buf.b.write("null")
        elif (tmp == 1):
            # /Users/glen/tools-a8/packages/haxe/current/std/haxe/format/JsonPrinter.hx:90
            _this = self.buf
            s = Std.string(v)
            _this.b.write(s)
        elif (tmp == 2):
            # /Users/glen/tools-a8/packages/haxe/current/std/haxe/format/JsonPrinter.hx:92
            f = v
            v1 = (Std.string(v) if ((((f != Math.POSITIVE_INFINITY) and ((f != Math.NEGATIVE_INFINITY))) and (not python_lib_Math.isnan(f)))) else "null")
            _this1 = self.buf
            s1 = Std.string(v1)
            _this1.b.write(s1)
        elif (tmp == 3):
            # /Users/glen/tools-a8/packages/haxe/current/std/haxe/format/JsonPrinter.hx:134
            _this2 = self.buf
            s2 = Std.string(v)
            _this2.b.write(s2)
        elif (tmp == 4):
            self.fieldsString(v,python_Boot.fields(v))
        elif (tmp == 5):
            self.buf.b.write("\"<fun>\"")
        elif (tmp == 6):
            # /Users/glen/tools-a8/packages/haxe/current/std/haxe/format/JsonPrinter.hx:95
            c = _g.params[0]
            # /Users/glen/tools-a8/packages/haxe/current/std/haxe/format/JsonPrinter.hx:96
            if (c == str):
                self.quote(v)
            elif (c == list):
                # /Users/glen/tools-a8/packages/haxe/current/std/haxe/format/JsonPrinter.hx:99
                v2 = v
                # /Users/glen/tools-a8/packages/haxe/current/std/haxe/format/JsonPrinter.hx:100
                # /Users/glen/tools-a8/packages/haxe/current/std/haxe/format/JsonPrinter.hx:100
                _this3 = self.buf
                s3 = "".join(map(chr,[91]))
                _this3.b.write(s3)
                # /Users/glen/tools-a8/packages/haxe/current/std/haxe/format/JsonPrinter.hx:102
                _hx_len = len(v2)
                # /Users/glen/tools-a8/packages/haxe/current/std/haxe/format/JsonPrinter.hx:103
                last = (_hx_len - 1)
                # /Users/glen/tools-a8/packages/haxe/current/std/haxe/format/JsonPrinter.hx:104
                # /Users/glen/tools-a8/packages/haxe/current/std/haxe/format/JsonPrinter.hx:104
                _g1 = 0
                _g11 = _hx_len
                while (_g1 < _g11):
                    i = _g1
                    _g1 = (_g1 + 1)
                    # /Users/glen/tools-a8/packages/haxe/current/std/haxe/format/JsonPrinter.hx:105
                    if (i > 0):
                        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/format/JsonPrinter.hx:106
                        _this4 = self.buf
                        s4 = "".join(map(chr,[44]))
                        _this4.b.write(s4)
                    else:
                        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/format/JsonPrinter.hx:108
                        _hx_local_0 = self
                        _hx_local_1 = _hx_local_0.nind
                        _hx_local_0.nind = (_hx_local_1 + 1)
                        _hx_local_1
                    # /Users/glen/tools-a8/packages/haxe/current/std/haxe/format/JsonPrinter.hx:109
                    if self.pretty:
                        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/format/JsonPrinter.hx:109
                        _this5 = self.buf
                        s5 = "".join(map(chr,[10]))
                        _this5.b.write(s5)
                    # /Users/glen/tools-a8/packages/haxe/current/std/haxe/format/JsonPrinter.hx:110
                    if self.pretty:
                        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/format/JsonPrinter.hx:110
                        v3 = StringTools.lpad("",self.indent,(self.nind * len(self.indent)))
                        _this6 = self.buf
                        s6 = Std.string(v3)
                        _this6.b.write(s6)
                    # /Users/glen/tools-a8/packages/haxe/current/std/haxe/format/JsonPrinter.hx:111
                    self.write(i,(v2[i] if i >= 0 and i < len(v2) else None))
                    # /Users/glen/tools-a8/packages/haxe/current/std/haxe/format/JsonPrinter.hx:112
                    if (i == last):
                        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/format/JsonPrinter.hx:113
                        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/format/JsonPrinter.hx:113
                        _hx_local_2 = self
                        _hx_local_3 = _hx_local_2.nind
                        _hx_local_2.nind = (_hx_local_3 - 1)
                        _hx_local_3
                        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/format/JsonPrinter.hx:114
                        if self.pretty:
                            # /Users/glen/tools-a8/packages/haxe/current/std/haxe/format/JsonPrinter.hx:114
                            _this7 = self.buf
                            s7 = "".join(map(chr,[10]))
                            _this7.b.write(s7)
                        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/format/JsonPrinter.hx:115
                        if self.pretty:
                            # /Users/glen/tools-a8/packages/haxe/current/std/haxe/format/JsonPrinter.hx:115
                            v4 = StringTools.lpad("",self.indent,(self.nind * len(self.indent)))
                            _this8 = self.buf
                            s8 = Std.string(v4)
                            _this8.b.write(s8)
                # /Users/glen/tools-a8/packages/haxe/current/std/haxe/format/JsonPrinter.hx:118
                # /Users/glen/tools-a8/packages/haxe/current/std/haxe/format/JsonPrinter.hx:118
                _this9 = self.buf
                s9 = "".join(map(chr,[93]))
                _this9.b.write(s9)
            elif (c == haxe_ds_StringMap):
                # /Users/glen/tools-a8/packages/haxe/current/std/haxe/format/JsonPrinter.hx:120
                v5 = v
                # /Users/glen/tools-a8/packages/haxe/current/std/haxe/format/JsonPrinter.hx:121
                o = _hx_AnonObject({})
                # /Users/glen/tools-a8/packages/haxe/current/std/haxe/format/JsonPrinter.hx:122
                # /Users/glen/tools-a8/packages/haxe/current/std/haxe/format/JsonPrinter.hx:122
                k1 = v5.keys()
                while k1.hasNext():
                    k2 = k1.next()
                    # /Users/glen/tools-a8/packages/haxe/current/std/haxe/format/JsonPrinter.hx:123
                    value = v5.h.get(k2,None)
                    setattr(o,(("_hx_" + k2) if ((k2 in python_Boot.keywords)) else (("_hx_" + k2) if (((((len(k2) > 2) and ((ord(k2[0]) == 95))) and ((ord(k2[1]) == 95))) and ((ord(k2[(len(k2) - 1)]) != 95)))) else k2)),value)
                # /Users/glen/tools-a8/packages/haxe/current/std/haxe/format/JsonPrinter.hx:124
                # /Users/glen/tools-a8/packages/haxe/current/std/haxe/format/JsonPrinter.hx:124
                v6 = o
                self.fieldsString(v6,python_Boot.fields(v6))
            elif (c == Date):
                # /Users/glen/tools-a8/packages/haxe/current/std/haxe/format/JsonPrinter.hx:126
                v7 = v
                # /Users/glen/tools-a8/packages/haxe/current/std/haxe/format/JsonPrinter.hx:127
                self.quote(v7.toString())
            else:
                self.classString(v)
        elif (tmp == 7):
            # /Users/glen/tools-a8/packages/haxe/current/std/haxe/format/JsonPrinter.hx:130
            _g12 = _g.params[0]
            # /Users/glen/tools-a8/packages/haxe/current/std/haxe/format/JsonPrinter.hx:131
            i1 = v.index
            # /Users/glen/tools-a8/packages/haxe/current/std/haxe/format/JsonPrinter.hx:132
            # /Users/glen/tools-a8/packages/haxe/current/std/haxe/format/JsonPrinter.hx:132
            _this10 = self.buf
            s10 = Std.string(i1)
            _this10.b.write(s10)
        elif (tmp == 8):
            self.buf.b.write("\"???\"")
        else:
            pass

    def classString(self,v):
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/format/JsonPrinter.hx:158
        self.fieldsString(v,python_Boot.getInstanceFields(Type.getClass(v)))

    def fieldsString(self,v,fields):
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/format/JsonPrinter.hx:166
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/format/JsonPrinter.hx:166
        _this = self.buf
        s = "".join(map(chr,[123]))
        _this.b.write(s)
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/format/JsonPrinter.hx:167
        _hx_len = len(fields)
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/format/JsonPrinter.hx:168
        last = (_hx_len - 1)
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/format/JsonPrinter.hx:169
        first = True
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/format/JsonPrinter.hx:170
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/format/JsonPrinter.hx:170
        _g = 0
        _g1 = _hx_len
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            # /Users/glen/tools-a8/packages/haxe/current/std/haxe/format/JsonPrinter.hx:171
            f = (fields[i] if i >= 0 and i < len(fields) else None)
            # /Users/glen/tools-a8/packages/haxe/current/std/haxe/format/JsonPrinter.hx:172
            value = Reflect.field(v,f)
            # /Users/glen/tools-a8/packages/haxe/current/std/haxe/format/JsonPrinter.hx:173
            if Reflect.isFunction(value):
                continue
            # /Users/glen/tools-a8/packages/haxe/current/std/haxe/format/JsonPrinter.hx:175
            if first:
                # /Users/glen/tools-a8/packages/haxe/current/std/haxe/format/JsonPrinter.hx:176
                # /Users/glen/tools-a8/packages/haxe/current/std/haxe/format/JsonPrinter.hx:176
                _hx_local_0 = self
                _hx_local_1 = _hx_local_0.nind
                _hx_local_0.nind = (_hx_local_1 + 1)
                _hx_local_1
                # /Users/glen/tools-a8/packages/haxe/current/std/haxe/format/JsonPrinter.hx:177
                first = False
            else:
                # /Users/glen/tools-a8/packages/haxe/current/std/haxe/format/JsonPrinter.hx:179
                _this1 = self.buf
                s1 = "".join(map(chr,[44]))
                _this1.b.write(s1)
            # /Users/glen/tools-a8/packages/haxe/current/std/haxe/format/JsonPrinter.hx:180
            if self.pretty:
                # /Users/glen/tools-a8/packages/haxe/current/std/haxe/format/JsonPrinter.hx:180
                _this2 = self.buf
                s2 = "".join(map(chr,[10]))
                _this2.b.write(s2)
            # /Users/glen/tools-a8/packages/haxe/current/std/haxe/format/JsonPrinter.hx:181
            if self.pretty:
                # /Users/glen/tools-a8/packages/haxe/current/std/haxe/format/JsonPrinter.hx:181
                v1 = StringTools.lpad("",self.indent,(self.nind * len(self.indent)))
                _this3 = self.buf
                s3 = Std.string(v1)
                _this3.b.write(s3)
            # /Users/glen/tools-a8/packages/haxe/current/std/haxe/format/JsonPrinter.hx:182
            self.quote(f)
            # /Users/glen/tools-a8/packages/haxe/current/std/haxe/format/JsonPrinter.hx:183
            # /Users/glen/tools-a8/packages/haxe/current/std/haxe/format/JsonPrinter.hx:183
            _this4 = self.buf
            s4 = "".join(map(chr,[58]))
            _this4.b.write(s4)
            # /Users/glen/tools-a8/packages/haxe/current/std/haxe/format/JsonPrinter.hx:184
            if self.pretty:
                # /Users/glen/tools-a8/packages/haxe/current/std/haxe/format/JsonPrinter.hx:185
                _this5 = self.buf
                s5 = "".join(map(chr,[32]))
                _this5.b.write(s5)
            # /Users/glen/tools-a8/packages/haxe/current/std/haxe/format/JsonPrinter.hx:186
            self.write(f,value)
            # /Users/glen/tools-a8/packages/haxe/current/std/haxe/format/JsonPrinter.hx:187
            if (i == last):
                # /Users/glen/tools-a8/packages/haxe/current/std/haxe/format/JsonPrinter.hx:188
                # /Users/glen/tools-a8/packages/haxe/current/std/haxe/format/JsonPrinter.hx:188
                _hx_local_2 = self
                _hx_local_3 = _hx_local_2.nind
                _hx_local_2.nind = (_hx_local_3 - 1)
                _hx_local_3
                # /Users/glen/tools-a8/packages/haxe/current/std/haxe/format/JsonPrinter.hx:189
                if self.pretty:
                    # /Users/glen/tools-a8/packages/haxe/current/std/haxe/format/JsonPrinter.hx:189
                    _this6 = self.buf
                    s6 = "".join(map(chr,[10]))
                    _this6.b.write(s6)
                # /Users/glen/tools-a8/packages/haxe/current/std/haxe/format/JsonPrinter.hx:190
                if self.pretty:
                    # /Users/glen/tools-a8/packages/haxe/current/std/haxe/format/JsonPrinter.hx:190
                    v2 = StringTools.lpad("",self.indent,(self.nind * len(self.indent)))
                    _this7 = self.buf
                    s7 = Std.string(v2)
                    _this7.b.write(s7)
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/format/JsonPrinter.hx:193
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/format/JsonPrinter.hx:193
        _this8 = self.buf
        s8 = "".join(map(chr,[125]))
        _this8.b.write(s8)

    def quote(self,s):
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/format/JsonPrinter.hx:203
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/format/JsonPrinter.hx:203
        _this = self.buf
        s1 = "".join(map(chr,[34]))
        _this.b.write(s1)
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/format/JsonPrinter.hx:204
        i = 0
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/format/JsonPrinter.hx:208
        while True:
            # /Users/glen/tools-a8/packages/haxe/current/std/haxe/format/JsonPrinter.hx:209
            index = i
            i = (i + 1)
            c = (-1 if ((index >= len(s))) else ord(s[index]))
            # /Users/glen/tools-a8/packages/haxe/current/std/haxe/format/JsonPrinter.hx:210
            if (c == -1):
                break
            # /Users/glen/tools-a8/packages/haxe/current/std/haxe/format/JsonPrinter.hx:212
            c1 = c
            # /Users/glen/tools-a8/packages/haxe/current/std/haxe/format/JsonPrinter.hx:224
            if (c1 == 8):
                self.buf.b.write("\\b")
            elif (c1 == 9):
                self.buf.b.write("\\t")
            elif (c1 == 10):
                self.buf.b.write("\\n")
            elif (c1 == 12):
                self.buf.b.write("\\f")
            elif (c1 == 13):
                self.buf.b.write("\\r")
            elif (c1 == 34):
                self.buf.b.write("\\\"")
            elif (c1 == 92):
                self.buf.b.write("\\\\")
            else:
                # /Users/glen/tools-a8/packages/haxe/current/std/haxe/format/JsonPrinter.hx:249
                _this1 = self.buf
                s2 = "".join(map(chr,[c]))
                _this1.b.write(s2)
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/format/JsonPrinter.hx:257
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/format/JsonPrinter.hx:257
        _this2 = self.buf
        s3 = "".join(map(chr,[34]))
        _this2.b.write(s3)

    @staticmethod
    def print(o,replacer = None,space = None):
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/format/JsonPrinter.hx:45
        printer = haxe_format_JsonPrinter(replacer,space)
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/format/JsonPrinter.hx:46
        printer.write("",o)
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/format/JsonPrinter.hx:47
        return printer.buf.b.getvalue()

haxe_format_JsonPrinter._hx_class = haxe_format_JsonPrinter


class haxe_http_HttpBase:
    _hx_class_name = "haxe.http.HttpBase"
    _hx_is_interface = "False"
    _hx_fields = ["url", "responseBytes", "responseAsString", "postData", "postBytes", "headers", "params", "emptyOnData"]
    _hx_methods = ["onData", "onBytes", "onError", "onStatus", "hasOnData", "success", "get_responseData"]

    def __init__(self,url):
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/http/HttpBase.hx:58
        self.emptyOnData = None
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/http/HttpBase.hx:54
        self.postBytes = None
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/http/HttpBase.hx:53
        self.postData = None
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/http/HttpBase.hx:52
        self.responseAsString = None
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/http/HttpBase.hx:50
        self.responseBytes = None
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/http/HttpBase.hx:72
        self.url = url
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/http/HttpBase.hx:73
        self.headers = []
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/http/HttpBase.hx:74
        self.params = []
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/http/HttpBase.hx:75
        self.emptyOnData = self.onData

    def onData(self,data):
        pass

    def onBytes(self,data):
        pass

    def onError(self,msg):
        pass

    def onStatus(self,status):
        pass

    def hasOnData(self):
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/http/HttpBase.hx:229
        return (not Reflect.compareMethods(self.onData,self.emptyOnData))

    def success(self,data):
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/http/HttpBase.hx:233
        self.responseBytes = data
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/http/HttpBase.hx:234
        self.responseAsString = None
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/http/HttpBase.hx:235
        if self.hasOnData():
            self.onData(self.get_responseData())
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/http/HttpBase.hx:238
        self.onBytes(self.responseBytes)

    def get_responseData(self):
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/http/HttpBase.hx:242
        if ((self.responseAsString is None) and ((self.responseBytes is not None))):
            self.responseAsString = self.responseBytes.getString(0,self.responseBytes.length,haxe_io_Encoding.UTF8)
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/http/HttpBase.hx:249
        return self.responseAsString

haxe_http_HttpBase._hx_class = haxe_http_HttpBase


class haxe_io_Bytes:
    _hx_class_name = "haxe.io.Bytes"
    _hx_is_interface = "False"
    __slots__ = ("length", "b")
    _hx_fields = ["length", "b"]
    _hx_methods = ["sub", "getString", "toString"]
    _hx_statics = ["alloc", "ofString", "ofData"]

    def __init__(self,length,b):
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/io/Bytes.hx:35
        self.length = length
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/io/Bytes.hx:36
        self.b = b

    def sub(self,pos,_hx_len):
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/io/Bytes.hx:157
        if (((pos < 0) or ((_hx_len < 0))) or (((pos + _hx_len) > self.length))):
            raise _HxException(haxe_io_Error.OutsideBounds)
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/io/Bytes.hx:176
        return haxe_io_Bytes(_hx_len,self.b[pos:(pos + _hx_len)])

    def getString(self,pos,_hx_len,encoding = None):
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/io/Bytes.hx:416
        tmp = (encoding is None)
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/io/Bytes.hx:419
        if (((pos < 0) or ((_hx_len < 0))) or (((pos + _hx_len) > self.length))):
            raise _HxException(haxe_io_Error.OutsideBounds)
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/io/Bytes.hx:450
        return self.b[pos:pos+_hx_len].decode('UTF-8','replace')

    def toString(self):
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/io/Bytes.hx:516
        return self.getString(0,self.length)

    @staticmethod
    def alloc(length):
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/io/Bytes.hx:566
        return haxe_io_Bytes(length,bytearray(length))

    @staticmethod
    def ofString(s,encoding = None):
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/io/Bytes.hx:615
        b = bytearray(s,"UTF-8")
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/io/Bytes.hx:616
        return haxe_io_Bytes(len(b),b)

    @staticmethod
    def ofData(b):
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/io/Bytes.hx:664
        return haxe_io_Bytes(len(b),b)

haxe_io_Bytes._hx_class = haxe_io_Bytes


class haxe_io_BytesBuffer:
    _hx_class_name = "haxe.io.BytesBuffer"
    _hx_is_interface = "False"
    __slots__ = ("b",)
    _hx_fields = ["b"]
    _hx_methods = ["getBytes"]

    def __init__(self):
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/io/BytesBuffer.hx:58
        self.b = bytearray()

    def getBytes(self):
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/io/BytesBuffer.hx:216
        _hx_bytes = haxe_io_Bytes(len(self.b),self.b)
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/io/BytesBuffer.hx:222
        self.b = None
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/io/BytesBuffer.hx:223
        return _hx_bytes

haxe_io_BytesBuffer._hx_class = haxe_io_BytesBuffer


class haxe_io_Output:
    _hx_class_name = "haxe.io.Output"
    _hx_is_interface = "False"
    __slots__ = ("bigEndian",)
    _hx_fields = ["bigEndian"]
    _hx_methods = ["writeByte", "writeBytes", "flush", "close", "set_bigEndian", "writeFullBytes", "prepare", "writeString"]

    def writeByte(self,c):
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/io/Output.hx:47
        raise _HxException("Not implemented")

    def writeBytes(self,s,pos,_hx_len):
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/io/Output.hx:59
        if (((pos < 0) or ((_hx_len < 0))) or (((pos + _hx_len) > s.length))):
            raise _HxException(haxe_io_Error.OutsideBounds)
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/io/Output.hx:62
        b = s.b
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/io/Output.hx:63
        k = _hx_len
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/io/Output.hx:64
        while (k > 0):
            # /Users/glen/tools-a8/packages/haxe/current/std/haxe/io/Output.hx:74
            self.writeByte(b[pos])
            # /Users/glen/tools-a8/packages/haxe/current/std/haxe/io/Output.hx:76
            pos = (pos + 1)
            # /Users/glen/tools-a8/packages/haxe/current/std/haxe/io/Output.hx:77
            k = (k - 1)
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/io/Output.hx:79
        return _hx_len

    def flush(self):
        pass

    def close(self):
        pass

    def set_bigEndian(self,b):
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/io/Output.hx:95
        self.bigEndian = b
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/io/Output.hx:96
        return b

    def writeFullBytes(self,s,pos,_hx_len):
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/io/Output.hx:121
        while (_hx_len > 0):
            # /Users/glen/tools-a8/packages/haxe/current/std/haxe/io/Output.hx:122
            k = self.writeBytes(s,pos,_hx_len)
            # /Users/glen/tools-a8/packages/haxe/current/std/haxe/io/Output.hx:123
            pos = (pos + k)
            # /Users/glen/tools-a8/packages/haxe/current/std/haxe/io/Output.hx:124
            _hx_len = (_hx_len - k)

    def prepare(self,nbytes):
        pass

    def writeString(self,s,encoding = None):
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/io/Output.hx:282
        b = haxe_io_Bytes.ofString(s,encoding)
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/io/Output.hx:284
        self.writeFullBytes(b,0,b.length)

haxe_io_Output._hx_class = haxe_io_Output


class haxe_io_BytesOutput(haxe_io_Output):
    _hx_class_name = "haxe.io.BytesOutput"
    _hx_is_interface = "False"
    __slots__ = ("b",)
    _hx_fields = ["b"]
    _hx_methods = ["writeByte", "writeBytes", "getBytes"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = haxe_io_Output


    def __init__(self):
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/io/BytesOutput.hx:40
        self.b = haxe_io_BytesBuffer()
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/io/BytesOutput.hx:43
        self.set_bigEndian(False)

    def writeByte(self,c):
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/io/BytesOutput.hx:55
        self.b.b.append(c)

    def writeBytes(self,buf,pos,_hx_len):
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/io/BytesOutput.hx:65
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/io/BytesOutput.hx:65
        if (((pos < 0) or ((_hx_len < 0))) or (((pos + _hx_len) > buf.length))):
            raise _HxException(haxe_io_Error.OutsideBounds)
        self.b.b.extend(buf.b[pos:(pos + _hx_len)])
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/io/BytesOutput.hx:67
        return _hx_len

    def getBytes(self):
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/io/BytesOutput.hx:143
        return self.b.getBytes()

haxe_io_BytesOutput._hx_class = haxe_io_BytesOutput

class haxe_io_Encoding(Enum):
    __slots__ = ()
    _hx_class_name = "haxe.io.Encoding"
    _hx_constructs = ["UTF8", "RawNative"]
haxe_io_Encoding.UTF8 = haxe_io_Encoding("UTF8", 0, ())
haxe_io_Encoding.RawNative = haxe_io_Encoding("RawNative", 1, ())
haxe_io_Encoding._hx_class = haxe_io_Encoding


class haxe_io_Eof:
    _hx_class_name = "haxe.io.Eof"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_methods = ["toString"]

    def __init__(self):
        pass

    def toString(self):
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/io/Eof.hx:33
        return "Eof"

haxe_io_Eof._hx_class = haxe_io_Eof

class haxe_io_Error(Enum):
    __slots__ = ()
    _hx_class_name = "haxe.io.Error"
    _hx_constructs = ["Blocked", "Overflow", "OutsideBounds", "Custom"]

    @staticmethod
    def Custom(e):
        return haxe_io_Error("Custom", 3, (e,))
haxe_io_Error.Blocked = haxe_io_Error("Blocked", 0, ())
haxe_io_Error.Overflow = haxe_io_Error("Overflow", 1, ())
haxe_io_Error.OutsideBounds = haxe_io_Error("OutsideBounds", 2, ())
haxe_io_Error._hx_class = haxe_io_Error


class haxe_io_Input:
    _hx_class_name = "haxe.io.Input"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_methods = ["readByte", "readBytes"]

    def readByte(self):
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/io/Input.hx:53
        raise _HxException("Not implemented")

    def readBytes(self,s,pos,_hx_len):
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/io/Input.hx:65
        k = _hx_len
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/io/Input.hx:66
        b = s.b
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/io/Input.hx:67
        if (((pos < 0) or ((_hx_len < 0))) or (((pos + _hx_len) > s.length))):
            raise _HxException(haxe_io_Error.OutsideBounds)
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/io/Input.hx:69
        try:
            while (k > 0):
                # /Users/glen/tools-a8/packages/haxe/current/std/haxe/io/Input.hx:78
                b[pos] = self.readByte()
                # /Users/glen/tools-a8/packages/haxe/current/std/haxe/io/Input.hx:80
                pos = (pos + 1)
                # /Users/glen/tools-a8/packages/haxe/current/std/haxe/io/Input.hx:81
                k = (k - 1)
        except Exception as _hx_e:
            _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
            if isinstance(_hx_e1, haxe_io_Eof):
                    pass
            else:
                raise _hx_e
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/io/Input.hx:84
        return (_hx_len - k)

haxe_io_Input._hx_class = haxe_io_Input


class python_Boot:
    _hx_class_name = "python.Boot"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["keywords", "toString1", "fields", "simpleField", "hasField", "field", "getInstanceFields", "getSuperClass", "getClassFields", "prefixLength", "unhandleKeywords"]

    @staticmethod
    def toString1(o,s):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:88
        if (o is None):
            return "null"
        # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:91
        if isinstance(o,str):
            return o
        # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:94
        if (s is None):
            s = ""
        # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:96
        if (len(s) >= 5):
            return "<...>"
        # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:99
        if isinstance(o,bool):
            if o:
                return "true"
            else:
                return "false"
        # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:105
        if (isinstance(o,int) and (not isinstance(o,bool))):
            return str(o)
        # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:109
        if isinstance(o,float):
            try:
                if (o == int(o)):
                    return str(Math.floor((o + 0.5)))
                else:
                    return str(o)
            except Exception as _hx_e:
                _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
                e = _hx_e1
                return str(o)
        # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:121
        if isinstance(o,list):
            # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:122
            o1 = o
            # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:124
            l = len(o1)
            # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:126
            st = "["
            # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:127
            s = (("null" if s is None else s) + "\t")
            # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:128
            # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:128
            _g = 0
            _g1 = l
            while (_g < _g1):
                i = _g
                _g = (_g + 1)
                # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:129
                prefix = ""
                # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:130
                if (i > 0):
                    prefix = ","
                # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:133
                st = (("null" if st is None else st) + HxOverrides.stringOrNull(((("null" if prefix is None else prefix) + HxOverrides.stringOrNull(python_Boot.toString1((o1[i] if i >= 0 and i < len(o1) else None),s))))))
            # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:135
            st = (("null" if st is None else st) + "]")
            # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:136
            return st
        # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:139
        try:
            if hasattr(o,"toString"):
                return o.toString()
        except Exception as _hx_e:
            _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
            pass
        # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:144
        if hasattr(o,"__class__"):
            # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:145
            if isinstance(o,_hx_AnonObject):
                # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:146
                toStr = None
                # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:147
                try:
                    # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:148
                    fields = python_Boot.fields(o)
                    # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:149
                    _g2 = []
                    _g11 = 0
                    while (_g11 < len(fields)):
                        f = (fields[_g11] if _g11 >= 0 and _g11 < len(fields) else None)
                        _g11 = (_g11 + 1)
                        x = ((("" + ("null" if f is None else f)) + " : ") + HxOverrides.stringOrNull(python_Boot.toString1(python_Boot.simpleField(o,f),(("null" if s is None else s) + "\t"))))
                        _g2.append(x)
                    fieldsStr = _g2
                    # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:150
                    toStr = (("{ " + HxOverrides.stringOrNull(", ".join([x1 for x1 in fieldsStr]))) + " }")
                except Exception as _hx_e:
                    _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
                    e2 = _hx_e1
                    return "{ ... }"
                # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:155
                if (toStr is None):
                    return "{ ... }"
                else:
                    return toStr
            # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:161
            if isinstance(o,Enum):
                # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:162
                o2 = o
                # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:164
                l1 = len(o2.params)
                # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:165
                hasParams = (l1 > 0)
                # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:166
                if hasParams:
                    # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:167
                    paramsStr = ""
                    # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:168
                    # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:168
                    _g3 = 0
                    _g12 = l1
                    while (_g3 < _g12):
                        i1 = _g3
                        _g3 = (_g3 + 1)
                        # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:169
                        prefix1 = ""
                        # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:170
                        if (i1 > 0):
                            prefix1 = ","
                        # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:173
                        paramsStr = (("null" if paramsStr is None else paramsStr) + HxOverrides.stringOrNull(((("null" if prefix1 is None else prefix1) + HxOverrides.stringOrNull(python_Boot.toString1(o2.params[i1],s))))))
                    # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:175
                    return (((HxOverrides.stringOrNull(o2.tag) + "(") + ("null" if paramsStr is None else paramsStr)) + ")")
                else:
                    return o2.tag
            # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:181
            if hasattr(o,"_hx_class_name"):
                if (o.__class__.__name__ != "type"):
                    # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:183
                    fields1 = python_Boot.getInstanceFields(o)
                    # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:184
                    _g4 = []
                    _g13 = 0
                    while (_g13 < len(fields1)):
                        f1 = (fields1[_g13] if _g13 >= 0 and _g13 < len(fields1) else None)
                        _g13 = (_g13 + 1)
                        x1 = ((("" + ("null" if f1 is None else f1)) + " : ") + HxOverrides.stringOrNull(python_Boot.toString1(python_Boot.simpleField(o,f1),(("null" if s is None else s) + "\t"))))
                        _g4.append(x1)
                    fieldsStr1 = _g4
                    # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:186
                    toStr1 = (((HxOverrides.stringOrNull(o._hx_class_name) + "( ") + HxOverrides.stringOrNull(", ".join([x1 for x1 in fieldsStr1]))) + " )")
                    # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:187
                    return toStr1
                else:
                    # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:189
                    fields2 = python_Boot.getClassFields(o)
                    # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:190
                    _g5 = []
                    _g14 = 0
                    while (_g14 < len(fields2)):
                        f2 = (fields2[_g14] if _g14 >= 0 and _g14 < len(fields2) else None)
                        _g14 = (_g14 + 1)
                        x2 = ((("" + ("null" if f2 is None else f2)) + " : ") + HxOverrides.stringOrNull(python_Boot.toString1(python_Boot.simpleField(o,f2),(("null" if s is None else s) + "\t"))))
                        _g5.append(x2)
                    fieldsStr2 = _g5
                    # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:191
                    toStr2 = (((("#" + HxOverrides.stringOrNull(o._hx_class_name)) + "( ") + HxOverrides.stringOrNull(", ".join([x1 for x1 in fieldsStr2]))) + " )")
                    # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:192
                    return toStr2
            # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:196
            if (o == str):
                return "#String"
            # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:200
            if (o == list):
                return "#Array"
            # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:204
            if callable(o):
                return "function"
            # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:207
            try:
                if hasattr(o,"__repr__"):
                    return o.__repr__()
            except Exception as _hx_e:
                _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
                pass
            # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:213
            if hasattr(o,"__str__"):
                return o.__str__([])
            # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:217
            if hasattr(o,"__name__"):
                return o.__name__
            # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:220
            return "???"
        else:
            return str(o)

    @staticmethod
    def fields(o):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:232
        a = []
        # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:233
        if (o is not None):
            # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:234
            if hasattr(o,"_hx_fields"):
                # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:235
                fields = o._hx_fields
                # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:236
                if (fields is not None):
                    return list(fields)
            # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:240
            if isinstance(o,_hx_AnonObject):
                # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:241
                d = o.__dict__
                # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:242
                keys = d.keys()
                # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:243
                handler = python_Boot.unhandleKeywords
                # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:245
                for k in keys:
                # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:246
                    if (k != '_hx_disable_getattr'):
                # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:247
                        a.append(handler(k))
            elif hasattr(o,"__dict__"):
                # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:250
                d1 = o.__dict__
                # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:251
                keys1 = d1.keys()
                # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:252
                for k in keys1:
                # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:253
                    a.append(k)
        # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:256
        return a

    @staticmethod
    def simpleField(o,field):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:268
        if (field is None):
            return None
        # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:271
        field1 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
        # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:272
        if hasattr(o,field1):
            return getattr(o,field1)
        else:
            return None

    @staticmethod
    def hasField(o,field):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:281
        if isinstance(o,_hx_AnonObject):
            return o._hx_hasattr(field)
        # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:284
        return hasattr(o,(("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field)))

    @staticmethod
    def field(o,field):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:288
        if (field is None):
            return None
        # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:296
        if isinstance(o,str):
            # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:297
            field1 = field
            _hx_local_0 = len(field1)
            # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:307
            if (_hx_local_0 == 10):
                if (field1 == "charCodeAt"):
                    return python_internal_MethodClosure(o,HxString.charCodeAt)
                else:
                    # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:321
                    field2 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    return (getattr(o,field2) if (hasattr(o,field2)) else None)
            elif (_hx_local_0 == 11):
                if (field1 == "lastIndexOf"):
                    return python_internal_MethodClosure(o,HxString.lastIndexOf)
                elif (field1 == "toLowerCase"):
                    return python_internal_MethodClosure(o,HxString.toLowerCase)
                elif (field1 == "toUpperCase"):
                    return python_internal_MethodClosure(o,HxString.toUpperCase)
                else:
                    field2 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    return (getattr(o,field2) if (hasattr(o,field2)) else None)
            elif (_hx_local_0 == 9):
                if (field1 == "substring"):
                    return python_internal_MethodClosure(o,HxString.substring)
                else:
                    field2 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    return (getattr(o,field2) if (hasattr(o,field2)) else None)
            elif (_hx_local_0 == 5):
                if (field1 == "split"):
                    return python_internal_MethodClosure(o,HxString.split)
                else:
                    field2 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    return (getattr(o,field2) if (hasattr(o,field2)) else None)
            elif (_hx_local_0 == 7):
                if (field1 == "indexOf"):
                    return python_internal_MethodClosure(o,HxString.indexOf)
                else:
                    field2 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    return (getattr(o,field2) if (hasattr(o,field2)) else None)
            elif (_hx_local_0 == 8):
                if (field1 == "toString"):
                    return python_internal_MethodClosure(o,HxString.toString)
                else:
                    field2 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    return (getattr(o,field2) if (hasattr(o,field2)) else None)
            elif (_hx_local_0 == 6):
                if (field1 == "charAt"):
                    return python_internal_MethodClosure(o,HxString.charAt)
                elif (field1 == "length"):
                    return len(o)
                elif (field1 == "substr"):
                    return python_internal_MethodClosure(o,HxString.substr)
                else:
                    field2 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    return (getattr(o,field2) if (hasattr(o,field2)) else None)
            else:
                field2 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                return (getattr(o,field2) if (hasattr(o,field2)) else None)
        elif isinstance(o,list):
            # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:324
            field3 = field
            _hx_local_1 = len(field3)
            # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:352
            if (_hx_local_1 == 11):
                if (field3 == "lastIndexOf"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.lastIndexOf)
                else:
                    # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:366
                    field4 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    return (getattr(o,field4) if (hasattr(o,field4)) else None)
            elif (_hx_local_1 == 4):
                if (field3 == "copy"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.copy)
                elif (field3 == "join"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.join)
                elif (field3 == "push"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.push)
                elif (field3 == "sort"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.sort)
                else:
                    field4 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    return (getattr(o,field4) if (hasattr(o,field4)) else None)
            elif (_hx_local_1 == 5):
                if (field3 == "shift"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.shift)
                elif (field3 == "slice"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.slice)
                else:
                    field4 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    return (getattr(o,field4) if (hasattr(o,field4)) else None)
            elif (_hx_local_1 == 7):
                if (field3 == "indexOf"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.indexOf)
                elif (field3 == "reverse"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.reverse)
                elif (field3 == "unshift"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.unshift)
                else:
                    field4 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    return (getattr(o,field4) if (hasattr(o,field4)) else None)
            elif (_hx_local_1 == 3):
                if (field3 == "map"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.map)
                elif (field3 == "pop"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.pop)
                else:
                    field4 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    return (getattr(o,field4) if (hasattr(o,field4)) else None)
            elif (_hx_local_1 == 8):
                if (field3 == "iterator"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.iterator)
                elif (field3 == "toString"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.toString)
                else:
                    field4 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    return (getattr(o,field4) if (hasattr(o,field4)) else None)
            elif (_hx_local_1 == 6):
                if (field3 == "concat"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.concat)
                elif (field3 == "filter"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.filter)
                elif (field3 == "insert"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.insert)
                elif (field3 == "length"):
                    return len(o)
                elif (field3 == "remove"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.remove)
                elif (field3 == "splice"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.splice)
                else:
                    field4 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    return (getattr(o,field4) if (hasattr(o,field4)) else None)
            else:
                field4 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                return (getattr(o,field4) if (hasattr(o,field4)) else None)
        else:
            # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:369
            field5 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
            return (getattr(o,field5) if (hasattr(o,field5)) else None)

    @staticmethod
    def getInstanceFields(c):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:374
        f = (list(c._hx_fields) if (hasattr(c,"_hx_fields")) else [])
        # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:375
        if hasattr(c,"_hx_methods"):
            f = (f + c._hx_methods)
        # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:378
        sc = python_Boot.getSuperClass(c)
        # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:380
        if (sc is None):
            return f
        else:
            # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:383
            scArr = python_Boot.getInstanceFields(sc)
            # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:384
            scMap = set(scArr)
            # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:385
            # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:385
            _g = 0
            while (_g < len(f)):
                f1 = (f[_g] if _g >= 0 and _g < len(f) else None)
                _g = (_g + 1)
                # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:386
                if (not (f1 in scMap)):
                    scArr.append(f1)
            # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:391
            return scArr

    @staticmethod
    def getSuperClass(c):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:396
        if (c is None):
            return None
        # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:399
        try:
            # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:400
            if hasattr(c,"_hx_super"):
                return c._hx_super
            # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:403
            return None
        except Exception as _hx_e:
            _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
            pass
        # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:405
        return None

    @staticmethod
    def getClassFields(c):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:409
        if hasattr(c,"_hx_statics"):
            # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:410
            x = c._hx_statics
            # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:411
            return list(x)
        else:
            return []

    @staticmethod
    def unhandleKeywords(name):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:436
        if (HxString.substr(name,0,python_Boot.prefixLength) == "_hx_"):
            # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:437
            real = HxString.substr(name,python_Boot.prefixLength,None)
            # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:438
            if (real in python_Boot.keywords):
                return real
        # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:441
        return name
python_Boot._hx_class = python_Boot


class python_internal_ArrayImpl:
    _hx_class_name = "python.internal.ArrayImpl"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["concat", "copy", "iterator", "indexOf", "lastIndexOf", "join", "toString", "pop", "push", "unshift", "remove", "shift", "slice", "sort", "splice", "map", "filter", "insert", "reverse", "_get", "_set"]

    @staticmethod
    def concat(a1,a2):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/internal/ArrayImpl.hx:35
        return (a1 + a2)

    @staticmethod
    def copy(x):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/internal/ArrayImpl.hx:40
        return list(x)

    @staticmethod
    def iterator(x):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/internal/ArrayImpl.hx:45
        return python_HaxeIterator(x.__iter__())

    @staticmethod
    def indexOf(a,x,fromIndex = None):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/internal/ArrayImpl.hx:50
        _hx_len = len(a)
        # /Users/glen/tools-a8/packages/haxe/current/std/python/internal/ArrayImpl.hx:51
        l = (0 if ((fromIndex is None)) else ((_hx_len + fromIndex) if ((fromIndex < 0)) else fromIndex))
        # /Users/glen/tools-a8/packages/haxe/current/std/python/internal/ArrayImpl.hx:52
        if (l < 0):
            l = 0
        # /Users/glen/tools-a8/packages/haxe/current/std/python/internal/ArrayImpl.hx:54
        # /Users/glen/tools-a8/packages/haxe/current/std/python/internal/ArrayImpl.hx:54
        _g = l
        _g1 = _hx_len
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            # /Users/glen/tools-a8/packages/haxe/current/std/python/internal/ArrayImpl.hx:55
            if HxOverrides.eq(a[i],x):
                return i
        # /Users/glen/tools-a8/packages/haxe/current/std/python/internal/ArrayImpl.hx:58
        return -1

    @staticmethod
    def lastIndexOf(a,x,fromIndex = None):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/internal/ArrayImpl.hx:63
        _hx_len = len(a)
        # /Users/glen/tools-a8/packages/haxe/current/std/python/internal/ArrayImpl.hx:64
        l = (_hx_len if ((fromIndex is None)) else (((_hx_len + fromIndex) + 1) if ((fromIndex < 0)) else (fromIndex + 1)))
        # /Users/glen/tools-a8/packages/haxe/current/std/python/internal/ArrayImpl.hx:65
        if (l > _hx_len):
            l = _hx_len
        # /Users/glen/tools-a8/packages/haxe/current/std/python/internal/ArrayImpl.hx:67
        while True:
            # /Users/glen/tools-a8/packages/haxe/current/std/python/internal/ArrayImpl.hx:67
            l = (l - 1)
            tmp = l
            if (not ((tmp > -1))):
                break
            # /Users/glen/tools-a8/packages/haxe/current/std/python/internal/ArrayImpl.hx:68
            if HxOverrides.eq(a[l],x):
                return l
        # /Users/glen/tools-a8/packages/haxe/current/std/python/internal/ArrayImpl.hx:71
        return -1

    @staticmethod
    def join(x,sep):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/internal/ArrayImpl.hx:77
        return sep.join([python_Boot.toString1(x1,'') for x1 in x])

    @staticmethod
    def toString(x):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/internal/ArrayImpl.hx:82
        return (("[" + HxOverrides.stringOrNull(",".join([python_Boot.toString1(x1,'') for x1 in x]))) + "]")

    @staticmethod
    def pop(x):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/internal/ArrayImpl.hx:87
        if (len(x) == 0):
            return None
        else:
            return x.pop()

    @staticmethod
    def push(x,e):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/internal/ArrayImpl.hx:92
        x.append(e)
        # /Users/glen/tools-a8/packages/haxe/current/std/python/internal/ArrayImpl.hx:93
        return len(x)

    @staticmethod
    def unshift(x,e):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/internal/ArrayImpl.hx:98
        x.insert(0, e)

    @staticmethod
    def remove(x,e):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/internal/ArrayImpl.hx:103
        try:
            # /Users/glen/tools-a8/packages/haxe/current/std/python/internal/ArrayImpl.hx:104
            x.remove(e)
            # /Users/glen/tools-a8/packages/haxe/current/std/python/internal/ArrayImpl.hx:105
            return True
        except Exception as _hx_e:
            _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
            e1 = _hx_e1
            return False

    @staticmethod
    def shift(x):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/internal/ArrayImpl.hx:113
        if (len(x) == 0):
            return None
        # /Users/glen/tools-a8/packages/haxe/current/std/python/internal/ArrayImpl.hx:115
        return x.pop(0)

    @staticmethod
    def slice(x,pos,end = None):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/internal/ArrayImpl.hx:120
        return x[pos:end]

    @staticmethod
    def sort(x,f):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/internal/ArrayImpl.hx:125
        x.sort(key= python_lib_Functools.cmp_to_key(f))

    @staticmethod
    def splice(x,pos,_hx_len):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/internal/ArrayImpl.hx:130
        if (pos < 0):
            pos = (len(x) + pos)
        # /Users/glen/tools-a8/packages/haxe/current/std/python/internal/ArrayImpl.hx:132
        if (pos < 0):
            pos = 0
        # /Users/glen/tools-a8/packages/haxe/current/std/python/internal/ArrayImpl.hx:134
        res = x[pos:(pos + _hx_len)]
        # /Users/glen/tools-a8/packages/haxe/current/std/python/internal/ArrayImpl.hx:135
        del x[pos:(pos + _hx_len)]
        # /Users/glen/tools-a8/packages/haxe/current/std/python/internal/ArrayImpl.hx:136
        return res

    @staticmethod
    def map(x,f):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/internal/ArrayImpl.hx:141
        return list(map(f,x))

    @staticmethod
    def filter(x,f):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/internal/ArrayImpl.hx:146
        return list(filter(f,x))

    @staticmethod
    def insert(a,pos,x):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/internal/ArrayImpl.hx:151
        a.insert(pos, x)

    @staticmethod
    def reverse(a):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/internal/ArrayImpl.hx:156
        a.reverse()

    @staticmethod
    def _get(x,idx):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/internal/ArrayImpl.hx:161
        if ((idx > -1) and ((idx < len(x)))):
            return x[idx]
        else:
            return None

    @staticmethod
    def _set(x,idx,v):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/internal/ArrayImpl.hx:166
        l = len(x)
        # /Users/glen/tools-a8/packages/haxe/current/std/python/internal/ArrayImpl.hx:167
        while (l < idx):
            # /Users/glen/tools-a8/packages/haxe/current/std/python/internal/ArrayImpl.hx:168
            x.append(None)
            # /Users/glen/tools-a8/packages/haxe/current/std/python/internal/ArrayImpl.hx:169
            l = (l + 1)
        # /Users/glen/tools-a8/packages/haxe/current/std/python/internal/ArrayImpl.hx:171
        if (l == idx):
            x.append(v)
        else:
            x[idx] = v
        # /Users/glen/tools-a8/packages/haxe/current/std/python/internal/ArrayImpl.hx:176
        return v
python_internal_ArrayImpl._hx_class = python_internal_ArrayImpl


class _HxException(Exception):
    _hx_class_name = "_HxException"
    _hx_is_interface = "False"
    __slots__ = ("val",)
    _hx_fields = ["val"]
    _hx_methods = []
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = Exception


    def __init__(self,val):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/internal/HxException.hx:29
        self.val = None
        # /Users/glen/tools-a8/packages/haxe/current/std/python/internal/HxException.hx:33
        message = str(val)
        # /Users/glen/tools-a8/packages/haxe/current/std/python/internal/HxException.hx:34
        super().__init__(message)
        # /Users/glen/tools-a8/packages/haxe/current/std/python/internal/HxException.hx:35
        self.val = val

_HxException._hx_class = _HxException


class HxOverrides:
    _hx_class_name = "HxOverrides"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["iterator", "eq", "stringOrNull", "mapKwArgs"]

    @staticmethod
    def iterator(x):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/internal/HxOverrides.hx:37
        if isinstance(x,list):
            return python_HaxeIterator(x.__iter__())
        # /Users/glen/tools-a8/packages/haxe/current/std/python/internal/HxOverrides.hx:40
        return x.iterator()

    @staticmethod
    def eq(a,b):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/internal/HxOverrides.hx:45
        if (isinstance(a,list) or isinstance(b,list)):
            return a is b
        # /Users/glen/tools-a8/packages/haxe/current/std/python/internal/HxOverrides.hx:48
        return (a == b)

    @staticmethod
    def stringOrNull(s):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/internal/HxOverrides.hx:53
        if (s is None):
            return "null"
        else:
            return s

    @staticmethod
    def mapKwArgs(a,v):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/internal/HxOverrides.hx:196
        a1 = _hx_AnonObject(python_Lib.anonToDict(a))
        # /Users/glen/tools-a8/packages/haxe/current/std/python/internal/HxOverrides.hx:197
        # /Users/glen/tools-a8/packages/haxe/current/std/python/internal/HxOverrides.hx:197
        k = python_HaxeIterator(iter(v.keys()))
        while k.hasNext():
            k1 = k.next()
            # /Users/glen/tools-a8/packages/haxe/current/std/python/internal/HxOverrides.hx:198
            val = v.get(k1)
            # /Users/glen/tools-a8/packages/haxe/current/std/python/internal/HxOverrides.hx:199
            if a1._hx_hasattr(k1):
                # /Users/glen/tools-a8/packages/haxe/current/std/python/internal/HxOverrides.hx:200
                x = getattr(a1,k1)
                # /Users/glen/tools-a8/packages/haxe/current/std/python/internal/HxOverrides.hx:201
                setattr(a1,val,x)
                # /Users/glen/tools-a8/packages/haxe/current/std/python/internal/HxOverrides.hx:202
                delattr(a1,k1)
        # /Users/glen/tools-a8/packages/haxe/current/std/python/internal/HxOverrides.hx:205
        return a1
HxOverrides._hx_class = HxOverrides


class python_internal_MethodClosure:
    _hx_class_name = "python.internal.MethodClosure"
    _hx_is_interface = "False"
    __slots__ = ("obj", "func")
    _hx_fields = ["obj", "func"]
    _hx_methods = ["__call__"]

    def __init__(self,obj,func):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/internal/MethodClosure.hx:30
        self.obj = obj
        # /Users/glen/tools-a8/packages/haxe/current/std/python/internal/MethodClosure.hx:31
        self.func = func

    def __call__(self,*args):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/internal/MethodClosure.hx:35
        return self.func(self.obj,*args)

python_internal_MethodClosure._hx_class = python_internal_MethodClosure


class sys_net_Socket:
    _hx_class_name = "sys.net.Socket"
    _hx_is_interface = "False"
    __slots__ = ("_hx___s", "input", "output")
    _hx_fields = ["__s", "input", "output"]
    _hx_methods = ["__initSocket", "close", "connect", "shutdown", "setTimeout", "fileno"]

    def __init__(self):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/sys/net/Socket.hx:115
        self.output = None
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/sys/net/Socket.hx:113
        self.input = None
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/sys/net/Socket.hx:111
        self._hx___s = None
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/sys/net/Socket.hx:120
        self._hx___initSocket()
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/sys/net/Socket.hx:121
        self.input = sys_net__Socket_SocketInput(self._hx___s)
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/sys/net/Socket.hx:122
        self.output = sys_net__Socket_SocketOutput(self._hx___s)

    def _hx___initSocket(self):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/sys/net/Socket.hx:126
        self._hx___s = python_lib_socket_Socket()

    def close(self):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/sys/net/Socket.hx:130
        self._hx___s.close()

    def connect(self,host,port):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/sys/net/Socket.hx:142
        host_str = host.toString()
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/sys/net/Socket.hx:143
        self._hx___s.connect((host_str, port))

    def shutdown(self,read,write):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/sys/net/Socket.hx:151
        self._hx___s.shutdown((python_lib_Socket.SHUT_RDWR if ((read and write)) else (python_lib_Socket.SHUT_RD if read else python_lib_Socket.SHUT_WR)))

    def setTimeout(self,timeout):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/sys/net/Socket.hx:178
        self._hx___s.settimeout(timeout)

    def fileno(self):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/sys/net/Socket.hx:194
        return self._hx___s.fileno()

sys_net_Socket._hx_class = sys_net_Socket


class python_net_SslSocket(sys_net_Socket):
    _hx_class_name = "python.net.SslSocket"
    _hx_is_interface = "False"
    __slots__ = ("hostName",)
    _hx_fields = ["hostName"]
    _hx_methods = ["__initSocket", "connect"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = sys_net_Socket


    def __init__(self):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/net/SslSocket.hx:31
        self.hostName = None
        # /Users/glen/tools-a8/packages/haxe/current/std/python/net/SslSocket.hx:30
        super().__init__()

    def _hx___initSocket(self):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/net/SslSocket.hx:38
        context = python_lib_ssl_SSLContext(python_lib_Ssl.PROTOCOL_SSLv23)
        # /Users/glen/tools-a8/packages/haxe/current/std/python/net/SslSocket.hx:39
        context.verify_mode = python_lib_Ssl.CERT_REQUIRED
        # /Users/glen/tools-a8/packages/haxe/current/std/python/net/SslSocket.hx:40
        context.set_default_verify_paths()
        # /Users/glen/tools-a8/packages/haxe/current/std/python/net/SslSocket.hx:41
        context.options = (context.options | python_lib_Ssl.OP_NO_SSLv2)
        # /Users/glen/tools-a8/packages/haxe/current/std/python/net/SslSocket.hx:42
        context.options = (context.options | python_lib_Ssl.OP_NO_SSLv3)
        # /Users/glen/tools-a8/packages/haxe/current/std/python/net/SslSocket.hx:43
        context.options = (context.options | python_lib_Ssl.OP_NO_COMPRESSION)
        # /Users/glen/tools-a8/packages/haxe/current/std/python/net/SslSocket.hx:45
        context.options = (context.options | python_lib_Ssl.OP_NO_TLSv1)
        # /Users/glen/tools-a8/packages/haxe/current/std/python/net/SslSocket.hx:46
        self._hx___s = python_lib_socket_Socket()
        # /Users/glen/tools-a8/packages/haxe/current/std/python/net/SslSocket.hx:47
        self._hx___s = context.wrap_socket(self._hx___s,False,True,True,self.hostName)

    def connect(self,host,port):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/net/SslSocket.hx:51
        self.hostName = host.host
        # /Users/glen/tools-a8/packages/haxe/current/std/python/net/SslSocket.hx:52
        super().connect(host,port)

python_net_SslSocket._hx_class = python_net_SslSocket


class sys_Http(haxe_http_HttpBase):
    _hx_class_name = "sys.Http"
    _hx_is_interface = "False"
    __slots__ = ("noShutdown", "cnxTimeout", "responseHeaders", "chunk_size", "chunk_buf", "file")
    _hx_fields = ["noShutdown", "cnxTimeout", "responseHeaders", "chunk_size", "chunk_buf", "file"]
    _hx_methods = ["request", "customRequest", "writeBody", "readHttpResponse", "readChunk"]
    _hx_statics = ["PROXY", "requestUrl"]
    _hx_interfaces = []
    _hx_super = haxe_http_HttpBase


    def __init__(self,url):
        # /Users/glen/tools-a8/packages/haxe/current/std/sys/Http.hx:38
        self.file = None
        # /Users/glen/tools-a8/packages/haxe/current/std/sys/Http.hx:37
        self.chunk_buf = None
        # /Users/glen/tools-a8/packages/haxe/current/std/sys/Http.hx:36
        self.chunk_size = None
        # /Users/glen/tools-a8/packages/haxe/current/std/sys/Http.hx:34
        self.responseHeaders = None
        # /Users/glen/tools-a8/packages/haxe/current/std/sys/Http.hx:32
        self.noShutdown = None
        # /Users/glen/tools-a8/packages/haxe/current/std/sys/Http.hx:49
        self.cnxTimeout = 10
        # /Users/glen/tools-a8/packages/haxe/current/std/sys/Http.hx:53
        super().__init__(url)

    def request(self,post = None):
        # /Users/glen/tools-a8/packages/haxe/current/std/sys/Http.hx:56
        _gthis = self
        # /Users/glen/tools-a8/packages/haxe/current/std/sys/Http.hx:57
        output = haxe_io_BytesOutput()
        # /Users/glen/tools-a8/packages/haxe/current/std/sys/Http.hx:58
        old = self.onError
        # /Users/glen/tools-a8/packages/haxe/current/std/sys/Http.hx:59
        err = False
        # /Users/glen/tools-a8/packages/haxe/current/std/sys/Http.hx:60
        def _hx_local_0(e):
            # /Users/glen/tools-a8/packages/haxe/current/std/sys/Http.hx:60
            nonlocal err
            # /Users/glen/tools-a8/packages/haxe/current/std/sys/Http.hx:61
            _gthis.responseBytes = output.getBytes()
            # /Users/glen/tools-a8/packages/haxe/current/std/sys/Http.hx:62
            err = True
            # /Users/glen/tools-a8/packages/haxe/current/std/sys/Http.hx:64
            _gthis.onError = old
            # /Users/glen/tools-a8/packages/haxe/current/std/sys/Http.hx:65
            _gthis.onError(e)
        self.onError = _hx_local_0
        # /Users/glen/tools-a8/packages/haxe/current/std/sys/Http.hx:67
        post = ((post or ((self.postBytes is not None))) or ((self.postData is not None)))
        # /Users/glen/tools-a8/packages/haxe/current/std/sys/Http.hx:68
        self.customRequest(post,output)
        # /Users/glen/tools-a8/packages/haxe/current/std/sys/Http.hx:69
        if (not err):
            self.success(output.getBytes())

    def customRequest(self,post,api,sock = None,method = None):
        # /Users/glen/tools-a8/packages/haxe/current/std/sys/Http.hx:91
        self.responseAsString = None
        # /Users/glen/tools-a8/packages/haxe/current/std/sys/Http.hx:92
        self.responseBytes = None
        # /Users/glen/tools-a8/packages/haxe/current/std/sys/Http.hx:93
        url_regexp = EReg("^(https?://)?([a-zA-Z\\.0-9_-]+)(:[0-9]+)?(.*)$","")
        # /Users/glen/tools-a8/packages/haxe/current/std/sys/Http.hx:94
        url_regexp.matchObj = python_lib_Re.search(url_regexp.pattern,self.url)
        if (url_regexp.matchObj is None):
            # /Users/glen/tools-a8/packages/haxe/current/std/sys/Http.hx:95
            self.onError("Invalid URL")
            # /Users/glen/tools-a8/packages/haxe/current/std/sys/Http.hx:96
            return
        # /Users/glen/tools-a8/packages/haxe/current/std/sys/Http.hx:98
        secure = (url_regexp.matchObj.group(1) == "https://")
        # /Users/glen/tools-a8/packages/haxe/current/std/sys/Http.hx:99
        if (sock is None):
            # /Users/glen/tools-a8/packages/haxe/current/std/sys/Http.hx:100
            if secure:
                sock = python_net_SslSocket()
            else:
                sock = sys_net_Socket()
            # /Users/glen/tools-a8/packages/haxe/current/std/sys/Http.hx:117
            sock.setTimeout(self.cnxTimeout)
        # /Users/glen/tools-a8/packages/haxe/current/std/sys/Http.hx:119
        host = url_regexp.matchObj.group(2)
        # /Users/glen/tools-a8/packages/haxe/current/std/sys/Http.hx:120
        portString = url_regexp.matchObj.group(3)
        # /Users/glen/tools-a8/packages/haxe/current/std/sys/Http.hx:121
        request = url_regexp.matchObj.group(4)
        # /Users/glen/tools-a8/packages/haxe/current/std/sys/Http.hx:125
        if ((("" if ((0 >= len(request))) else request[0])) != "/"):
            request = ("/" + ("null" if request is None else request))
        # /Users/glen/tools-a8/packages/haxe/current/std/sys/Http.hx:128
        port = ((443 if secure else 80) if (((portString is None) or ((portString == "")))) else Std.parseInt(HxString.substr(portString,1,(len(portString) - 1))))
        # /Users/glen/tools-a8/packages/haxe/current/std/sys/Http.hx:130
        multipart = (self.file is not None)
        # /Users/glen/tools-a8/packages/haxe/current/std/sys/Http.hx:131
        boundary = None
        # /Users/glen/tools-a8/packages/haxe/current/std/sys/Http.hx:132
        uri = None
        # /Users/glen/tools-a8/packages/haxe/current/std/sys/Http.hx:133
        if multipart:
            # /Users/glen/tools-a8/packages/haxe/current/std/sys/Http.hx:134
            post = True
            # /Users/glen/tools-a8/packages/haxe/current/std/sys/Http.hx:135
            boundary = (((Std.string(int((python_lib_Random.random() * 1000))) + Std.string(int((python_lib_Random.random() * 1000)))) + Std.string(int((python_lib_Random.random() * 1000)))) + Std.string(int((python_lib_Random.random() * 1000))))
            # /Users/glen/tools-a8/packages/haxe/current/std/sys/Http.hx:139
            while (len(boundary) < 38):
                boundary = ("-" + ("null" if boundary is None else boundary))
            # /Users/glen/tools-a8/packages/haxe/current/std/sys/Http.hx:141
            b_b = python_lib_io_StringIO()
            # /Users/glen/tools-a8/packages/haxe/current/std/sys/Http.hx:142
            # /Users/glen/tools-a8/packages/haxe/current/std/sys/Http.hx:142
            _g = 0
            _g1 = self.params
            while (_g < len(_g1)):
                p = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
                _g = (_g + 1)
                # /Users/glen/tools-a8/packages/haxe/current/std/sys/Http.hx:143
                b_b.write("--")
                # /Users/glen/tools-a8/packages/haxe/current/std/sys/Http.hx:144
                b_b.write(Std.string(boundary))
                # /Users/glen/tools-a8/packages/haxe/current/std/sys/Http.hx:145
                b_b.write("\r\n")
                # /Users/glen/tools-a8/packages/haxe/current/std/sys/Http.hx:146
                b_b.write("Content-Disposition: form-data; name=\"")
                # /Users/glen/tools-a8/packages/haxe/current/std/sys/Http.hx:147
                b_b.write(Std.string(p.name))
                # /Users/glen/tools-a8/packages/haxe/current/std/sys/Http.hx:148
                b_b.write("\"")
                # /Users/glen/tools-a8/packages/haxe/current/std/sys/Http.hx:149
                b_b.write("\r\n")
                # /Users/glen/tools-a8/packages/haxe/current/std/sys/Http.hx:150
                b_b.write("\r\n")
                # /Users/glen/tools-a8/packages/haxe/current/std/sys/Http.hx:151
                b_b.write(Std.string(p.value))
                # /Users/glen/tools-a8/packages/haxe/current/std/sys/Http.hx:152
                b_b.write("\r\n")
            # /Users/glen/tools-a8/packages/haxe/current/std/sys/Http.hx:154
            b_b.write("--")
            # /Users/glen/tools-a8/packages/haxe/current/std/sys/Http.hx:155
            b_b.write(Std.string(boundary))
            # /Users/glen/tools-a8/packages/haxe/current/std/sys/Http.hx:156
            b_b.write("\r\n")
            # /Users/glen/tools-a8/packages/haxe/current/std/sys/Http.hx:157
            b_b.write("Content-Disposition: form-data; name=\"")
            # /Users/glen/tools-a8/packages/haxe/current/std/sys/Http.hx:158
            b_b.write(Std.string(self.file.param))
            # /Users/glen/tools-a8/packages/haxe/current/std/sys/Http.hx:159
            b_b.write("\"; filename=\"")
            # /Users/glen/tools-a8/packages/haxe/current/std/sys/Http.hx:160
            b_b.write(Std.string(self.file.filename))
            # /Users/glen/tools-a8/packages/haxe/current/std/sys/Http.hx:161
            b_b.write("\"")
            # /Users/glen/tools-a8/packages/haxe/current/std/sys/Http.hx:162
            b_b.write("\r\n")
            # /Users/glen/tools-a8/packages/haxe/current/std/sys/Http.hx:163
            b_b.write(Std.string(((("Content-Type: " + HxOverrides.stringOrNull(self.file.mimeType)) + "\r\n") + "\r\n")))
            # /Users/glen/tools-a8/packages/haxe/current/std/sys/Http.hx:164
            uri = b_b.getvalue()
        else:
            # /Users/glen/tools-a8/packages/haxe/current/std/sys/Http.hx:166
            _g2 = 0
            _g11 = self.params
            while (_g2 < len(_g11)):
                p1 = (_g11[_g2] if _g2 >= 0 and _g2 < len(_g11) else None)
                _g2 = (_g2 + 1)
                # /Users/glen/tools-a8/packages/haxe/current/std/sys/Http.hx:167
                if (uri is None):
                    uri = ""
                else:
                    uri = (("null" if uri is None else uri) + "&")
                # /Users/glen/tools-a8/packages/haxe/current/std/sys/Http.hx:171
                uri = (("null" if uri is None else uri) + HxOverrides.stringOrNull((((HxOverrides.stringOrNull(python_lib_urllib_Parse.quote(p1.name,"")) + "=") + HxOverrides.stringOrNull(python_lib_urllib_Parse.quote(("" + HxOverrides.stringOrNull(p1.value)),""))))))
        # /Users/glen/tools-a8/packages/haxe/current/std/sys/Http.hx:175
        b = haxe_io_BytesOutput()
        # /Users/glen/tools-a8/packages/haxe/current/std/sys/Http.hx:176
        if (method is not None):
            # /Users/glen/tools-a8/packages/haxe/current/std/sys/Http.hx:177
            b.writeString(method)
            # /Users/glen/tools-a8/packages/haxe/current/std/sys/Http.hx:178
            b.writeString(" ")
        elif post:
            b.writeString("POST ")
        else:
            b.writeString("GET ")
        # /Users/glen/tools-a8/packages/haxe/current/std/sys/Http.hx:184
        if (sys_Http.PROXY is not None):
            # /Users/glen/tools-a8/packages/haxe/current/std/sys/Http.hx:185
            b.writeString("http://")
            # /Users/glen/tools-a8/packages/haxe/current/std/sys/Http.hx:186
            b.writeString(host)
            # /Users/glen/tools-a8/packages/haxe/current/std/sys/Http.hx:187
            if (port != 80):
                # /Users/glen/tools-a8/packages/haxe/current/std/sys/Http.hx:188
                b.writeString(":")
                # /Users/glen/tools-a8/packages/haxe/current/std/sys/Http.hx:189
                b.writeString(("" + Std.string(port)))
        # /Users/glen/tools-a8/packages/haxe/current/std/sys/Http.hx:192
        b.writeString(request)
        # /Users/glen/tools-a8/packages/haxe/current/std/sys/Http.hx:194
        if ((not post) and ((uri is not None))):
            # /Users/glen/tools-a8/packages/haxe/current/std/sys/Http.hx:195
            if (request.find("?", 0) >= 0):
                b.writeString("&")
            else:
                b.writeString("?")
            # /Users/glen/tools-a8/packages/haxe/current/std/sys/Http.hx:199
            b.writeString(uri)
        # /Users/glen/tools-a8/packages/haxe/current/std/sys/Http.hx:201
        b.writeString(((" HTTP/1.1\r\nHost: " + ("null" if host is None else host)) + "\r\n"))
        # /Users/glen/tools-a8/packages/haxe/current/std/sys/Http.hx:202
        if (self.postData is not None):
            # /Users/glen/tools-a8/packages/haxe/current/std/sys/Http.hx:203
            self.postBytes = haxe_io_Bytes.ofString(self.postData)
            # /Users/glen/tools-a8/packages/haxe/current/std/sys/Http.hx:204
            self.postData = None
        # /Users/glen/tools-a8/packages/haxe/current/std/sys/Http.hx:206
        if (self.postBytes is not None):
            b.writeString((("Content-Length: " + Std.string(self.postBytes.length)) + "\r\n"))
        elif (post and ((uri is not None))):
            # /Users/glen/tools-a8/packages/haxe/current/std/sys/Http.hx:209
            def _hx_local_4(h):
                # /Users/glen/tools-a8/packages/haxe/current/std/sys/Http.hx:209
                return (h.name == "Content-Type")
            if (multipart or (not Lambda.exists(self.headers,_hx_local_4))):
                # /Users/glen/tools-a8/packages/haxe/current/std/sys/Http.hx:210
                b.writeString("Content-Type: ")
                # /Users/glen/tools-a8/packages/haxe/current/std/sys/Http.hx:211
                if multipart:
                    # /Users/glen/tools-a8/packages/haxe/current/std/sys/Http.hx:212
                    b.writeString("multipart/form-data")
                    # /Users/glen/tools-a8/packages/haxe/current/std/sys/Http.hx:213
                    b.writeString("; boundary=")
                    # /Users/glen/tools-a8/packages/haxe/current/std/sys/Http.hx:214
                    b.writeString(boundary)
                else:
                    b.writeString("application/x-www-form-urlencoded")
                # /Users/glen/tools-a8/packages/haxe/current/std/sys/Http.hx:217
                b.writeString("\r\n")
            # /Users/glen/tools-a8/packages/haxe/current/std/sys/Http.hx:219
            if multipart:
                b.writeString((("Content-Length: " + Std.string(((((len(uri) + self.file.size) + len(boundary)) + 6)))) + "\r\n"))
            else:
                b.writeString((("Content-Length: " + Std.string(len(uri))) + "\r\n"))
        # /Users/glen/tools-a8/packages/haxe/current/std/sys/Http.hx:224
        b.writeString("Connection: close\r\n")
        # /Users/glen/tools-a8/packages/haxe/current/std/sys/Http.hx:225
        # /Users/glen/tools-a8/packages/haxe/current/std/sys/Http.hx:225
        _g3 = 0
        _g12 = self.headers
        while (_g3 < len(_g12)):
            h1 = (_g12[_g3] if _g3 >= 0 and _g3 < len(_g12) else None)
            _g3 = (_g3 + 1)
            # /Users/glen/tools-a8/packages/haxe/current/std/sys/Http.hx:226
            b.writeString(h1.name)
            # /Users/glen/tools-a8/packages/haxe/current/std/sys/Http.hx:227
            b.writeString(": ")
            # /Users/glen/tools-a8/packages/haxe/current/std/sys/Http.hx:228
            b.writeString(h1.value)
            # /Users/glen/tools-a8/packages/haxe/current/std/sys/Http.hx:229
            b.writeString("\r\n")
        # /Users/glen/tools-a8/packages/haxe/current/std/sys/Http.hx:231
        b.writeString("\r\n")
        # /Users/glen/tools-a8/packages/haxe/current/std/sys/Http.hx:232
        if (self.postBytes is not None):
            b.writeFullBytes(self.postBytes,0,self.postBytes.length)
        elif (post and ((uri is not None))):
            b.writeString(uri)
        # /Users/glen/tools-a8/packages/haxe/current/std/sys/Http.hx:236
        try:
            # /Users/glen/tools-a8/packages/haxe/current/std/sys/Http.hx:237
            if (sys_Http.PROXY is not None):
                sock.connect(sys_net_Host(sys_Http.PROXY.host),sys_Http.PROXY.port)
            else:
                sock.connect(sys_net_Host(host),port)
            # /Users/glen/tools-a8/packages/haxe/current/std/sys/Http.hx:241
            if multipart:
                self.writeBody(b,self.file.io,self.file.size,boundary,sock)
            else:
                self.writeBody(b,None,0,None,sock)
            # /Users/glen/tools-a8/packages/haxe/current/std/sys/Http.hx:245
            self.readHttpResponse(api,sock)
            # /Users/glen/tools-a8/packages/haxe/current/std/sys/Http.hx:246
            sock.close()
        except Exception as _hx_e:
            _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
            e = _hx_e1
            # /Users/glen/tools-a8/packages/haxe/current/std/sys/Http.hx:248
            try:
                sock.close()
            except Exception as _hx_e:
                _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
                pass
            # /Users/glen/tools-a8/packages/haxe/current/std/sys/Http.hx:251
            self.onError(Std.string(e))

    def writeBody(self,body,fileInput,fileSize,boundary,sock):
        # /Users/glen/tools-a8/packages/haxe/current/std/sys/Http.hx:256
        if (body is not None):
            # /Users/glen/tools-a8/packages/haxe/current/std/sys/Http.hx:257
            _hx_bytes = body.getBytes()
            # /Users/glen/tools-a8/packages/haxe/current/std/sys/Http.hx:258
            sock.output.writeFullBytes(_hx_bytes,0,_hx_bytes.length)
        # /Users/glen/tools-a8/packages/haxe/current/std/sys/Http.hx:260
        if (boundary is not None):
            # /Users/glen/tools-a8/packages/haxe/current/std/sys/Http.hx:261
            bufsize = 4096
            # /Users/glen/tools-a8/packages/haxe/current/std/sys/Http.hx:262
            buf = haxe_io_Bytes.alloc(bufsize)
            # /Users/glen/tools-a8/packages/haxe/current/std/sys/Http.hx:263
            while (fileSize > 0):
                # /Users/glen/tools-a8/packages/haxe/current/std/sys/Http.hx:264
                size = (bufsize if ((fileSize > bufsize)) else fileSize)
                # /Users/glen/tools-a8/packages/haxe/current/std/sys/Http.hx:265
                _hx_len = 0
                # /Users/glen/tools-a8/packages/haxe/current/std/sys/Http.hx:266
                try:
                    _hx_len = fileInput.readBytes(buf,0,size)
                except Exception as _hx_e:
                    _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
                    if isinstance(_hx_e1, haxe_io_Eof):
                        e = _hx_e1
                        break
                    else:
                        raise _hx_e
                # /Users/glen/tools-a8/packages/haxe/current/std/sys/Http.hx:270
                sock.output.writeFullBytes(buf,0,_hx_len)
                # /Users/glen/tools-a8/packages/haxe/current/std/sys/Http.hx:271
                fileSize = (fileSize - _hx_len)
            # /Users/glen/tools-a8/packages/haxe/current/std/sys/Http.hx:273
            sock.output.writeString("\r\n")
            # /Users/glen/tools-a8/packages/haxe/current/std/sys/Http.hx:274
            sock.output.writeString("--")
            # /Users/glen/tools-a8/packages/haxe/current/std/sys/Http.hx:275
            sock.output.writeString(boundary)
            # /Users/glen/tools-a8/packages/haxe/current/std/sys/Http.hx:276
            sock.output.writeString("--")

    def readHttpResponse(self,api,sock):
        # /Users/glen/tools-a8/packages/haxe/current/std/sys/Http.hx:282
        b = haxe_io_BytesBuffer()
        # /Users/glen/tools-a8/packages/haxe/current/std/sys/Http.hx:283
        k = 4
        # /Users/glen/tools-a8/packages/haxe/current/std/sys/Http.hx:284
        s = haxe_io_Bytes.alloc(4)
        # /Users/glen/tools-a8/packages/haxe/current/std/sys/Http.hx:285
        sock.setTimeout(self.cnxTimeout)
        # /Users/glen/tools-a8/packages/haxe/current/std/sys/Http.hx:286
        while True:
            # /Users/glen/tools-a8/packages/haxe/current/std/sys/Http.hx:287
            p = sock.input.readBytes(s,0,k)
            # /Users/glen/tools-a8/packages/haxe/current/std/sys/Http.hx:288
            while (p != k):
                p = (p + sock.input.readBytes(s,p,(k - p)))
            # /Users/glen/tools-a8/packages/haxe/current/std/sys/Http.hx:290
            # /Users/glen/tools-a8/packages/haxe/current/std/sys/Http.hx:290
            if ((k < 0) or ((k > s.length))):
                raise _HxException(haxe_io_Error.OutsideBounds)
            b.b.extend(s.b[0:k])
            # /Users/glen/tools-a8/packages/haxe/current/std/sys/Http.hx:291
            k1 = k
            # /Users/glen/tools-a8/packages/haxe/current/std/sys/Http.hx:292
            if (k1 == 1):
                # /Users/glen/tools-a8/packages/haxe/current/std/sys/Http.hx:293
                c = s.b[0]
                # /Users/glen/tools-a8/packages/haxe/current/std/sys/Http.hx:294
                if (c == 10):
                    break
                # /Users/glen/tools-a8/packages/haxe/current/std/sys/Http.hx:296
                if (c == 13):
                    k = 3
                else:
                    k = 4
            elif (k1 == 2):
                # /Users/glen/tools-a8/packages/haxe/current/std/sys/Http.hx:301
                c1 = s.b[1]
                # /Users/glen/tools-a8/packages/haxe/current/std/sys/Http.hx:302
                if (c1 == 10):
                    # /Users/glen/tools-a8/packages/haxe/current/std/sys/Http.hx:303
                    if (s.b[0] == 13):
                        break
                    # /Users/glen/tools-a8/packages/haxe/current/std/sys/Http.hx:305
                    k = 4
                elif (c1 == 13):
                    k = 3
                else:
                    k = 4
            elif (k1 == 3):
                # /Users/glen/tools-a8/packages/haxe/current/std/sys/Http.hx:311
                c2 = s.b[2]
                # /Users/glen/tools-a8/packages/haxe/current/std/sys/Http.hx:312
                if (c2 == 10):
                    if (s.b[1] != 13):
                        k = 4
                    elif (s.b[0] != 10):
                        k = 2
                    else:
                        break
                elif (c2 == 13):
                    if ((s.b[1] != 10) or ((s.b[0] != 13))):
                        k = 1
                    else:
                        k = 3
                else:
                    k = 4
            elif (k1 == 4):
                # /Users/glen/tools-a8/packages/haxe/current/std/sys/Http.hx:327
                c3 = s.b[3]
                # /Users/glen/tools-a8/packages/haxe/current/std/sys/Http.hx:328
                if (c3 == 10):
                    if (s.b[2] != 13):
                        continue
                    elif ((s.b[1] != 10) or ((s.b[0] != 13))):
                        k = 2
                    else:
                        break
                elif (c3 == 13):
                    if ((s.b[2] != 10) or ((s.b[1] != 13))):
                        k = 3
                    else:
                        k = 1
            else:
                pass
        # /Users/glen/tools-a8/packages/haxe/current/std/sys/Http.hx:346
        _this = b.getBytes().toString()
        headers = _this.split("\r\n")
        # /Users/glen/tools-a8/packages/haxe/current/std/sys/Http.hx:348
        response = (None if ((len(headers) == 0)) else headers.pop(0))
        # /Users/glen/tools-a8/packages/haxe/current/std/sys/Http.hx:349
        rp = response.split(" ")
        # /Users/glen/tools-a8/packages/haxe/current/std/sys/Http.hx:350
        status = Std.parseInt((rp[1] if 1 < len(rp) else None))
        # /Users/glen/tools-a8/packages/haxe/current/std/sys/Http.hx:351
        if ((status == 0) or ((status is None))):
            raise _HxException("Response status error")
        # /Users/glen/tools-a8/packages/haxe/current/std/sys/Http.hx:355
        if (len(headers) != 0):
            headers.pop()
        # /Users/glen/tools-a8/packages/haxe/current/std/sys/Http.hx:356
        if (len(headers) != 0):
            headers.pop()
        # /Users/glen/tools-a8/packages/haxe/current/std/sys/Http.hx:357
        self.responseHeaders = haxe_ds_StringMap()
        # /Users/glen/tools-a8/packages/haxe/current/std/sys/Http.hx:358
        size = None
        # /Users/glen/tools-a8/packages/haxe/current/std/sys/Http.hx:359
        chunked = False
        # /Users/glen/tools-a8/packages/haxe/current/std/sys/Http.hx:360
        # /Users/glen/tools-a8/packages/haxe/current/std/sys/Http.hx:360
        _g = 0
        while (_g < len(headers)):
            hline = (headers[_g] if _g >= 0 and _g < len(headers) else None)
            _g = (_g + 1)
            # /Users/glen/tools-a8/packages/haxe/current/std/sys/Http.hx:361
            a = hline.split(": ")
            # /Users/glen/tools-a8/packages/haxe/current/std/sys/Http.hx:362
            hname = (None if ((len(a) == 0)) else a.pop(0))
            # /Users/glen/tools-a8/packages/haxe/current/std/sys/Http.hx:363
            hval = ((a[0] if 0 < len(a) else None) if ((len(a) == 1)) else ": ".join([python_Boot.toString1(x1,'') for x1 in a]))
            # /Users/glen/tools-a8/packages/haxe/current/std/sys/Http.hx:364
            hval = StringTools.ltrim(StringTools.rtrim(hval))
            # /Users/glen/tools-a8/packages/haxe/current/std/sys/Http.hx:365
            self.responseHeaders.h[hname] = hval
            # /Users/glen/tools-a8/packages/haxe/current/std/sys/Http.hx:366
            # /Users/glen/tools-a8/packages/haxe/current/std/sys/Http.hx:366
            _g1 = hname.lower()
            _hx_local_2 = len(_g1)
            # /Users/glen/tools-a8/packages/haxe/current/std/sys/Http.hx:370
            if (_hx_local_2 == 17):
                if (_g1 == "transfer-encoding"):
                    chunked = (hval.lower() == "chunked")
            elif (_hx_local_2 == 14):
                if (_g1 == "content-length"):
                    size = Std.parseInt(hval)
            else:
                pass
        # /Users/glen/tools-a8/packages/haxe/current/std/sys/Http.hx:374
        self.onStatus(status)
        # /Users/glen/tools-a8/packages/haxe/current/std/sys/Http.hx:376
        chunk_re = EReg("^([0-9A-Fa-f]+)[ ]*\r\n","m")
        # /Users/glen/tools-a8/packages/haxe/current/std/sys/Http.hx:377
        self.chunk_size = None
        # /Users/glen/tools-a8/packages/haxe/current/std/sys/Http.hx:378
        self.chunk_buf = None
        # /Users/glen/tools-a8/packages/haxe/current/std/sys/Http.hx:380
        bufsize = 1024
        # /Users/glen/tools-a8/packages/haxe/current/std/sys/Http.hx:381
        buf = haxe_io_Bytes.alloc(bufsize)
        # /Users/glen/tools-a8/packages/haxe/current/std/sys/Http.hx:382
        if chunked:
            try:
                while True:
                    # /Users/glen/tools-a8/packages/haxe/current/std/sys/Http.hx:385
                    _hx_len = sock.input.readBytes(buf,0,bufsize)
                    # /Users/glen/tools-a8/packages/haxe/current/std/sys/Http.hx:386
                    if (not self.readChunk(chunk_re,api,buf,_hx_len)):
                        break
            except Exception as _hx_e:
                _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
                if isinstance(_hx_e1, haxe_io_Eof):
                    e = _hx_e1
                    raise _HxException("Transfer aborted")
                else:
                    raise _hx_e
        elif (size is None):
            # /Users/glen/tools-a8/packages/haxe/current/std/sys/Http.hx:393
            if (not self.noShutdown):
                sock.shutdown(False,True)
            # /Users/glen/tools-a8/packages/haxe/current/std/sys/Http.hx:395
            try:
                while True:
                    # /Users/glen/tools-a8/packages/haxe/current/std/sys/Http.hx:397
                    len1 = sock.input.readBytes(buf,0,bufsize)
                    # /Users/glen/tools-a8/packages/haxe/current/std/sys/Http.hx:398
                    if (len1 == 0):
                        break
                    # /Users/glen/tools-a8/packages/haxe/current/std/sys/Http.hx:400
                    api.writeBytes(buf,0,len1)
            except Exception as _hx_e:
                _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
                if isinstance(_hx_e1, haxe_io_Eof):
                        pass
                else:
                    raise _hx_e
        else:
            # /Users/glen/tools-a8/packages/haxe/current/std/sys/Http.hx:404
            api.prepare(size)
            # /Users/glen/tools-a8/packages/haxe/current/std/sys/Http.hx:405
            try:
                while (size > 0):
                    # /Users/glen/tools-a8/packages/haxe/current/std/sys/Http.hx:407
                    len2 = sock.input.readBytes(buf,0,(bufsize if ((size > bufsize)) else size))
                    # /Users/glen/tools-a8/packages/haxe/current/std/sys/Http.hx:408
                    api.writeBytes(buf,0,len2)
                    # /Users/glen/tools-a8/packages/haxe/current/std/sys/Http.hx:409
                    size = (size - len2)
            except Exception as _hx_e:
                _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
                if isinstance(_hx_e1, haxe_io_Eof):
                    e2 = _hx_e1
                    raise _HxException("Transfer aborted")
                else:
                    raise _hx_e
        # /Users/glen/tools-a8/packages/haxe/current/std/sys/Http.hx:415
        if (chunked and (((self.chunk_size is not None) or ((self.chunk_buf is not None))))):
            raise _HxException("Invalid chunk")
        # /Users/glen/tools-a8/packages/haxe/current/std/sys/Http.hx:417
        if ((status < 200) or ((status >= 400))):
            raise _HxException(("Http Error #" + Std.string(status)))
        # /Users/glen/tools-a8/packages/haxe/current/std/sys/Http.hx:419
        api.close()

    def readChunk(self,chunk_re,api,buf,_hx_len):
        # /Users/glen/tools-a8/packages/haxe/current/std/sys/Http.hx:423
        if (self.chunk_size is None):
            # /Users/glen/tools-a8/packages/haxe/current/std/sys/Http.hx:424
            if (self.chunk_buf is not None):
                # /Users/glen/tools-a8/packages/haxe/current/std/sys/Http.hx:425
                b = haxe_io_BytesBuffer()
                # /Users/glen/tools-a8/packages/haxe/current/std/sys/Http.hx:426
                b.b.extend(self.chunk_buf.b)
                # /Users/glen/tools-a8/packages/haxe/current/std/sys/Http.hx:427
                # /Users/glen/tools-a8/packages/haxe/current/std/sys/Http.hx:427
                if ((_hx_len < 0) or ((_hx_len > buf.length))):
                    raise _HxException(haxe_io_Error.OutsideBounds)
                b.b.extend(buf.b[0:_hx_len])
                # /Users/glen/tools-a8/packages/haxe/current/std/sys/Http.hx:428
                buf = b.getBytes()
                # /Users/glen/tools-a8/packages/haxe/current/std/sys/Http.hx:429
                _hx_len = (_hx_len + self.chunk_buf.length)
                # /Users/glen/tools-a8/packages/haxe/current/std/sys/Http.hx:430
                self.chunk_buf = None
            # /Users/glen/tools-a8/packages/haxe/current/std/sys/Http.hx:435
            s = buf.toString()
            chunk_re.matchObj = python_lib_Re.search(chunk_re.pattern,s)
            if (chunk_re.matchObj is not None):
                # /Users/glen/tools-a8/packages/haxe/current/std/sys/Http.hx:437
                p_pos = chunk_re.matchObj.start()
                p_len = (chunk_re.matchObj.end() - chunk_re.matchObj.start())
                # /Users/glen/tools-a8/packages/haxe/current/std/sys/Http.hx:438
                if (p_len <= _hx_len):
                    # /Users/glen/tools-a8/packages/haxe/current/std/sys/Http.hx:439
                    cstr = chunk_re.matchObj.group(1)
                    # /Users/glen/tools-a8/packages/haxe/current/std/sys/Http.hx:440
                    self.chunk_size = Std.parseInt(("0x" + ("null" if cstr is None else cstr)))
                    # /Users/glen/tools-a8/packages/haxe/current/std/sys/Http.hx:441
                    if (self.chunk_size == 0):
                        # /Users/glen/tools-a8/packages/haxe/current/std/sys/Http.hx:442
                        self.chunk_size = None
                        # /Users/glen/tools-a8/packages/haxe/current/std/sys/Http.hx:443
                        self.chunk_buf = None
                        # /Users/glen/tools-a8/packages/haxe/current/std/sys/Http.hx:444
                        return False
                    # /Users/glen/tools-a8/packages/haxe/current/std/sys/Http.hx:446
                    _hx_len = (_hx_len - p_len)
                    # /Users/glen/tools-a8/packages/haxe/current/std/sys/Http.hx:447
                    return self.readChunk(chunk_re,api,buf.sub(p_len,_hx_len),_hx_len)
            # /Users/glen/tools-a8/packages/haxe/current/std/sys/Http.hx:451
            if (_hx_len > 10):
                # /Users/glen/tools-a8/packages/haxe/current/std/sys/Http.hx:452
                self.onError("Invalid chunk")
                # /Users/glen/tools-a8/packages/haxe/current/std/sys/Http.hx:453
                return False
            # /Users/glen/tools-a8/packages/haxe/current/std/sys/Http.hx:455
            self.chunk_buf = buf.sub(0,_hx_len)
            # /Users/glen/tools-a8/packages/haxe/current/std/sys/Http.hx:456
            return True
        # /Users/glen/tools-a8/packages/haxe/current/std/sys/Http.hx:459
        if (self.chunk_size > _hx_len):
            # /Users/glen/tools-a8/packages/haxe/current/std/sys/Http.hx:460
            # /Users/glen/tools-a8/packages/haxe/current/std/sys/Http.hx:460
            _hx_local_2 = self
            _hx_local_3 = _hx_local_2.chunk_size
            _hx_local_2.chunk_size = (_hx_local_3 - _hx_len)
            _hx_local_2.chunk_size
            # /Users/glen/tools-a8/packages/haxe/current/std/sys/Http.hx:461
            api.writeBytes(buf,0,_hx_len)
            # /Users/glen/tools-a8/packages/haxe/current/std/sys/Http.hx:462
            return True
        # /Users/glen/tools-a8/packages/haxe/current/std/sys/Http.hx:464
        end = (self.chunk_size + 2)
        # /Users/glen/tools-a8/packages/haxe/current/std/sys/Http.hx:465
        if (_hx_len >= end):
            # /Users/glen/tools-a8/packages/haxe/current/std/sys/Http.hx:466
            if (self.chunk_size > 0):
                api.writeBytes(buf,0,self.chunk_size)
            # /Users/glen/tools-a8/packages/haxe/current/std/sys/Http.hx:468
            _hx_len = (_hx_len - end)
            # /Users/glen/tools-a8/packages/haxe/current/std/sys/Http.hx:469
            self.chunk_size = None
            # /Users/glen/tools-a8/packages/haxe/current/std/sys/Http.hx:470
            if (_hx_len == 0):
                return True
            # /Users/glen/tools-a8/packages/haxe/current/std/sys/Http.hx:472
            return self.readChunk(chunk_re,api,buf.sub(end,_hx_len),_hx_len)
        # /Users/glen/tools-a8/packages/haxe/current/std/sys/Http.hx:474
        if (self.chunk_size > 0):
            api.writeBytes(buf,0,self.chunk_size)
        # /Users/glen/tools-a8/packages/haxe/current/std/sys/Http.hx:476
        # /Users/glen/tools-a8/packages/haxe/current/std/sys/Http.hx:476
        _hx_local_5 = self
        _hx_local_6 = _hx_local_5.chunk_size
        _hx_local_5.chunk_size = (_hx_local_6 - _hx_len)
        _hx_local_5.chunk_size
        # /Users/glen/tools-a8/packages/haxe/current/std/sys/Http.hx:477
        return True

    @staticmethod
    def requestUrl(url):
        # /Users/glen/tools-a8/packages/haxe/current/std/sys/Http.hx:489
        h = sys_Http(url)
        # /Users/glen/tools-a8/packages/haxe/current/std/sys/Http.hx:490
        r = None
        # /Users/glen/tools-a8/packages/haxe/current/std/sys/Http.hx:492
        def _hx_local_0(d):
            # /Users/glen/tools-a8/packages/haxe/current/std/sys/Http.hx:492
            nonlocal r
            r = d
        # /Users/glen/tools-a8/packages/haxe/current/std/sys/Http.hx:491
        h.onData = _hx_local_0
        # /Users/glen/tools-a8/packages/haxe/current/std/sys/Http.hx:495
        def _hx_local_1(e):
            # /Users/glen/tools-a8/packages/haxe/current/std/sys/Http.hx:495
            raise _HxException(e)
        # /Users/glen/tools-a8/packages/haxe/current/std/sys/Http.hx:494
        h.onError = _hx_local_1
        # /Users/glen/tools-a8/packages/haxe/current/std/sys/Http.hx:497
        h.request(False)
        # /Users/glen/tools-a8/packages/haxe/current/std/sys/Http.hx:498
        return r

sys_Http._hx_class = sys_Http


class sys_net_Host:
    _hx_class_name = "sys.net.Host"
    _hx_is_interface = "False"
    __slots__ = ("host", "name")
    _hx_fields = ["host", "name"]
    _hx_methods = ["toString"]

    def __init__(self,name):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/sys/net/Host.hx:32
        self.host = name
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/sys/net/Host.hx:33
        self.name = name

    def toString(self):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/sys/net/Host.hx:37
        return self.name

sys_net_Host._hx_class = sys_net_Host


class sys_net__Socket_SocketInput(haxe_io_Input):
    _hx_class_name = "sys.net._Socket.SocketInput"
    _hx_is_interface = "False"
    __slots__ = ("_hx___s",)
    _hx_fields = ["__s"]
    _hx_methods = ["readByte", "readBytes"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = haxe_io_Input


    def __init__(self,s):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/sys/net/Socket.hx:39
        self._hx___s = s

    def readByte(self):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/sys/net/Socket.hx:43
        r = None
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/sys/net/Socket.hx:44
        try:
            r = self._hx___s.recv(1,0)
        except Exception as _hx_e:
            _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
            if isinstance(_hx_e1, BlockingIOError):
                e = _hx_e1
                raise _HxException(haxe_io_Error.Blocked)
            else:
                raise _hx_e
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/sys/net/Socket.hx:49
        if (len(r) == 0):
            raise _HxException(haxe_io_Eof())
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/sys/net/Socket.hx:51
        return r[0]

    def readBytes(self,buf,pos,_hx_len):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/sys/net/Socket.hx:55
        r = None
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/sys/net/Socket.hx:56
        data = buf.b
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/sys/net/Socket.hx:57
        try:
            # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/sys/net/Socket.hx:58
            r = self._hx___s.recv(_hx_len,0)
            # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/sys/net/Socket.hx:59
            # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/sys/net/Socket.hx:59
            _g = pos
            _g1 = (pos + len(r))
            while (_g < _g1):
                i = _g
                _g = (_g + 1)
                # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/sys/net/Socket.hx:60
                data.__setitem__(i,r[(i - pos)])
        except Exception as _hx_e:
            _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
            if isinstance(_hx_e1, BlockingIOError):
                e = _hx_e1
                raise _HxException(haxe_io_Error.Blocked)
            else:
                raise _hx_e
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/sys/net/Socket.hx:65
        if (len(r) == 0):
            raise _HxException(haxe_io_Eof())
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/sys/net/Socket.hx:67
        return len(r)

sys_net__Socket_SocketInput._hx_class = sys_net__Socket_SocketInput


class sys_net__Socket_SocketOutput(haxe_io_Output):
    _hx_class_name = "sys.net._Socket.SocketOutput"
    _hx_is_interface = "False"
    __slots__ = ("_hx___s",)
    _hx_fields = ["__s"]
    _hx_methods = ["writeByte", "writeBytes", "close"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = haxe_io_Output


    def __init__(self,s):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/sys/net/Socket.hx:81
        self._hx___s = s

    def writeByte(self,c):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/sys/net/Socket.hx:85
        try:
            self._hx___s.send(bytes([c]),0)
        except Exception as _hx_e:
            _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
            if isinstance(_hx_e1, BlockingIOError):
                e = _hx_e1
                raise _HxException(haxe_io_Error.Blocked)
            else:
                raise _hx_e

    def writeBytes(self,buf,pos,_hx_len):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/sys/net/Socket.hx:93
        try:
            # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/sys/net/Socket.hx:94
            data = buf.b
            # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/sys/net/Socket.hx:95
            payload = data[pos:pos+_hx_len]
            # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/sys/net/Socket.hx:96
            r = self._hx___s.send(payload,0)
            # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/sys/net/Socket.hx:97
            return r
        except Exception as _hx_e:
            _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
            if isinstance(_hx_e1, BlockingIOError):
                e = _hx_e1
                raise _HxException(haxe_io_Error.Blocked)
            else:
                raise _hx_e

    def close(self):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/sys/net/Socket.hx:104
        super().close()
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/sys/net/Socket.hx:105
        if (self._hx___s is not None):
            self._hx___s.close()

sys_net__Socket_SocketOutput._hx_class = sys_net__Socket_SocketOutput


class tink_core_Annex:
    _hx_class_name = "tink.core.Annex"
    _hx_is_interface = "False"
    __slots__ = ("target", "registry")
    _hx_fields = ["target", "registry"]

    def __init__(self,target):
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Annex.hx:17
        self.target = target
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Annex.hx:18
        self.registry = haxe_ds_ObjectMap()

tink_core_Annex._hx_class = tink_core_Annex


class tink_core__Callback_Callback_Impl_:
    _hx_class_name = "tink.core._Callback.Callback_Impl_"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["_new", "toFunction", "depth", "MAX_DEPTH", "invoke", "ignore", "fromNiladic", "fromMany", "defer"]

    @staticmethod
    def _new(f):
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Callback.hx:5
        this1 = f
        return this1

    @staticmethod
    def toFunction(this1):
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Callback.hx:9
        return this1

    @staticmethod
    def invoke(this1,data):
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Callback.hx:14
        if (tink_core__Callback_Callback_Impl_.depth < 200):
            # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Callback.hx:15
            # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Callback.hx:15
            _hx_local_0 = tink_core__Callback_Callback_Impl_
            _hx_local_1 = _hx_local_0.depth
            _hx_local_0.depth = (_hx_local_1 + 1)
            _hx_local_1
            # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Callback.hx:16
            this1(data)
            # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Callback.hx:17
            # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Callback.hx:17
            _hx_local_2 = tink_core__Callback_Callback_Impl_
            _hx_local_3 = _hx_local_2.depth
            _hx_local_2.depth = (_hx_local_3 - 1)
            _hx_local_3
        else:
            # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Callback.hx:19
            _e = this1
            def _hx_local_4(data1):
                tink_core__Callback_Callback_Impl_.invoke(_e,data1)
            f = _hx_local_4
            data2 = data
            def _hx_local_5():
                f(data2)
            tink_core__Callback_Callback_Impl_.defer(_hx_local_5)

    @staticmethod
    def ignore(cb):
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Callback.hx:24
        def _hx_local_0(_):
            # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Callback.hx:24
            tink_core__Callback_Callback_Impl_.invoke(cb,tink_core_Noise.Noise)
        return _hx_local_0

    @staticmethod
    def fromNiladic(f):
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Callback.hx:27
        def _hx_local_0(_):
            # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Callback.hx:27
            f()
        return _hx_local_0

    @staticmethod
    def fromMany(callbacks):
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Callback.hx:31
        def _hx_local_0(v):
            # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Callback.hx:32
            _g = 0
            while (_g < len(callbacks)):
                callback = (callbacks[_g] if _g >= 0 and _g < len(callbacks) else None)
                _g = (_g + 1)
                # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Callback.hx:33
                tink_core__Callback_Callback_Impl_.invoke(callback,v)
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Callback.hx:30
        return _hx_local_0

    @staticmethod
    def defer(f):
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Callback.hx:49
        haxe_Timer.delay(f,0)
tink_core__Callback_Callback_Impl_._hx_class = tink_core__Callback_Callback_Impl_


class tink_core_LinkObject:
    _hx_class_name = "tink.core.LinkObject"
    _hx_is_interface = "True"
    __slots__ = ()
    _hx_methods = ["cancel"]
tink_core_LinkObject._hx_class = tink_core_LinkObject


class tink_core__Callback_CallbackLink_Impl_:
    _hx_class_name = "tink.core._Callback.CallbackLink_Impl_"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["_new", "cancel", "dissolve", "noop", "toFunction", "toCallback", "fromFunction", "join", "fromMany"]

    @staticmethod
    def _new(link):
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Callback.hx:61
        this1 = tink_core_SimpleLink(link)
        return this1

    @staticmethod
    def cancel(this1):
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Callback.hx:65
        if (this1 is not None):
            this1.cancel()

    @staticmethod
    def dissolve(this1):
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Callback.hx:69
        if (this1 is not None):
            this1.cancel()

    @staticmethod
    def noop():
        pass

    @staticmethod
    def toFunction(this1):
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Callback.hx:74
        if (this1 is None):
            return tink_core__Callback_CallbackLink_Impl_.noop
        else:
            return this1.cancel

    @staticmethod
    def toCallback(this1):
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Callback.hx:77
        def _hx_local_0(_):
            # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Callback.hx:77
            this1.cancel()
        return _hx_local_0

    @staticmethod
    def fromFunction(f):
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Callback.hx:80
        this1 = tink_core_SimpleLink(f)
        return this1

    @staticmethod
    def join(a,b):
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Callback.hx:83
        return tink_core__Callback_LinkPair(a,b)

    @staticmethod
    def fromMany(callbacks):
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Callback.hx:87
        def _hx_local_1():
            # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Callback.hx:87
            nonlocal callbacks
            if (callbacks is not None):
                # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Callback.hx:88
                _g = 0
                while (_g < len(callbacks)):
                    cb = (callbacks[_g] if _g >= 0 and _g < len(callbacks) else None)
                    _g = (_g + 1)
                    if (cb is not None):
                        cb.cancel()
            else:
                callbacks = None
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Callback.hx:86
        this1 = tink_core_SimpleLink(_hx_local_1)
        return this1
tink_core__Callback_CallbackLink_Impl_._hx_class = tink_core__Callback_CallbackLink_Impl_


class tink_core_SimpleLink:
    _hx_class_name = "tink.core.SimpleLink"
    _hx_is_interface = "False"
    __slots__ = ("f",)
    _hx_fields = ["f"]
    _hx_methods = ["cancel"]
    _hx_interfaces = [tink_core_LinkObject]

    def __init__(self,f):
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Callback.hx:98
        self.f = f

    def cancel(self):
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Callback.hx:101
        if (self.f is not None):
            # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Callback.hx:102
            self.f()
            # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Callback.hx:103
            self.f = None

tink_core_SimpleLink._hx_class = tink_core_SimpleLink


class tink_core__Callback_LinkPair:
    _hx_class_name = "tink.core._Callback.LinkPair"
    _hx_is_interface = "False"
    __slots__ = ("a", "b", "dissolved")
    _hx_fields = ["a", "b", "dissolved"]
    _hx_methods = ["cancel"]
    _hx_interfaces = [tink_core_LinkObject]

    def __init__(self,a,b):
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Callback.hx:111
        self.dissolved = False
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Callback.hx:113
        self.a = a
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Callback.hx:114
        self.b = b

    def cancel(self):
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Callback.hx:118
        if (not self.dissolved):
            # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Callback.hx:119
            self.dissolved = True
            # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Callback.hx:120
            # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Callback.hx:120
            this1 = self.a
            if (this1 is not None):
                this1.cancel()
            # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Callback.hx:121
            # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Callback.hx:121
            this2 = self.b
            if (this2 is not None):
                this2.cancel()
            # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Callback.hx:122
            self.a = None
            # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Callback.hx:123
            self.b = None

tink_core__Callback_LinkPair._hx_class = tink_core__Callback_LinkPair


class tink_core__Callback_ListCell:
    _hx_class_name = "tink.core._Callback.ListCell"
    _hx_is_interface = "False"
    __slots__ = ("cb", "list")
    _hx_fields = ["cb", "list"]
    _hx_methods = ["invoke", "clear", "cancel"]
    _hx_interfaces = [tink_core_LinkObject]

    def __init__(self,cb,_hx_list):
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Callback.hx:132
        if (cb is None):
            raise _HxException("callback expected but null received")
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Callback.hx:133
        self.cb = cb
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Callback.hx:134
        self.list = _hx_list

    def invoke(self,data):
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Callback.hx:138
        if (self.list is not None):
            tink_core__Callback_Callback_Impl_.invoke(self.cb,data)

    def clear(self):
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Callback.hx:142
        self.cb = None
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Callback.hx:143
        self.list = None

    def cancel(self):
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Callback.hx:147
        if (self.list is not None):
            # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Callback.hx:148
            _hx_list = self.list
            # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Callback.hx:149
            # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Callback.hx:149
            self.cb = None
            self.list = None
            # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Callback.hx:150
            def _hx_local_1():
                # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Callback.hx:150
                _hx_list.used = (_hx_list.used - 1)
                return _hx_list.used
            tmp = _hx_local_1()
            if (tmp < ((_hx_list.used >> 1))):
                _hx_list.compact()

tink_core__Callback_ListCell._hx_class = tink_core__Callback_ListCell


class tink_core_CallbackList:
    _hx_class_name = "tink.core.CallbackList"
    _hx_is_interface = "False"
    _hx_fields = ["cells", "used", "queue", "busy"]
    _hx_methods = ["ondrain", "get_length", "release", "add", "invoke", "compact", "resize", "clear"]

    def __init__(self):
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Callback.hx:163
        self.busy = False
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Callback.hx:161
        self.queue = []
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Callback.hx:160
        self.used = 0
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Callback.hx:165
        self.cells = []

    def ondrain(self):
        pass

    def get_length(self):
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Callback.hx:171
        return self.used

    def release(self):
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Callback.hx:174
        self.used = (self.used - 1)
        tmp = self.used
        if (tmp < ((self.used >> 1))):
            self.compact()

    def add(self,cb):
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Callback.hx:178
        node = tink_core__Callback_ListCell(cb,self)
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Callback.hx:179
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Callback.hx:179
        _this = self.cells
        _this.append(node)
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Callback.hx:180
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Callback.hx:180
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.used
        _hx_local_0.used = (_hx_local_1 + 1)
        _hx_local_1
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Callback.hx:181
        return node

    def invoke(self,data,destructive = None):
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Callback.hx:185
        if self.busy:
            # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Callback.hx:186
            _this = self.queue
            f = self.invoke
            data1 = data
            destructive1 = destructive
            def _hx_local_0():
                f(data1,destructive1)
                return
            tmp = _hx_local_0
            _this.append(tmp)
        else:
            # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Callback.hx:188
            self.busy = True
            # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Callback.hx:190
            length = len(self.cells)
            # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Callback.hx:191
            # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Callback.hx:191
            _g = 0
            _g1 = length
            while (_g < _g1):
                i = _g
                _g = (_g + 1)
                # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Callback.hx:192
                # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Callback.hx:192
                _this1 = (self.cells[i] if i >= 0 and i < len(self.cells) else None)
                if (_this1.list is not None):
                    tink_core__Callback_Callback_Impl_.invoke(_this1.cb,data)
            # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Callback.hx:194
            self.busy = False
            # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Callback.hx:196
            if destructive:
                # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Callback.hx:197
                added = (len(self.cells) - length)
                # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Callback.hx:198
                # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Callback.hx:198
                _g2 = 0
                _g3 = length
                while (_g2 < _g3):
                    i1 = _g2
                    _g2 = (_g2 + 1)
                    # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Callback.hx:199
                    # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Callback.hx:199
                    _this2 = (self.cells[i1] if i1 >= 0 and i1 < len(self.cells) else None)
                    _this2.cb = None
                    _this2.list = None
                # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Callback.hx:200
                # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Callback.hx:200
                _g4 = 0
                _g5 = added
                while (_g4 < _g5):
                    i2 = _g4
                    _g4 = (_g4 + 1)
                    # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Callback.hx:201
                    python_internal_ArrayImpl._set(self.cells, i2, python_internal_ArrayImpl._get(self.cells, (length + i2)))
                # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Callback.hx:202
                self.resize(added)
            elif (self.used < len(self.cells)):
                self.compact()
            # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Callback.hx:206
            if (len(self.queue) > 0):
                # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Callback.hx:207
                _this3 = self.queue
                ((None if ((len(_this3) == 0)) else _this3.pop(0)))()

    def compact(self):
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Callback.hx:211
        if self.busy:
            return
        elif (self.used == 0):
            # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Callback.hx:213
            self.resize(0)
            # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Callback.hx:214
            self.ondrain()
        else:
            # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Callback.hx:217
            compacted = 0
            # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Callback.hx:219
            # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Callback.hx:219
            _g = 0
            _g1 = len(self.cells)
            while (_g < _g1):
                i = _g
                _g = (_g + 1)
                # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Callback.hx:220
                # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Callback.hx:220
                _g2 = (self.cells[i] if i >= 0 and i < len(self.cells) else None)
                # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Callback.hx:221
                _g21 = _g2.list
                # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Callback.hx:221
                if (_g2.cb is not None):
                    # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Callback.hx:222
                    v = _g2
                    # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Callback.hx:223
                    if (compacted != i):
                        python_internal_ArrayImpl._set(self.cells, compacted, v)
                    # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Callback.hx:225
                    compacted = (compacted + 1)
                    tmp = compacted
                    if (tmp == self.used):
                        break
            # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Callback.hx:228
            self.resize(self.used)

    def resize(self,length):
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Callback.hx:233
        _this = self.cells
        l = len(_this)
        if (l < length):
            idx = (length - 1)
            v = None
            l1 = len(_this)
            while (l1 < idx):
                _this.append(None)
                l1 = (l1 + 1)
            if (l1 == idx):
                _this.append(v)
            else:
                _this[idx] = v
        elif (l > length):
            pos = length
            _hx_len = (l - length)
            if (pos < 0):
                pos = (len(_this) + pos)
            if (pos < 0):
                pos = 0
            res = _this[pos:(pos + _hx_len)]
            del _this[pos:(pos + _hx_len)]

    def clear(self):
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Callback.hx:240
        if self.busy:
            # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Callback.hx:241
            _this = self.queue
            _this.append(self.clear)
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Callback.hx:242
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Callback.hx:242
        _g = 0
        _g1 = self.cells
        while (_g < len(_g1)):
            cell = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Callback.hx:243
            # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Callback.hx:243
            cell.cb = None
            cell.list = None
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Callback.hx:244
        self.resize(0)

tink_core_CallbackList._hx_class = tink_core_CallbackList


class tink_core_TypedError:
    _hx_class_name = "tink.core.TypedError"
    _hx_is_interface = "False"
    __slots__ = ("message", "code", "data", "pos", "callStack", "exceptionStack", "isTinkError")
    _hx_fields = ["message", "code", "data", "pos", "callStack", "exceptionStack", "isTinkError"]
    _hx_methods = ["printPos", "toString", "throwSelf"]
    _hx_statics = ["withData", "typed", "asError", "catchExceptions", "reporter", "rethrow", "tryFinally"]

    def __init__(self,code = None,message = None,pos = None):
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Error.hx:48
        if (code is None):
            code = 500
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Error.hx:51
        self.data = None
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Error.hx:55
        self.isTinkError = True
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Error.hx:58
        self.code = code
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Error.hx:59
        self.message = message
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Error.hx:60
        self.pos = pos
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Error.hx:61
        self.exceptionStack = []
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Error.hx:62
        self.callStack = []

    def printPos(self):
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Error.hx:65
        return ((((HxOverrides.stringOrNull(self.pos.className) + ".") + HxOverrides.stringOrNull(self.pos.methodName)) + ":") + Std.string(self.pos.lineNumber))

    def toString(self):
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Error.hx:75
        ret = ((("Error#" + Std.string(self.code)) + ": ") + HxOverrides.stringOrNull(self.message))
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Error.hx:77
        if (self.pos is not None):
            ret = (("null" if ret is None else ret) + HxOverrides.stringOrNull(((" @ " + HxOverrides.stringOrNull(self.printPos())))))
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Error.hx:80
        return ret

    def throwSelf(self):
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Error.hx:92
        any = self
        raise _HxException(any)

    @staticmethod
    def withData(code = None,message = None,data = None,pos = None):
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Error.hx:96
        return tink_core_TypedError.typed(code,message,data,pos)

    @staticmethod
    def typed(code = None,message = None,data = None,pos = None):
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Error.hx:100
        ret = tink_core_TypedError(code,message,pos)
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Error.hx:101
        ret.data = data
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Error.hx:102
        return ret

    @staticmethod
    def asError(v):
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Error.hx:111
        return Std.downcast(v,tink_core_TypedError)

    @staticmethod
    def catchExceptions(f,report = None,pos = None):
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Error.hx:123
        try:
            return tink_core_Outcome.Success(f())
        except Exception as _hx_e:
            _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
            e = _hx_e1
            # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Error.hx:127
            _g = tink_core_TypedError.asError(e)
            tmp = None
            # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Error.hx:128
            if (_g is None):
                tmp = (tink_core_TypedError.withData(None,"Unexpected Error",e,pos) if ((report is None)) else report(e))
            else:
                # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Error.hx:133
                e1 = _g
                # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Error.hx:127
                tmp = e1
            # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Error.hx:126
            return tink_core_Outcome.Failure(tmp)

    @staticmethod
    def reporter(code = None,message = None,pos = None):
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Error.hx:139
        def _hx_local_0(e):
            # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Error.hx:139
            return tink_core_TypedError.withData(code,message,e,pos)
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Error.hx:138
        return _hx_local_0

    @staticmethod
    def rethrow(any):
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Error.hx:149
        raise _HxException(any)

    @staticmethod
    def tryFinally(f,cleanup):
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Error.hx:163
        try:
            # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Error.hx:164
            ret = f()
            # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Error.hx:165
            cleanup()
            # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Error.hx:166
            return ret
        except Exception as _hx_e:
            _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
            e = _hx_e1
            # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Error.hx:169
            cleanup()
            # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Error.hx:170
            raise _HxException(e)

tink_core_TypedError._hx_class = tink_core_TypedError


class tink_core__Error_Stack_Impl_:
    _hx_class_name = "tink.core._Error.Stack_Impl_"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["toString"]

    @staticmethod
    def toString(this1):
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Error.hx:180
        return "Error stack not available. Compile with -D error_stack."
tink_core__Error_Stack_Impl_._hx_class = tink_core__Error_Stack_Impl_


class tink_core_FutureObject:
    _hx_class_name = "tink.core.FutureObject"
    _hx_is_interface = "True"
    __slots__ = ()
    _hx_methods = ["map", "flatMap", "handle", "gather", "eager"]
tink_core_FutureObject._hx_class = tink_core_FutureObject


class tink_core__Future_NeverFuture:
    _hx_class_name = "tink.core._Future.NeverFuture"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_methods = ["map", "flatMap", "handle", "gather", "eager"]
    _hx_statics = ["inst"]
    _hx_interfaces = [tink_core_FutureObject]

    def __init__(self):
        pass

    def map(self,f):
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Future.hx:236
        return tink_core__Future_NeverFuture.inst

    def flatMap(self,f):
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Future.hx:237
        return tink_core__Future_NeverFuture.inst

    def handle(self,callback):
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Future.hx:238
        return None

    def gather(self):
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Future.hx:239
        return tink_core__Future_NeverFuture.inst

    def eager(self):
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Future.hx:240
        return tink_core__Future_NeverFuture.inst

tink_core__Future_NeverFuture._hx_class = tink_core__Future_NeverFuture

class tink_core_Noise(Enum):
    __slots__ = ()
    _hx_class_name = "tink.core.Noise"
    _hx_constructs = ["Noise"]
tink_core_Noise.Noise = tink_core_Noise("Noise", 0, ())
tink_core_Noise._hx_class = tink_core_Noise


class tink_core__Lazy_LazyObject:
    _hx_class_name = "tink.core._Lazy.LazyObject"
    _hx_is_interface = "True"
    __slots__ = ()
    _hx_methods = ["get", "map", "flatMap"]
tink_core__Lazy_LazyObject._hx_class = tink_core__Lazy_LazyObject


class tink_core__Lazy_LazyConst:
    _hx_class_name = "tink.core._Lazy.LazyConst"
    _hx_is_interface = "False"
    __slots__ = ("value",)
    _hx_fields = ["value"]
    _hx_methods = ["get", "map", "flatMap"]
    _hx_interfaces = [tink_core__Lazy_LazyObject]

    def __init__(self,value):
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Lazy.hx:34
        self.value = value

    def get(self):
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Lazy.hx:37
        return self.value

    def map(self,f):
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Lazy.hx:39
        _gthis = self
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Lazy.hx:40
        def _hx_local_1():
            # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Lazy.hx:40
            def _hx_local_0():
                # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Lazy.hx:40
                return f(_gthis.value)
            return tink_core__Lazy_LazyFunc(_hx_local_0)
        return _hx_local_1()

    def flatMap(self,f):
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Lazy.hx:42
        _gthis = self
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Lazy.hx:43
        def _hx_local_1():
            # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Lazy.hx:43
            def _hx_local_0():
                # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Lazy.hx:43
                return f(_gthis.value).get()
            return tink_core__Lazy_LazyFunc(_hx_local_0)
        return _hx_local_1()

tink_core__Lazy_LazyConst._hx_class = tink_core__Lazy_LazyConst


class tink_core__Future_SyncFuture:
    _hx_class_name = "tink.core._Future.SyncFuture"
    _hx_is_interface = "False"
    __slots__ = ("value",)
    _hx_fields = ["value"]
    _hx_methods = ["map", "flatMap", "handle", "eager", "gather"]
    _hx_interfaces = [tink_core_FutureObject]

    def __init__(self,value):
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Future.hx:248
        self.value = value

    def map(self,f):
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Future.hx:251
        return tink_core__Future_SyncFuture(self.value.map(f))

    def flatMap(self,f):
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Future.hx:253
        _gthis = self
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Future.hx:254
        def _hx_local_1():
            # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Future.hx:254
            def _hx_local_0(_hx_yield):
                # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Future.hx:254
                tmp = _gthis.value.get()
                return f(tmp).handle(_hx_yield)
            return tink_core__Future_SuspendableFuture(_hx_local_0)
        return _hx_local_1()

    def handle(self,cb):
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Future.hx:257
        tink_core__Callback_Callback_Impl_.invoke(cb,self.value.get())
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Future.hx:258
        return None

    def eager(self):
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Future.hx:262
        return self

    def gather(self):
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Future.hx:265
        return self

tink_core__Future_SyncFuture._hx_class = tink_core__Future_SyncFuture


class tink_core__Future_Future_Impl_:
    _hx_class_name = "tink.core._Future.Future_Impl_"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["NULL", "NOISE", "NEVER", "_new", "first", "map", "flatMap", "next", "merge", "flatten", "ofAny", "asPromise", "ofMany", "fromMany", "lazy", "sync", "isFuture", "make", "or", "either", "and", "_tryFailingFlatMap", "_tryFlatMap", "_tryFailingMap", "_tryMap", "_flatMap", "_map", "trigger", "delay"]

    @staticmethod
    def _new(f):
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Future.hx:17
        this1 = tink_core__Future_SuspendableFuture(f)
        return this1

    @staticmethod
    def first(this1,other):
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Future.hx:24
        ret = tink_core_FutureTrigger()
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Future.hx:25
        l1 = this1.handle(ret.trigger)
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Future.hx:26
        l2 = other.handle(ret.trigger)
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Future.hx:27
        ret1 = ret
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Future.hx:28
        if (l1 is not None):
            # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Future.hx:29
            this2 = l1
            def _hx_local_0(_):
                this2.cancel()
            ret1.handle(_hx_local_0)
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Future.hx:30
        if (l2 is not None):
            # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Future.hx:31
            this3 = l2
            def _hx_local_1(_1):
                this3.cancel()
            ret1.handle(_hx_local_1)
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Future.hx:32
        return ret1

    @staticmethod
    def map(this1,f,gather = None):
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Future.hx:39
        if (gather is None):
            gather = True
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Future.hx:40
        ret = this1.map(f)
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Future.hx:42
        if gather:
            return ret.gather()
        else:
            return ret

    @staticmethod
    def flatMap(this1,next,gather = None):
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Future.hx:50
        if (gather is None):
            gather = True
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Future.hx:51
        ret = this1.flatMap(next)
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Future.hx:53
        if gather:
            return ret.gather()
        else:
            return ret

    @staticmethod
    def next(this1,n):
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Future.hx:62
        def _hx_local_1():
            # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Future.hx:62
            def _hx_local_0(v):
                # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Future.hx:62
                return n(v)
            return this1.flatMap(_hx_local_0)
        return _hx_local_1()

    @staticmethod
    def merge(this1,other,merger,gather = None):
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Future.hx:68
        if (gather is None):
            gather = True
        gather1 = gather
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Future.hx:50
        if (gather1 is None):
            gather1 = True
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Future.hx:69
        def _hx_local_1(t):
            # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Future.hx:69
            gather2 = False
            # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Future.hx:39
            if (gather2 is None):
                gather2 = True
            # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Future.hx:69
            def _hx_local_0(a):
                # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Future.hx:69
                return merger(t,a)
            ret1 = other.map(_hx_local_0)
            if gather2:
                return ret1.gather()
            else:
                return ret1
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Future.hx:68
        ret = this1.flatMap(_hx_local_1)
        if gather1:
            return ret.gather()
        else:
            return ret

    @staticmethod
    def flatten(f):
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Future.hx:76
        def _hx_local_3():
            # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Future.hx:76
            def _hx_local_2(_hx_yield):
                # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Future.hx:77
                inner = None
                # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Future.hx:79
                def _hx_local_0(second):
                    # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Future.hx:79
                    nonlocal inner
                    inner = second.handle(_hx_yield)
                # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Future.hx:78
                outer = f.handle(_hx_local_0)
                # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Future.hx:81
                def _hx_local_1():
                    # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Future.hx:81
                    if (inner is not None):
                        inner.cancel()
                this1 = tink_core_SimpleLink(_hx_local_1)
                return tink_core__Callback_LinkPair(outer,this1)
            return tink_core__Future_SuspendableFuture(_hx_local_2)
        return _hx_local_3()

    @staticmethod
    def ofAny(v):
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Future.hx:93
        return tink_core__Future_SyncFuture(tink_core__Lazy_LazyConst(v))

    @staticmethod
    def asPromise(s):
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Future.hx:99
        return s

    @staticmethod
    def ofMany(futures,gather = None):
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Future.hx:104
        if (gather is None):
            gather = True
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Future.hx:105
        ret = tink_core__Future_SyncFuture(tink_core__Lazy_LazyConst([]))
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Future.hx:106
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Future.hx:106
        _g = 0
        while (_g < len(futures)):
            f = [(futures[_g] if _g >= 0 and _g < len(futures) else None)]
            _g = (_g + 1)
            # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Future.hx:107
            gather1 = False
            # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Future.hx:50
            if (gather1 is None):
                gather1 = True
            # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Future.hx:108
            def _hx_local_4(f1):
                # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Future.hx:108
                def _hx_local_1(results):
                    # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Future.hx:109
                    gather2 = False
                    # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Future.hx:39
                    if (gather2 is None):
                        gather2 = True
                    # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Future.hx:110
                    def _hx_local_3():
                        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Future.hx:110
                        def _hx_local_2(result):
                            # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Future.hx:111
                            return (results + [result])
                        return _hx_local_2
                    ret2 = _hx_local_3()
                    # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Future.hx:109
                    ret3 = (f1[0] if 0 < len(f1) else None).map(ret2)
                    if gather2:
                        return ret3.gather()
                    else:
                        return ret3
                return _hx_local_1
            # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Future.hx:107
            ret1 = ret.flatMap(_hx_local_4(f))
            ret = (ret1.gather() if gather1 else ret1)
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Future.hx:117
        if gather:
            return ret.gather()
        else:
            return ret

    @staticmethod
    def fromMany(futures):
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Future.hx:123
        return tink_core__Future_Future_Impl_.ofMany(futures)

    @staticmethod
    def lazy(l):
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Future.hx:127
        return tink_core__Future_SyncFuture(l)

    @staticmethod
    def sync(v):
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Future.hx:134
        return tink_core__Future_SyncFuture(tink_core__Lazy_LazyConst(v))

    @staticmethod
    def isFuture(maybeFuture):
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Future.hx:137
        return Std._hx_is(maybeFuture,tink_core_FutureObject)

    @staticmethod
    def make(f,lazy = None):
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Future.hx:145
        if (lazy is None):
            lazy = False
        if lazy:
            # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Future.hx:146
            def _hx_local_1():
                # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Future.hx:146
                def _hx_local_0(_hx_yield):
                    # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Future.hx:147
                    f(_hx_yield)
                    # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Future.hx:148
                    return None
                return tink_core__Future_SuspendableFuture(_hx_local_0)
            return _hx_local_1()
        else:
            # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Future.hx:151
            op = tink_core_FutureTrigger()
            # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Future.hx:152
            wrapped = f
            # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Future.hx:153
            tink_core__Callback_Callback_Impl_.invoke(wrapped,op.trigger)
            # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Future.hx:154
            return op

    @staticmethod
    def _hx_or(a,b):
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Future.hx:161
        return tink_core__Future_Future_Impl_.first(a,b)

    @staticmethod
    def either(a,b):
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Future.hx:167
        gather = False
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Future.hx:39
        if (gather is None):
            gather = True
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Future.hx:167
        ret = a.map(haxe_ds_Either.Left)
        tmp = (ret.gather() if gather else ret)
        gather1 = False
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Future.hx:39
        if (gather1 is None):
            gather1 = True
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Future.hx:167
        ret1 = b.map(haxe_ds_Either.Right)
        return tink_core__Future_Future_Impl_.first(tmp,(ret1.gather() if gather1 else ret1))

    @staticmethod
    def _hx_and(a,b):
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Future.hx:173
        def _hx_local_1():
            # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Future.hx:173
            def _hx_local_0(a1,b1):
                # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Future.hx:173
                this1 = tink_core_MPair(a1,b1)
                return this1
            return tink_core__Future_Future_Impl_.merge(a,b,_hx_local_0)
        return _hx_local_1()

    @staticmethod
    def _tryFailingFlatMap(f,_hx_map):
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Future.hx:176
        def _hx_local_0(o):
            # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Future.hx:176
            ret1 = o.index
            # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Future.hx:177
            if (ret1 == 0):
                # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Future.hx:177
                d = o.params[0]
                return _hx_map(d)
            elif (ret1 == 1):
                # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Future.hx:178
                f1 = o.params[0]
                return tink_core__Future_SyncFuture(tink_core__Lazy_LazyConst(tink_core_Outcome.Failure(f1)))
            else:
                pass
        ret = f.flatMap(_hx_local_0)
        return ret.gather()

    @staticmethod
    def _tryFlatMap(f,_hx_map):
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Future.hx:182
        def _hx_local_0(o):
            # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Future.hx:182
            ret1 = o.index
            # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Future.hx:183
            if (ret1 == 0):
                # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Future.hx:183
                d = o.params[0]
                ret2 = _hx_map(d).map(tink_core_Outcome.Success)
                return ret2.gather()
            elif (ret1 == 1):
                # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Future.hx:184
                f1 = o.params[0]
                return tink_core__Future_SyncFuture(tink_core__Lazy_LazyConst(tink_core_Outcome.Failure(f1)))
            else:
                pass
        ret = f.flatMap(_hx_local_0)
        return ret.gather()

    @staticmethod
    def _tryFailingMap(f,_hx_map):
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Future.hx:188
        def _hx_local_0(o):
            # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Future.hx:188
            return tink_core_OutcomeTools.flatMap(o,tink_core__Outcome_OutcomeMapper_Impl_.withSameError(_hx_map))
        ret = f.map(_hx_local_0)
        return ret.gather()

    @staticmethod
    def _tryMap(f,_hx_map):
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Future.hx:191
        def _hx_local_0(o):
            # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Future.hx:191
            return tink_core_OutcomeTools.map(o,_hx_map)
        ret = f.map(_hx_local_0)
        return ret.gather()

    @staticmethod
    def _flatMap(f,_hx_map):
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Future.hx:194
        ret = f.flatMap(_hx_map)
        return ret.gather()

    @staticmethod
    def _map(f,_hx_map):
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Future.hx:197
        ret = f.map(_hx_map)
        return ret.gather()

    @staticmethod
    def trigger():
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Future.hx:203
        return tink_core_FutureTrigger()

    @staticmethod
    def delay(ms,value):
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Future.hx:206
        def _hx_local_2():
            # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Future.hx:206
            def _hx_local_1(cb):
                # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Future.hx:206
                def _hx_local_0():
                    # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Future.hx:206
                    cb(value.get())
                haxe_Timer.delay(_hx_local_0,ms)
            return tink_core__Future_Future_Impl_.make(_hx_local_1)
        return _hx_local_2()
tink_core__Future_Future_Impl_._hx_class = tink_core__Future_Future_Impl_


class tink_core_FutureTrigger:
    _hx_class_name = "tink.core.FutureTrigger"
    _hx_is_interface = "False"
    __slots__ = ("result", "list")
    _hx_fields = ["result", "list"]
    _hx_methods = ["handle", "map", "flatMap", "gather", "eager", "asFuture", "trigger"]
    _hx_statics = ["gatherFuture"]
    _hx_interfaces = [tink_core_FutureObject]

    def __init__(self):
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Future.hx:269
        self.result = None
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Future.hx:273
        self.list = tink_core_CallbackList()

    def handle(self,callback):
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Future.hx:276
        _g = self.list
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Future.hx:277
        if (_g is None):
            # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Future.hx:278
            tink_core__Callback_Callback_Impl_.invoke(callback,self.result)
            # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Future.hx:279
            return None
        else:
            # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Future.hx:280
            v = _g
            # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Future.hx:281
            node = tink_core__Callback_ListCell(callback,v)
            _this = v.cells
            _this.append(node)
            v.used = (v.used + 1)
            return node

    def map(self,f):
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Future.hx:285
        _g = self.list
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Future.hx:286
        if (_g is None):
            return tink_core__Future_SyncFuture(tink_core__Lazy_LazyConst(f(self.result)))
        else:
            # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Future.hx:287
            v = _g
            # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Future.hx:288
            ret = tink_core_FutureTrigger()
            # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Future.hx:289
            # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Future.hx:289
            _this = self.list
            def _hx_local_0(v1):
                node1 = f(v1)
                ret.trigger(node1)
            node = tink_core__Callback_ListCell(_hx_local_0,_this)
            _this1 = _this.cells
            _this1.append(node)
            _this.used = (_this.used + 1)
            # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Future.hx:290
            return ret

    def flatMap(self,f):
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Future.hx:294
        _g = self.list
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Future.hx:295
        if (_g is None):
            return f(self.result)
        else:
            # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Future.hx:296
            v = _g
            # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Future.hx:297
            ret = tink_core_FutureTrigger()
            # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Future.hx:298
            # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Future.hx:298
            _this = self.list
            def _hx_local_0(v1):
                f(v1).handle(ret.trigger)
            node = tink_core__Callback_ListCell(_hx_local_0,_this)
            _this1 = _this.cells
            _this1.append(node)
            _this.used = (_this.used + 1)
            # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Future.hx:299
            return ret

    def gather(self):
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Future.hx:303
        return self

    def eager(self):
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Future.hx:306
        return self

    def asFuture(self):
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Future.hx:309
        return self

    def trigger(self,result):
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Future.hx:319
        if (self.list is None):
            return False
        else:
            # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Future.hx:321
            _hx_list = self.list
            # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Future.hx:322
            self.list = None
            # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Future.hx:323
            self.result = result
            # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Future.hx:324
            _hx_list.invoke(result,True)
            # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Future.hx:325
            return True

    @staticmethod
    def gatherFuture(f):
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Future.hx:312
        def _hx_local_1():
            # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Future.hx:312
            def _hx_local_0(_hx_yield):
                # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Future.hx:312
                return f.handle(_hx_yield)
            return tink_core__Future_SuspendableFuture(_hx_local_0)
        return _hx_local_1()

tink_core_FutureTrigger._hx_class = tink_core_FutureTrigger


class tink_core__Future_SuspendableFuture:
    _hx_class_name = "tink.core._Future.SuspendableFuture"
    _hx_is_interface = "False"
    __slots__ = ("callbacks", "result", "suspended", "link", "wakeup")
    _hx_fields = ["callbacks", "result", "suspended", "link", "wakeup"]
    _hx_methods = ["trigger", "handle", "map", "flatMap", "gather", "eager"]
    _hx_interfaces = [tink_core_FutureObject]

    def __init__(self,wakeup):
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Future.hx:345
        self.wakeup = None
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Future.hx:344
        self.link = None
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Future.hx:342
        self.result = None
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Future.hx:341
        self.callbacks = None
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Future.hx:343
        self.suspended = True
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Future.hx:347
        _gthis = self
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Future.hx:348
        self.wakeup = wakeup
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Future.hx:349
        self.callbacks = tink_core_CallbackList()
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Future.hx:351
        def _hx_local_0():
            # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Future.hx:351
            if (_gthis.callbacks is not None):
                # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Future.hx:352
                _gthis.suspended = True
                # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Future.hx:353
                # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Future.hx:353
                this1 = _gthis.link
                if (this1 is not None):
                    this1.cancel()
                # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Future.hx:354
                _gthis.link = None
        self.callbacks.ondrain = _hx_local_0

    def trigger(self,value):
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Future.hx:359
        _g = self.callbacks
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Future.hx:360
        if (_g is not None):
            # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Future.hx:361
            _hx_list = _g
            # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Future.hx:362
            self.callbacks = None
            # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Future.hx:363
            self.suspended = False
            # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Future.hx:364
            self.result = value
            # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Future.hx:365
            self.link = None
            # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Future.hx:366
            self.wakeup = None
            # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Future.hx:367
            _hx_list.invoke(value,True)

    def handle(self,callback):
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Future.hx:372
        _g = self.callbacks
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Future.hx:373
        if (_g is None):
            # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Future.hx:374
            tink_core__Callback_Callback_Impl_.invoke(callback,self.result)
            # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Future.hx:375
            return None
        else:
            # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Future.hx:376
            v = _g
            # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Future.hx:377
            _this = self.callbacks
            node = tink_core__Callback_ListCell(callback,_this)
            _this1 = _this.cells
            _this1.append(node)
            _this.used = (_this.used + 1)
            ret = node
            # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Future.hx:378
            if self.suspended:
                # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Future.hx:379
                self.suspended = False
                # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Future.hx:380
                self.link = self.wakeup(self.trigger)
            # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Future.hx:382
            return ret

    def map(self,f):
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Future.hx:386
        _gthis = self
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Future.hx:387
        def _hx_local_3():
            # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Future.hx:388
            def _hx_local_2(_hx_yield):
                # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Future.hx:388
                def _hx_local_1():
                    # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Future.hx:388
                    def _hx_local_0(res):
                        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Future.hx:388
                        tmp = f(res)
                        _hx_yield(tmp)
                    return _gthis.handle(_hx_local_0)
                return _hx_local_1()
            # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Future.hx:387
            return tink_core__Future_SuspendableFuture(_hx_local_2)
        return _hx_local_3()

    def flatMap(self,f):
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Future.hx:392
        return tink_core__Future_Future_Impl_.flatten(self.map(f))

    def gather(self):
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Future.hx:395
        return self

    def eager(self):
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Future.hx:398
        def _hx_local_0():
            pass
        self.handle(tink_core__Callback_Callback_Impl_.fromNiladic(_hx_local_0))
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Future.hx:399
        return self

tink_core__Future_SuspendableFuture._hx_class = tink_core__Future_SuspendableFuture


class tink_core__Lazy_Lazy_Impl_:
    _hx_class_name = "tink.core._Lazy.Lazy_Impl_"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["NULL", "get", "ofFunc", "map", "flatMap", "ofConst"]

    @staticmethod
    def get(this1):
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Lazy.hx:8
        return this1.get()

    @staticmethod
    def ofFunc(f):
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Lazy.hx:11
        return tink_core__Lazy_LazyFunc(f)

    @staticmethod
    def map(this1,f):
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Lazy.hx:14
        return this1.map(f)

    @staticmethod
    def flatMap(this1,f):
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Lazy.hx:17
        return this1.flatMap(f)

    @staticmethod
    def ofConst(c):
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Lazy.hx:20
        return tink_core__Lazy_LazyConst(c)
tink_core__Lazy_Lazy_Impl_._hx_class = tink_core__Lazy_Lazy_Impl_


class tink_core__Lazy_LazyFunc:
    _hx_class_name = "tink.core._Lazy.LazyFunc"
    _hx_is_interface = "False"
    __slots__ = ("f", "result", "busy")
    _hx_fields = ["f", "result", "busy"]
    _hx_methods = ["get", "map", "flatMap"]
    _hx_interfaces = [tink_core__Lazy_LazyObject]

    def __init__(self,f):
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Lazy.hx:48
        self.result = None
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Lazy.hx:49
        self.busy = False
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Lazy.hx:51
        self.f = f

    def get(self):
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Lazy.hx:54
        if self.busy:
            raise _HxException(tink_core_TypedError(None,"circular lazyness",_hx_AnonObject({'fileName': "tink/core/Lazy.hx", 'lineNumber': 54, 'className': "tink.core._Lazy.LazyFunc", 'methodName': "get"})))
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Lazy.hx:55
        if (self.f is not None):
            # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Lazy.hx:56
            self.busy = True
            # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Lazy.hx:57
            self.result = self.f()
            # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Lazy.hx:58
            self.f = None
            # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Lazy.hx:59
            self.busy = False
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Lazy.hx:61
        return self.result

    def map(self,f):
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Lazy.hx:64
        _gthis = self
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Lazy.hx:65
        def _hx_local_1():
            # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Lazy.hx:65
            def _hx_local_0():
                # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Lazy.hx:65
                tmp = _gthis.get()
                return f(tmp)
            return tink_core__Lazy_LazyFunc(_hx_local_0)
        return _hx_local_1()

    def flatMap(self,f):
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Lazy.hx:67
        _gthis = self
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Lazy.hx:68
        def _hx_local_1():
            # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Lazy.hx:68
            def _hx_local_0():
                # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Lazy.hx:68
                this1 = _gthis.get()
                return f(this1).get()
            return tink_core__Lazy_LazyFunc(_hx_local_0)
        return _hx_local_1()

tink_core__Lazy_LazyFunc._hx_class = tink_core__Lazy_LazyFunc


class tink_core_NamedWith:
    _hx_class_name = "tink.core.NamedWith"
    _hx_is_interface = "False"
    __slots__ = ("name", "value")
    _hx_fields = ["name", "value"]

    def __init__(self,name,value):
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Named.hx:12
        self.name = name
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Named.hx:13
        self.value = value

tink_core_NamedWith._hx_class = tink_core_NamedWith


class tink_core_OptionTools:
    _hx_class_name = "tink.core.OptionTools"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["force", "or", "orNull", "filter", "satisfies", "equals", "map", "flatMap", "iterator", "toArray"]

    @staticmethod
    def force(o,pos = None):
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Option.hx:11
        if (o.index == 0):
            # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Option.hx:12
            v = o.params[0]
            # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Option.hx:13
            return v
        else:
            raise _HxException(tink_core_TypedError(404,"Some value expected but none found",pos))

    @staticmethod
    def _hx_or(o,l):
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Option.hx:22
        if (o.index == 0):
            # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Option.hx:23
            v = o.params[0]
            return v
        else:
            return l.get()

    @staticmethod
    def orNull(o):
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Option.hx:31
        if (o.index == 0):
            # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Option.hx:32
            v = o.params[0]
            return v
        else:
            return None

    @staticmethod
    def filter(o,f):
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Option.hx:40
        if (o.index == 0):
            if (f(o.params[0]) == False):
                return haxe_ds_Option._hx_None
            else:
                return o
        else:
            return o

    @staticmethod
    def satisfies(o,f):
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Option.hx:49
        if (o.index == 0):
            # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Option.hx:50
            v = o.params[0]
            return f(v)
        else:
            return False

    @staticmethod
    def equals(o,v):
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Option.hx:58
        if (o.index == 0):
            # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Option.hx:58
            v1 = o.params[0]
            return HxOverrides.eq(v1,v)
        else:
            return False

    @staticmethod
    def map(o,f):
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Option.hx:65
        if (o.index == 0):
            # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Option.hx:66
            v = o.params[0]
            return haxe_ds_Option.Some(f(v))
        else:
            return haxe_ds_Option._hx_None

    @staticmethod
    def flatMap(o,f):
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Option.hx:75
        if (o.index == 0):
            # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Option.hx:76
            v = o.params[0]
            return f(v)
        else:
            return haxe_ds_Option._hx_None

    @staticmethod
    def iterator(o):
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Option.hx:85
        return tink_core_OptionIter(o)

    @staticmethod
    def toArray(o):
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Option.hx:92
        if (o.index == 0):
            # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Option.hx:93
            v = o.params[0]
            return [v]
        else:
            return []
tink_core_OptionTools._hx_class = tink_core_OptionTools


class tink_core_OptionIter:
    _hx_class_name = "tink.core.OptionIter"
    _hx_is_interface = "False"
    __slots__ = ("value", "alive")
    _hx_fields = ["value", "alive"]
    _hx_methods = ["hasNext", "next"]

    def __init__(self,o):
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Option.hx:100
        self.value = None
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Option.hx:101
        self.alive = True
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Option.hx:104
        if (o.index == 0):
            # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Option.hx:105
            v = o.params[0]
            self.value = v
        else:
            self.alive = False

    def hasNext(self):
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Option.hx:110
        return self.alive

    def next(self):
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Option.hx:113
        self.alive = False
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Option.hx:115
        return self.value

tink_core_OptionIter._hx_class = tink_core_OptionIter

class tink_core_Outcome(Enum):
    __slots__ = ()
    _hx_class_name = "tink.core.Outcome"
    _hx_constructs = ["Success", "Failure"]

    @staticmethod
    def Success(data):
        return tink_core_Outcome("Success", 0, (data,))

    @staticmethod
    def Failure(failure):
        return tink_core_Outcome("Failure", 1, (failure,))
tink_core_Outcome._hx_class = tink_core_Outcome


class tink_core_OutcomeTools:
    _hx_class_name = "tink.core.OutcomeTools"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["sure", "toOption", "toOutcome", "orNull", "orUse", "orTry", "equals", "map", "isSuccess", "flatMap", "swap", "next", "attempt", "flatten"]

    @staticmethod
    def sure(outcome):
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Outcome.hx:19
        tmp = outcome.index
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Outcome.hx:20
        if (tmp == 0):
            # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Outcome.hx:20
            data = outcome.params[0]
            # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Outcome.hx:21
            return data
        elif (tmp == 1):
            # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Outcome.hx:22
            failure = outcome.params[0]
            # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Outcome.hx:23
            _g = tink_core_TypedError.asError(failure)
            # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Outcome.hx:24
            if (_g is None):
                raise _HxException(failure)
            else:
                # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Outcome.hx:25
                e = _g
                return e.throwSelf()
        else:
            pass

    @staticmethod
    def toOption(outcome):
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Outcome.hx:34
        tmp = outcome.index
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Outcome.hx:35
        if (tmp == 0):
            # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Outcome.hx:35
            data = outcome.params[0]
            return haxe_ds_Option.Some(data)
        elif (tmp == 1):
            # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Outcome.hx:36
            _g1 = outcome.params[0]
            return haxe_ds_Option._hx_None
        else:
            pass

    @staticmethod
    def toOutcome(option,pos = None):
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Outcome.hx:44
        tmp = option.index
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Outcome.hx:45
        if (tmp == 0):
            # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Outcome.hx:45
            value = option.params[0]
            # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Outcome.hx:46
            return tink_core_Outcome.Success(value)
        elif (tmp == 1):
            return tink_core_Outcome.Failure(tink_core_TypedError(404,((("Some value expected but none found in " + HxOverrides.stringOrNull(pos.fileName)) + "@line ") + Std.string(pos.lineNumber)),_hx_AnonObject({'fileName': "tink/core/Outcome.hx", 'lineNumber': 48, 'className': "tink.core.OutcomeTools", 'methodName': "toOutcome"})))
        else:
            pass

    @staticmethod
    def orNull(outcome):
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Outcome.hx:56
        tmp = outcome.index
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Outcome.hx:57
        if (tmp == 0):
            # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Outcome.hx:57
            data = outcome.params[0]
            return data
        elif (tmp == 1):
            # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Outcome.hx:58
            _g1 = outcome.params[0]
            return None
        else:
            pass

    @staticmethod
    def orUse(outcome,fallback):
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Outcome.hx:66
        tmp = outcome.index
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Outcome.hx:67
        if (tmp == 0):
            # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Outcome.hx:67
            data = outcome.params[0]
            return data
        elif (tmp == 1):
            # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Outcome.hx:68
            _g1 = outcome.params[0]
            return fallback.get()
        else:
            pass

    @staticmethod
    def orTry(outcome,fallback):
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Outcome.hx:76
        tmp = outcome.index
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Outcome.hx:77
        if (tmp == 0):
            # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Outcome.hx:77
            _g = outcome.params[0]
            return outcome
        elif (tmp == 1):
            # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Outcome.hx:78
            _g1 = outcome.params[0]
            return fallback.get()
        else:
            pass

    @staticmethod
    def equals(outcome,to):
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Outcome.hx:85
        tmp = outcome.index
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Outcome.hx:86
        if (tmp == 0):
            # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Outcome.hx:86
            data = outcome.params[0]
            return HxOverrides.eq(data,to)
        elif (tmp == 1):
            # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Outcome.hx:87
            _g1 = outcome.params[0]
            return False
        else:
            pass

    @staticmethod
    def map(outcome,transform):
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Outcome.hx:95
        tmp = outcome.index
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Outcome.hx:96
        if (tmp == 0):
            # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Outcome.hx:96
            a = outcome.params[0]
            # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Outcome.hx:97
            return tink_core_Outcome.Success(transform(a))
        elif (tmp == 1):
            # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Outcome.hx:98
            f = outcome.params[0]
            # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Outcome.hx:99
            return tink_core_Outcome.Failure(f)
        else:
            pass

    @staticmethod
    def isSuccess(outcome):
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Outcome.hx:107
        if (outcome.index == 0):
            # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Outcome.hx:108
            _g = outcome.params[0]
            return True
        else:
            return False

    @staticmethod
    def flatMap(o,mapper):
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Outcome.hx:118
        return tink_core__Outcome_OutcomeMapper_Impl_.apply(mapper,o)

    @staticmethod
    def swap(outcome,v):
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Outcome.hx:126
        tmp = outcome.index
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Outcome.hx:127
        if (tmp == 0):
            # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Outcome.hx:127
            a = outcome.params[0]
            # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Outcome.hx:128
            return tink_core_Outcome.Success(v)
        elif (tmp == 1):
            # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Outcome.hx:129
            f = outcome.params[0]
            # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Outcome.hx:130
            return tink_core_Outcome.Failure(f)
        else:
            pass

    @staticmethod
    def next(outcome,f):
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Outcome.hx:134
        tmp = outcome.index
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Outcome.hx:135
        if (tmp == 0):
            # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Outcome.hx:135
            v = outcome.params[0]
            return f(v)
        elif (tmp == 1):
            # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Outcome.hx:136
            e = outcome.params[0]
            return tink_core__Future_SyncFuture(tink_core__Lazy_LazyConst(tink_core_Outcome.Failure(e)))
        else:
            pass

    @staticmethod
    def attempt(f,report):
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Outcome.hx:145
        try:
            return tink_core_Outcome.Success(f())
        except Exception as _hx_e:
            _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
            e = _hx_e1
            return tink_core_Outcome.Failure(report(e))

    @staticmethod
    def flatten(o):
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Outcome.hx:150
        tmp = o.index
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Outcome.hx:152
        if (tmp == 0):
            # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Outcome.hx:152
            _g = o.params[0]
            tmp1 = _g.index
            # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Outcome.hx:151
            if (tmp1 == 0):
                # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Outcome.hx:151
                d = _g.params[0]
                return tink_core_Outcome.Success(d)
            elif (tmp1 == 1):
                # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Outcome.hx:152
                f = _g.params[0]
                return tink_core_Outcome.Failure(f)
            else:
                pass
        elif (tmp == 1):
            # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Outcome.hx:152
            f1 = o.params[0]
            return tink_core_Outcome.Failure(f1)
        else:
            pass
tink_core_OutcomeTools._hx_class = tink_core_OutcomeTools


class tink_core__Outcome_OutcomeMapper_Impl_:
    _hx_class_name = "tink.core._Outcome.OutcomeMapper_Impl_"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["_new", "apply", "withSameError", "withEitherError"]

    @staticmethod
    def _new(f):
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Outcome.hx:157
        this1 = _hx_AnonObject({'f': f})
        return this1

    @staticmethod
    def apply(this1,o):
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Outcome.hx:159
        return this1.f(o)

    @staticmethod
    def withSameError(f):
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Outcome.hx:162
        def _hx_local_1():
            # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Outcome.hx:163
            def _hx_local_0(o):
                # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Outcome.hx:163
                tmp = o.index
                # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Outcome.hx:164
                if (tmp == 0):
                    # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Outcome.hx:164
                    d = o.params[0]
                    return f(d)
                elif (tmp == 1):
                    # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Outcome.hx:165
                    f1 = o.params[0]
                    return tink_core_Outcome.Failure(f1)
                else:
                    pass
            # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Outcome.hx:162
            return tink_core__Outcome_OutcomeMapper_Impl_._new(_hx_local_0)
        return _hx_local_1()

    @staticmethod
    def withEitherError(f):
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Outcome.hx:171
        def _hx_local_1():
            # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Outcome.hx:172
            def _hx_local_0(o):
                # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Outcome.hx:172
                tmp = o.index
                # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Outcome.hx:173
                if (tmp == 0):
                    # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Outcome.hx:173
                    d = o.params[0]
                    # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Outcome.hx:174
                    _g = f(d)
                    tmp1 = _g.index
                    # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Outcome.hx:175
                    if (tmp1 == 0):
                        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Outcome.hx:175
                        d1 = _g.params[0]
                        return tink_core_Outcome.Success(d1)
                    elif (tmp1 == 1):
                        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Outcome.hx:176
                        f1 = _g.params[0]
                        return tink_core_Outcome.Failure(haxe_ds_Either.Right(f1))
                    else:
                        pass
                elif (tmp == 1):
                    # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Outcome.hx:178
                    f2 = o.params[0]
                    return tink_core_Outcome.Failure(haxe_ds_Either.Left(f2))
                else:
                    pass
            # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Outcome.hx:171
            return tink_core__Outcome_OutcomeMapper_Impl_._new(_hx_local_0)
        return _hx_local_1()
tink_core__Outcome_OutcomeMapper_Impl_._hx_class = tink_core__Outcome_OutcomeMapper_Impl_


class tink_core__Pair_Pair_Impl_:
    _hx_class_name = "tink.core._Pair.Pair_Impl_"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["_new", "get_a", "get_b", "toBool", "isNil", "nil"]
    a = None
    b = None

    @staticmethod
    def _new(a,b):
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Pair.hx:9
        this1 = tink_core_MPair(a,b)
        return this1

    @staticmethod
    def get_a(this1):
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Pair.hx:11
        return this1.a

    @staticmethod
    def get_b(this1):
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Pair.hx:12
        return this1.b

    @staticmethod
    def toBool(this1):
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Pair.hx:15
        return (this1 is not None)

    @staticmethod
    def isNil(this1):
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Pair.hx:18
        return (this1 is None)

    @staticmethod
    def nil():
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Pair.hx:21
        return None
tink_core__Pair_Pair_Impl_._hx_class = tink_core__Pair_Pair_Impl_


class tink_core_MPair:
    _hx_class_name = "tink.core.MPair"
    _hx_is_interface = "False"
    __slots__ = ("a", "b")
    _hx_fields = ["a", "b"]

    def __init__(self,a,b):
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Pair.hx:28
        self.a = a
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Pair.hx:29
        self.b = b

tink_core_MPair._hx_class = tink_core_MPair


class tink_core__Progress_Progress_Impl_:
    _hx_class_name = "tink.core._Progress.Progress_Impl_"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["INIT", "trigger", "make", "asFuture", "asPromise", "promise", "future", "next"]

    @staticmethod
    def trigger():
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Progress.hx:15
        return tink_core_ProgressTrigger()

    @staticmethod
    def make(f):
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Progress.hx:19
        value = tink_core_ProgressType.InProgress(tink_core__Progress_Progress_Impl_.INIT)
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Progress.hx:20
        signal = tink_core__Signal_Signal_Impl_.trigger()
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Progress.hx:21
        def _hx_local_2(cb):
            # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Progress.hx:23
            def _hx_local_0(v,total):
                # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Progress.hx:23
                nonlocal value
                progress1 = value.index
                # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Progress.hx:26
                if (progress1 == 0):
                    # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Progress.hx:26
                    current = value.params[0]
                    # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Progress.hx:27
                    if ((current.a != v) or (not tink_core_TotalTools.eq(current.b,total))):
                        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Progress.hx:28
                        this1 = tink_core_MPair(v,total)
                        pv = this1
                        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Progress.hx:29
                        value = tink_core_ProgressType.InProgress(pv)
                        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Progress.hx:30
                        signal.handlers.invoke(pv)
                elif (progress1 == 1):
                    _g1 = value.params[0]
                else:
                    pass
            # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Progress.hx:22
            progress = _hx_local_0
            # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Progress.hx:36
            def _hx_local_1(v1):
                # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Progress.hx:36
                nonlocal value
                if (value.index == 1):
                    _g = value.params[0]
                else:
                    # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Progress.hx:41
                    value = tink_core_ProgressType.Finished(v1)
                    # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Progress.hx:42
                    cb(v1)
            # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Progress.hx:35
            finish = _hx_local_1
            # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Progress.hx:46
            f(progress,finish)
        future = tink_core__Future_Future_Impl_.make(_hx_local_2)
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Progress.hx:49
        return tink_core_CompositeProgress(future,signal)

    @staticmethod
    def asFuture(this1):
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Progress.hx:54
        return this1

    @staticmethod
    def asPromise(p):
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Progress.hx:59
        return p

    @staticmethod
    def promise(v):
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Progress.hx:63
        return tink_core_PromiseProgress(v)

    @staticmethod
    def future(v):
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Progress.hx:68
        return tink_core_FutureProgress(v)

    @staticmethod
    def next(this1,f):
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Progress.hx:72
        return tink_core__Future_Future_Impl_.next(this1,f)
tink_core__Progress_Progress_Impl_._hx_class = tink_core__Progress_Progress_Impl_


class tink_core_SignalObject:
    _hx_class_name = "tink.core.SignalObject"
    _hx_is_interface = "True"
    __slots__ = ()
    _hx_methods = ["listen"]
tink_core_SignalObject._hx_class = tink_core_SignalObject


class tink_core_ProgressObject:
    _hx_class_name = "tink.core.ProgressObject"
    _hx_is_interface = "True"
    __slots__ = ()
    _hx_interfaces = [tink_core_SignalObject, tink_core_FutureObject]
tink_core_ProgressObject._hx_class = tink_core_ProgressObject


class tink_core_CompositeProgress:
    _hx_class_name = "tink.core.CompositeProgress"
    _hx_is_interface = "False"
    __slots__ = ("future", "signal")
    _hx_fields = ["future", "signal"]
    _hx_methods = ["map", "flatMap", "handle", "listen", "gather", "eager"]
    _hx_interfaces = [tink_core_ProgressObject]

    def __init__(self,future,signal):
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Progress.hx:82
        self.future = future
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Progress.hx:83
        self.signal = signal

    def map(self,f):
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Progress.hx:86
        ret = self.future.map(f)
        return ret.gather()

    def flatMap(self,f):
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Progress.hx:89
        ret = self.future.flatMap(f)
        return ret.gather()

    def handle(self,callback):
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Progress.hx:92
        return self.future.handle(callback)

    def listen(self,callback):
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Progress.hx:95
        return self.signal.listen(callback)

    def gather(self):
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Progress.hx:98
        return self.future.gather()

    def eager(self):
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Progress.hx:101
        return self.future.eager()

tink_core_CompositeProgress._hx_class = tink_core_CompositeProgress


class tink_core_ProgressTrigger(tink_core_CompositeProgress):
    _hx_class_name = "tink.core.ProgressTrigger"
    _hx_is_interface = "False"
    __slots__ = ("futureTrigger", "signalTrigger", "value")
    _hx_fields = ["futureTrigger", "signalTrigger", "value"]
    _hx_methods = ["progress", "finish", "asProgress"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = tink_core_CompositeProgress


    def __init__(self):
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Progress.hx:110
        self.signalTrigger = None
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Progress.hx:109
        self.futureTrigger = None
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Progress.hx:112
        self.value = tink_core_ProgressType.InProgress(tink_core__Progress_Progress_Impl_.INIT)
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Progress.hx:115
        def _hx_local_0():
            # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Progress.hx:115
            self.futureTrigger = tink_core_FutureTrigger()
            return self.futureTrigger
        def _hx_local_1():
            self.signalTrigger = tink_core__Signal_Signal_Impl_.trigger()
            return self.signalTrigger
        super().__init__(_hx_local_0(),_hx_local_1())

    def progress(self,v,total):
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Progress.hx:119
        _g = self.value
        tmp = _g.index
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Progress.hx:122
        if (tmp == 0):
            # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Progress.hx:122
            current = _g.params[0]
            # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Progress.hx:123
            if ((current.a != v) or (not tink_core_TotalTools.eq(current.b,total))):
                # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Progress.hx:124
                this1 = tink_core_MPair(v,total)
                pv = this1
                # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Progress.hx:125
                self.value = tink_core_ProgressType.InProgress(pv)
                # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Progress.hx:126
                self.signalTrigger.handlers.invoke(pv)
        elif (tmp == 1):
            _g2 = _g.params[0]
        else:
            pass

    def finish(self,v):
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Progress.hx:132
        _g = self.value
        if (_g.index == 1):
            _g1 = _g.params[0]
        else:
            # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Progress.hx:137
            self.value = tink_core_ProgressType.Finished(v)
            # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Progress.hx:138
            self.futureTrigger.trigger(v)

    def asProgress(self):
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Progress.hx:143
        return self

tink_core_ProgressTrigger._hx_class = tink_core_ProgressTrigger


class tink_core_FutureProgress(tink_core_CompositeProgress):
    _hx_class_name = "tink.core.FutureProgress"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_fields = []
    _hx_methods = []
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = tink_core_CompositeProgress


    def __init__(self,future):
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Progress.hx:149
        def _hx_local_0(progress):
            # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Progress.hx:149
            return progress
        ret = future.flatMap(_hx_local_0)
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Progress.hx:150
        def _hx_local_2(cb):
            # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Progress.hx:150
            def _hx_local_1(progress1):
                # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Progress.hx:150
                progress1.listen(cb)
            future.handle(_hx_local_1)
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Progress.hx:148
        super().__init__(ret.gather(),tink_core__Signal_Signal_Impl_.generate(_hx_local_2))
tink_core_FutureProgress._hx_class = tink_core_FutureProgress


class tink_core_PromiseProgress(tink_core_CompositeProgress):
    _hx_class_name = "tink.core.PromiseProgress"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_fields = []
    _hx_methods = []
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = tink_core_CompositeProgress


    def __init__(self,promise):
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Progress.hx:158
        def _hx_local_0(o):
            # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Progress.hx:158
            ret1 = o.index
            # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Progress.hx:159
            if (ret1 == 0):
                # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Progress.hx:159
                progress = o.params[0]
                return progress.map(tink_core_Outcome.Success)
            elif (ret1 == 1):
                # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Progress.hx:160
                e = o.params[0]
                return tink_core__Future_SyncFuture(tink_core__Lazy_LazyConst(tink_core_Outcome.Failure(e)))
            else:
                pass
        ret = promise.flatMap(_hx_local_0)
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Progress.hx:162
        def _hx_local_2(cb):
            # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Progress.hx:162
            def _hx_local_1(o1):
                # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Progress.hx:162
                tmp = o1.index
                # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Progress.hx:163
                if (tmp == 0):
                    # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Progress.hx:163
                    progress1 = o1.params[0]
                    progress1.listen(cb)
                elif (tmp == 1):
                    e1 = o1.params[0]
                else:
                    pass
            promise.handle(_hx_local_1)
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Progress.hx:157
        super().__init__(ret.gather(),tink_core__Signal_Signal_Impl_.generate(_hx_local_2))
tink_core_PromiseProgress._hx_class = tink_core_PromiseProgress


class tink_core__Progress_ProgressValue_Impl_:
    _hx_class_name = "tink.core._Progress.ProgressValue_Impl_"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["_new", "normalize", "get_value", "get_total"]
    value = None
    total = None

    @staticmethod
    def _new(value,total):
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Progress.hx:176
        this1 = tink_core_MPair(value,total)
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Progress.hx:175
        this2 = this1
        return this2

    @staticmethod
    def normalize(this1):
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Progress.hx:182
        o = this1.b
        if (o.index == 0):
            v = o.params[0]
            return haxe_ds_Option.Some((this1.a / v))
        else:
            return haxe_ds_Option._hx_None

    @staticmethod
    def get_value(this1):
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Progress.hx:185
        return this1.a

    @staticmethod
    def get_total(this1):
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Progress.hx:188
        return this1.b
tink_core__Progress_ProgressValue_Impl_._hx_class = tink_core__Progress_ProgressValue_Impl_


class tink_core__Progress_UnitInterval_Impl_:
    _hx_class_name = "tink.core._Progress.UnitInterval_Impl_"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["toPercentageString"]

    @staticmethod
    def toPercentageString(this1,dp):
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Progress.hx:193
        m = Math.pow(10,dp)
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Progress.hx:194
        v = (Math.floor((((this1 * m) * 100) + 0.5)) / m)
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Progress.hx:195
        s = Std.string(v)
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Progress.hx:196
        startIndex = None
        _g = (s.find(".") if ((startIndex is None)) else s.find(".", startIndex))
        if (_g == -1):
            return (((("null" if s is None else s) + ".") + HxOverrides.stringOrNull(StringTools.lpad("","0",dp))) + "%")
        else:
            # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Progress.hx:198
            i = _g
            if ((len(s) - i) > dp):
                return (HxOverrides.stringOrNull(HxString.substr(s,0,((dp + i) + 1))) + "%")
            else:
                # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Progress.hx:199
                i1 = _g
                return (HxOverrides.stringOrNull(StringTools.rpad(s,"0",((i1 + dp) + 1))) + "%")
tink_core__Progress_UnitInterval_Impl_._hx_class = tink_core__Progress_UnitInterval_Impl_

class tink_core_ProgressType(Enum):
    __slots__ = ()
    _hx_class_name = "tink.core.ProgressType"
    _hx_constructs = ["InProgress", "Finished"]

    @staticmethod
    def InProgress(v):
        return tink_core_ProgressType("InProgress", 0, (v,))

    @staticmethod
    def Finished(v):
        return tink_core_ProgressType("Finished", 1, (v,))
tink_core_ProgressType._hx_class = tink_core_ProgressType


class tink_core_TotalTools:
    _hx_class_name = "tink.core.TotalTools"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["eq"]

    @staticmethod
    def eq(a,b):
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Progress.hx:211
        tmp = a.index
        if (tmp == 0):
            if (b.index == 0):
                # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Progress.hx:212
                t1 = a.params[0]
                t2 = b.params[0]
                return (t1 == t2)
            else:
                return False
        elif (tmp == 1):
            if (b.index == 1):
                return True
            else:
                return False
        else:
            pass
tink_core_TotalTools._hx_class = tink_core_TotalTools


class tink_core__Promise_Promise_Impl_:
    _hx_class_name = "tink.core._Promise.Promise_Impl_"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["NULL", "NOISE", "NEVER", "_new", "eager", "map", "flatMap", "tryRecover", "recover", "mapError", "handle", "noise", "isSuccess", "next", "swap", "swapError", "merge", "and", "iterate", "retry", "ofSpecific", "ofFuture", "ofOutcome", "ofError", "ofData", "lazy", "inParallel", "inSequence", "cache", "lift", "trigger", "resolve", "reject"]

    @staticmethod
    def _new(f,lazy = None):
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Promise.hx:16
        if (lazy is None):
            lazy = False
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Promise.hx:18
        def _hx_local_2(cb):
            # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Promise.hx:18
            def _hx_local_0(v):
                # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Promise.hx:18
                cb(tink_core_Outcome.Success(v))
            def _hx_local_1(e):
                cb(tink_core_Outcome.Failure(e))
            f(_hx_local_0,_hx_local_1)
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Promise.hx:16
        this1 = tink_core__Future_Future_Impl_.make(_hx_local_2,lazy)
        return this1

    @staticmethod
    def eager(this1):
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Promise.hx:23
        return this1.eager()

    @staticmethod
    def map(this1,f):
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Promise.hx:26
        ret = this1.map(f)
        return ret.gather()

    @staticmethod
    def flatMap(this1,f):
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Promise.hx:29
        ret = this1.flatMap(f)
        return ret.gather()

    @staticmethod
    def tryRecover(this1,f):
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Promise.hx:32
        def _hx_local_0(o):
            # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Promise.hx:32
            ret1 = o.index
            # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Promise.hx:33
            if (ret1 == 0):
                # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Promise.hx:33
                d = o.params[0]
                return tink_core__Future_SyncFuture(tink_core__Lazy_LazyConst(o))
            elif (ret1 == 1):
                # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Promise.hx:34
                e = o.params[0]
                return f(e)
            else:
                pass
        ret = this1.flatMap(_hx_local_0)
        return ret.gather()

    @staticmethod
    def recover(this1,f):
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Promise.hx:38
        def _hx_local_0(o):
            # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Promise.hx:38
            ret1 = o.index
            # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Promise.hx:39
            if (ret1 == 0):
                # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Promise.hx:39
                d = o.params[0]
                return tink_core__Future_SyncFuture(tink_core__Lazy_LazyConst(d))
            elif (ret1 == 1):
                # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Promise.hx:40
                e = o.params[0]
                return f(e)
            else:
                pass
        ret = this1.flatMap(_hx_local_0)
        return ret.gather()

    @staticmethod
    def mapError(this1,f):
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Promise.hx:44
        def _hx_local_0(o):
            # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Promise.hx:44
            ret1 = o.index
            # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Promise.hx:45
            if (ret1 == 0):
                # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Promise.hx:45
                _g = o.params[0]
                return o
            elif (ret1 == 1):
                # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Promise.hx:46
                e = o.params[0]
                return tink_core_Outcome.Failure(f(e))
            else:
                pass
        ret = this1.map(_hx_local_0)
        return ret.gather()

    @staticmethod
    def handle(this1,cb):
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Promise.hx:50
        return this1.handle(cb)

    @staticmethod
    def noise(this1):
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Promise.hx:53
        def _hx_local_1():
            # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Promise.hx:53
            def _hx_local_0(v):
                # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Promise.hx:53
                return tink_core__Future_SyncFuture(tink_core__Lazy_LazyConst(tink_core_Outcome.Success(tink_core_Noise.Noise)))
            return tink_core__Promise_Promise_Impl_.next(this1,_hx_local_0)
        return _hx_local_1()

    @staticmethod
    def isSuccess(this1):
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Promise.hx:56
        def _hx_local_0(o):
            # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Promise.hx:56
            return tink_core_OutcomeTools.isSuccess(o)
        ret = this1.map(_hx_local_0)
        return ret.gather()

    @staticmethod
    def next(this1,f,gather = None):
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Promise.hx:59
        if (gather is None):
            gather = True
        gather1 = gather
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Future.hx:50
        if (gather1 is None):
            gather1 = True
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Promise.hx:59
        def _hx_local_0(o):
            # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Promise.hx:59
            ret1 = o.index
            # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Promise.hx:60
            if (ret1 == 0):
                # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Promise.hx:60
                d = o.params[0]
                return f(d)
            elif (ret1 == 1):
                # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Promise.hx:61
                f1 = o.params[0]
                return tink_core__Future_SyncFuture(tink_core__Lazy_LazyConst(tink_core_Outcome.Failure(f1)))
            else:
                pass
        ret = this1.flatMap(_hx_local_0)
        if gather1:
            return ret.gather()
        else:
            return ret

    @staticmethod
    def swap(this1,v):
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Promise.hx:65
        def _hx_local_1():
            # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Promise.hx:65
            def _hx_local_0(_):
                # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Promise.hx:65
                return v
            return tink_core__Future_Future_Impl_._tryMap(this1,_hx_local_0)
        return _hx_local_1()

    @staticmethod
    def swapError(this1,e):
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Promise.hx:68
        def _hx_local_1():
            # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Promise.hx:68
            def _hx_local_0(_):
                # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Promise.hx:68
                return e
            return tink_core__Promise_Promise_Impl_.mapError(this1,_hx_local_0)
        return _hx_local_1()

    @staticmethod
    def merge(this1,other,merger,gather = None):
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Promise.hx:71
        if (gather is None):
            gather = True
        def _hx_local_3():
            def _hx_local_2(t):
                def _hx_local_1():
                    def _hx_local_0(a):
                        return merger(t,a)
                    return tink_core__Promise_Promise_Impl_.next(other,_hx_local_0,False)
                return _hx_local_1()
            return tink_core__Promise_Promise_Impl_.next(this1,_hx_local_2,gather)
        return _hx_local_3()

    @staticmethod
    def _hx_and(a,b):
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Promise.hx:74
        def _hx_local_1():
            # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Promise.hx:74
            def _hx_local_0(a1,b1):
                # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Promise.hx:74
                this1 = tink_core_MPair(a1,b1)
                return tink_core__Future_SyncFuture(tink_core__Lazy_LazyConst(tink_core_Outcome.Success(this1)))
            return tink_core__Promise_Promise_Impl_.merge(a,b,_hx_local_0)
        return _hx_local_1()

    @staticmethod
    def iterate(promises,_hx_yield,fallback,lazy = None):
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Promise.hx:95
        def _hx_local_4():
            # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Promise.hx:95
            def _hx_local_3(cb):
                # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Promise.hx:96
                _hx_iter = HxOverrides.iterator(promises)
                # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Promise.hx:97
                next = None
                # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Promise.hx:98
                def _hx_local_2():
                    # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Promise.hx:98
                    if _hx_iter.hasNext():
                        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Promise.hx:99
                        def _hx_local_1(o):
                            # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Promise.hx:99
                            next1 = o.index
                            # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Promise.hx:100
                            if (next1 == 0):
                                # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Promise.hx:100
                                v = o.params[0]
                                # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Promise.hx:101
                                def _hx_local_0(o1):
                                    # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Promise.hx:101
                                    next2 = o1.index
                                    # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Promise.hx:103
                                    if (next2 == 0):
                                        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Promise.hx:103
                                        _g = o1.params[0]
                                        next3 = _g.index
                                        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Promise.hx:102
                                        if (next3 == 0):
                                            # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Promise.hx:102
                                            ret = _g.params[0]
                                            cb(tink_core_Outcome.Success(ret))
                                        elif (next3 == 1):
                                            next()
                                        else:
                                            pass
                                    elif (next2 == 1):
                                        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Promise.hx:104
                                        e = o1.params[0]
                                        cb(tink_core_Outcome.Failure(e))
                                    else:
                                        pass
                                _hx_yield(v).handle(_hx_local_0)
                            elif (next1 == 1):
                                # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Promise.hx:106
                                e1 = o.params[0]
                                # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Promise.hx:107
                                cb(tink_core_Outcome.Failure(e1))
                            else:
                                pass
                        _hx_iter.next().handle(_hx_local_1)
                    else:
                        fallback.handle(cb)
                # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Promise.hx:97
                next = _hx_local_2
                # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Promise.hx:112
                next()
            return tink_core__Future_Future_Impl_.make(_hx_local_3,lazy)
        return _hx_local_4()

    @staticmethod
    def retry(gen,next):
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Promise.hx:155
        def _hx_local_0():
            # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Promise.hx:155
            return (python_lib_Timeit.default_timer() * 1000)
        stamp = _hx_local_0
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Promise.hx:156
        start = stamp()
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Promise.hx:157
        attempt = None
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Promise.hx:158
        def _hx_local_5(count):
            # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Promise.hx:160
            def _hx_local_3(error):
                # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Promise.hx:160
                f1 = (stamp() - start)
                def _hx_local_2():
                    # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Promise.hx:161
                    def _hx_local_1(_):
                        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Promise.hx:161
                        return attempt((count + 1))
                    # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Promise.hx:160
                    return tink_core__Promise_Promise_Impl_.next(next(_hx_AnonObject({'attempt': count, 'error': error, 'elapsed': f1})),_hx_local_1)
                return _hx_local_2()
            # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Promise.hx:158
            f = _hx_local_3
            def _hx_local_4(o):
                ret1 = o.index
                if (ret1 == 0):
                    d = o.params[0]
                    return tink_core__Future_SyncFuture(tink_core__Lazy_LazyConst(o))
                elif (ret1 == 1):
                    e = o.params[0]
                    return f(e)
                else:
                    pass
            ret = gen().flatMap(_hx_local_4)
            return ret.gather()
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Promise.hx:157
        attempt = _hx_local_5
        return attempt(1)

    @staticmethod
    def ofSpecific(s):
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Promise.hx:180
        return s

    @staticmethod
    def ofFuture(f):
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Promise.hx:183
        ret = f.map(tink_core_Outcome.Success)
        return ret.gather()

    @staticmethod
    def ofOutcome(o):
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Promise.hx:186
        return tink_core__Future_SyncFuture(tink_core__Lazy_LazyConst(o))

    @staticmethod
    def ofError(e):
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Promise.hx:189
        return tink_core__Future_SyncFuture(tink_core__Lazy_LazyConst(tink_core_Outcome.Failure(e)))

    @staticmethod
    def ofData(d):
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Promise.hx:192
        return tink_core__Future_SyncFuture(tink_core__Lazy_LazyConst(tink_core_Outcome.Success(d)))

    @staticmethod
    def lazy(p):
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Promise.hx:195
        def _hx_local_1():
            # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Promise.hx:195
            def _hx_local_0(cb):
                # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Promise.hx:195
                p.get().handle(cb)
            return tink_core__Future_Future_Impl_.make(_hx_local_0,True)
        return _hx_local_1()

    @staticmethod
    def inParallel(a,concurrency = None,lazy = None):
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Promise.hx:199
        if (len(a) == 0):
            return tink_core__Future_SyncFuture(tink_core__Lazy_LazyConst(tink_core_Outcome.Success([])))
        else:
            # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Promise.hx:200
            def _hx_local_10():
                # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Promise.hx:200
                def _hx_local_9(cb):
                    # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Promise.hx:200
                    nonlocal concurrency
                    # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Promise.hx:201
                    result = []
                    pending = len(a)
                    links = None
                    linkArray = []
                    sync = False
                    i = 0
                    _hx_iter = python_HaxeIterator(a.__iter__())
                    next = None
                    # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Promise.hx:210
                    def _hx_local_0(o):
                        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Promise.hx:210
                        nonlocal sync
                        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Promise.hx:211
                        if (links is None):
                            sync = True
                        elif (links is not None):
                            links.cancel()
                        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Promise.hx:213
                        cb(o)
                    done = _hx_local_0
                    # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Promise.hx:216
                    def _hx_local_1(e):
                        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Promise.hx:216
                        nonlocal pending
                        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Promise.hx:217
                        pending = 0
                        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Promise.hx:218
                        done(tink_core_Outcome.Failure(e))
                    fail = _hx_local_1
                    # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Promise.hx:225
                    def _hx_local_4(index,value):
                        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Promise.hx:226
                        python_internal_ArrayImpl._set(result, index, value)
                        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Promise.hx:227
                        def _hx_local_3():
                            # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Promise.hx:227
                            nonlocal pending
                            pending = (pending - 1)
                            return pending
                        if ((_hx_local_3()) == 0):
                            done(tink_core_Outcome.Success(result))
                        elif (_hx_iter.hasNext() and ((pending > 0))):
                            next()
                    _hx_set = _hx_local_4
                    # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Promise.hx:233
                    def _hx_local_7():
                        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Promise.hx:233
                        nonlocal i
                        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Promise.hx:234
                        i = (i + 1)
                        index1 = (i - 1)
                        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Promise.hx:235
                        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Promise.hx:235
                        def _hx_local_6(o1):
                            # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Promise.hx:235
                            x1 = o1.index
                            # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Promise.hx:236
                            if (x1 == 0):
                                # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Promise.hx:236
                                v = o1.params[0]
                                _hx_set(index1,v)
                            elif (x1 == 1):
                                # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Promise.hx:237
                                e1 = o1.params[0]
                                fail(e1)
                            else:
                                pass
                        x = _hx_iter.next().handle(_hx_local_6)
                        linkArray.append(x)
                    next = _hx_local_7
                    # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Promise.hx:241
                    while True:
                        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Promise.hx:241
                        tmp = None
                        if (_hx_iter.hasNext() and ((pending > 0))):
                            if (concurrency is not None):
                                concurrency = (concurrency - 1)
                                tmp = ((concurrency + 1) > 0)
                            else:
                                tmp = True
                        else:
                            tmp = False
                        if (not tmp):
                            break
                        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Promise.hx:242
                        next()
                    # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Promise.hx:245
                    links = tink_core__Callback_CallbackLink_Impl_.fromMany(linkArray)
                    # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Promise.hx:247
                    if sync:
                        if (links is not None):
                            links.cancel()
                return tink_core__Future_Future_Impl_.make(_hx_local_9,lazy)
            return _hx_local_10()

    @staticmethod
    def inSequence(a):
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Promise.hx:253
        loop = None
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Promise.hx:255
        def _hx_local_4(index):
            # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Promise.hx:255
            if (index == len(a)):
                return tink_core__Future_SyncFuture(tink_core__Lazy_LazyConst(tink_core_Outcome.Success([])))
            else:
                # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Promise.hx:257
                def _hx_local_3():
                    # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Promise.hx:258
                    def _hx_local_2(head):
                        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Promise.hx:258
                        def _hx_local_1():
                            # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Promise.hx:259
                            def _hx_local_0(tail):
                                # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Promise.hx:259
                                return tink_core__Future_SyncFuture(tink_core__Lazy_LazyConst(tink_core_Outcome.Success(([head] + tail))))
                            # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Promise.hx:258
                            return tink_core__Promise_Promise_Impl_.next(loop((index + 1)),_hx_local_0)
                        return _hx_local_1()
                    # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Promise.hx:257
                    return tink_core__Promise_Promise_Impl_.next((a[index] if index >= 0 and index < len(a) else None),_hx_local_2)
                return _hx_local_3()
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Promise.hx:253
        loop = _hx_local_4
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Promise.hx:264
        return loop(0)

    @staticmethod
    def cache(gen):
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Promise.hx:269
        p = None
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Promise.hx:270
        def _hx_local_0():
            # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Promise.hx:270
            nonlocal p
            # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Promise.hx:271
            ret = p
            # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Promise.hx:272
            if (ret is None):
                # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Promise.hx:273
                sync = False
                # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Promise.hx:274
                def _hx_local_2(o):
                    # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Promise.hx:275
                    def _hx_local_1(_):
                        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Promise.hx:275
                        nonlocal sync
                        nonlocal p
                        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Promise.hx:276
                        sync = True
                        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Promise.hx:277
                        p = None
                    o.b.handle(_hx_local_1)
                    # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Promise.hx:279
                    return tink_core__Future_SyncFuture(tink_core__Lazy_LazyConst(tink_core_Outcome.Success(o.a)))
                ret = tink_core__Promise_Promise_Impl_.next(gen(),_hx_local_2)
                # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Promise.hx:281
                if (not sync):
                    p = ret
            # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Promise.hx:283
            def _hx_local_3(o1):
                # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Promise.hx:283
                nonlocal p
                # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Promise.hx:284
                if (not tink_core_OutcomeTools.isSuccess(o1)):
                    p = None
                # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Promise.hx:285
                return o1
            ret1 = ret.map(_hx_local_3)
            return ret1.gather()
        return _hx_local_0

    @staticmethod
    def lift(p):
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Promise.hx:293
        return p

    @staticmethod
    def trigger():
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Promise.hx:300
        this1 = tink_core_FutureTrigger()
        return this1

    @staticmethod
    def resolve(v):
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Promise.hx:304
        return tink_core__Future_SyncFuture(tink_core__Lazy_LazyConst(tink_core_Outcome.Success(v)))

    @staticmethod
    def reject(e):
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Promise.hx:308
        return tink_core__Future_SyncFuture(tink_core__Lazy_LazyConst(tink_core_Outcome.Failure(e)))
tink_core__Promise_Promise_Impl_._hx_class = tink_core__Promise_Promise_Impl_


class tink_core__Promise_Next_Impl_:
    _hx_class_name = "tink.core._Promise.Next_Impl_"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["ofSafe", "ofSync", "ofSafeSync", "_chain"]

    @staticmethod
    def ofSafe(f):
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Promise.hx:321
        def _hx_local_0(x):
            # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Promise.hx:321
            return tink_core__Future_SyncFuture(tink_core__Lazy_LazyConst(f(x)))
        return _hx_local_0

    @staticmethod
    def ofSync(f):
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Promise.hx:324
        def _hx_local_0(x):
            # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Promise.hx:324
            ret = f(x).map(tink_core_Outcome.Success)
            return ret.gather()
        return _hx_local_0

    @staticmethod
    def ofSafeSync(f):
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Promise.hx:327
        def _hx_local_0(x):
            # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Promise.hx:327
            return tink_core__Future_SyncFuture(tink_core__Lazy_LazyConst(tink_core_Outcome.Success(f(x))))
        return _hx_local_0

    @staticmethod
    def _chain(a,b):
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Promise.hx:330
        def _hx_local_0(v):
            # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Promise.hx:330
            return tink_core__Promise_Promise_Impl_.next(a(v),b)
        return _hx_local_0
tink_core__Promise_Next_Impl_._hx_class = tink_core__Promise_Next_Impl_


class tink_core__Promise_Recover_Impl_:
    _hx_class_name = "tink.core._Promise.Recover_Impl_"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["ofSync"]

    @staticmethod
    def ofSync(f):
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Promise.hx:339
        def _hx_local_0(e):
            # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Promise.hx:339
            return tink_core__Future_SyncFuture(tink_core__Lazy_LazyConst(f(e)))
        return _hx_local_0
tink_core__Promise_Recover_Impl_._hx_class = tink_core__Promise_Recover_Impl_


class tink_core__Promise_Combiner_Impl_:
    _hx_class_name = "tink.core._Promise.Combiner_Impl_"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["ofSafe", "ofSync", "ofSafeSync"]

    @staticmethod
    def ofSafe(f):
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Promise.hx:346
        def _hx_local_0(x1,x2):
            # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Promise.hx:346
            return tink_core__Future_SyncFuture(tink_core__Lazy_LazyConst(f(x1,x2)))
        return _hx_local_0

    @staticmethod
    def ofSync(f):
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Promise.hx:349
        def _hx_local_0(x1,x2):
            # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Promise.hx:349
            ret = f(x1,x2).map(tink_core_Outcome.Success)
            return ret.gather()
        return _hx_local_0

    @staticmethod
    def ofSafeSync(f):
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Promise.hx:352
        def _hx_local_0(x1,x2):
            # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Promise.hx:352
            return tink_core__Future_SyncFuture(tink_core__Lazy_LazyConst(tink_core_Outcome.Success(f(x1,x2))))
        return _hx_local_0
tink_core__Promise_Combiner_Impl_._hx_class = tink_core__Promise_Combiner_Impl_


class tink_core__Promise_PromiseTrigger_Impl_:
    _hx_class_name = "tink.core._Promise.PromiseTrigger_Impl_"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["_new", "resolve", "reject", "asPromise"]

    @staticmethod
    def _new():
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Promise.hx:358
        this1 = tink_core_FutureTrigger()
        return this1

    @staticmethod
    def resolve(this1,v):
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Promise.hx:359
        return this1.trigger(tink_core_Outcome.Success(v))

    @staticmethod
    def reject(this1,e):
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Promise.hx:360
        return this1.trigger(tink_core_Outcome.Failure(e))

    @staticmethod
    def asPromise(this1):
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Promise.hx:361
        return this1
tink_core__Promise_PromiseTrigger_Impl_._hx_class = tink_core__Promise_PromiseTrigger_Impl_


class tink_core__Ref_Ref_Impl_:
    _hx_class_name = "tink.core._Ref.Ref_Impl_"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["_new", "get_value", "set_value", "toString", "to"]
    value = None

    @staticmethod
    def _new():
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Ref.hx:6
        this1 = [None]*1
        this2 = this1
        return this2

    @staticmethod
    def get_value(this1):
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Ref.hx:8
        return this1[0]

    @staticmethod
    def set_value(this1,param):
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Ref.hx:9
        this1[0] = param
        return param

    @staticmethod
    def toString(this1):
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Ref.hx:11
        return (("@[" + Std.string(this1[0])) + "]")

    @staticmethod
    def to(v):
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Ref.hx:14
        this1 = [None]*1
        this2 = this1
        ret = this2
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Ref.hx:15
        ret[0] = v
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Ref.hx:16
        return ret
tink_core__Ref_Ref_Impl_._hx_class = tink_core__Ref_Ref_Impl_


class tink_core__Signal_Signal_Impl_:
    _hx_class_name = "tink.core._Signal.Signal_Impl_"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["_new", "handle", "map", "flatMap", "filter", "select", "join", "nextTime", "until", "next", "noise", "gather", "generate", "trigger", "create", "ofClassical"]

    @staticmethod
    def _new(f):
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Signal.hx:9
        this1 = tink_core__Signal_SimpleSignal(f)
        return this1

    @staticmethod
    def handle(this1,handler):
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Signal.hx:12
        return this1.listen(handler)

    @staticmethod
    def map(this1,f,gather = None):
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Signal.hx:18
        if (gather is None):
            gather = True
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Signal.hx:19
        def _hx_local_2(cb):
            # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Signal.hx:19
            def _hx_local_1():
                # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Signal.hx:19
                def _hx_local_0(result):
                    # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Signal.hx:19
                    this3 = f(result)
                    tink_core__Callback_Callback_Impl_.invoke(cb,this3)
                return this1.listen(_hx_local_0)
            return _hx_local_1()
        this2 = tink_core__Signal_SimpleSignal(_hx_local_2)
        ret = this2
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Signal.hx:21
        if gather:
            return tink_core__Signal_Signal_Impl_.gather(ret)
        else:
            return ret

    @staticmethod
    def flatMap(this1,f,gather = None):
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Signal.hx:29
        if (gather is None):
            gather = True
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Signal.hx:30
        def _hx_local_2(cb):
            # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Signal.hx:30
            def _hx_local_1():
                # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Signal.hx:30
                def _hx_local_0(result):
                    # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Signal.hx:30
                    f(result).handle(cb)
                return this1.listen(_hx_local_0)
            return _hx_local_1()
        this2 = tink_core__Signal_SimpleSignal(_hx_local_2)
        ret = this2
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Signal.hx:32
        if gather:
            return tink_core__Signal_Signal_Impl_.gather(ret)
        else:
            return ret

    @staticmethod
    def filter(this1,f,gather = None):
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Signal.hx:39
        if (gather is None):
            gather = True
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Signal.hx:40
        def _hx_local_2(cb):
            # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Signal.hx:40
            def _hx_local_1():
                # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Signal.hx:40
                def _hx_local_0(result):
                    # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Signal.hx:40
                    if f(result):
                        tink_core__Callback_Callback_Impl_.invoke(cb,result)
                return this1.listen(_hx_local_0)
            return _hx_local_1()
        this2 = tink_core__Signal_SimpleSignal(_hx_local_2)
        ret = this2
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Signal.hx:42
        if gather:
            return tink_core__Signal_Signal_Impl_.gather(ret)
        else:
            return ret

    @staticmethod
    def select(this1,selector,gather = None):
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Signal.hx:46
        if (gather is None):
            gather = True
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Signal.hx:47
        def _hx_local_2(cb):
            # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Signal.hx:47
            def _hx_local_1():
                # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Signal.hx:47
                def _hx_local_0(result):
                    # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Signal.hx:47
                    _g = selector(result)
                    this3 = _g.index
                    # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Signal.hx:48
                    if (this3 == 0):
                        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Signal.hx:48
                        v = _g.params[0]
                        tink_core__Callback_Callback_Impl_.invoke(cb,v)
                    elif (this3 == 1):
                        pass
                    else:
                        pass
                return this1.listen(_hx_local_0)
            return _hx_local_1()
        this2 = tink_core__Signal_SimpleSignal(_hx_local_2)
        ret = this2
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Signal.hx:52
        if gather:
            return tink_core__Signal_Signal_Impl_.gather(ret)
        else:
            return ret

    @staticmethod
    def join(this1,other,gather = None):
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Signal.hx:60
        if (gather is None):
            gather = True
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Signal.hx:63
        def _hx_local_0(cb):
            # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Signal.hx:63
            return tink_core__Callback_LinkPair(this1.listen(cb),other.listen(cb))
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Signal.hx:61
        this2 = tink_core__Signal_SimpleSignal(_hx_local_0)
        ret = this2
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Signal.hx:66
        if gather:
            return tink_core__Signal_Signal_Impl_.gather(ret)
        else:
            return ret

    @staticmethod
    def nextTime(this1,condition = None):
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Signal.hx:74
        ret = tink_core_FutureTrigger()
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Signal.hx:75
        link = None
        immediate = False
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Signal.hx:78
        def _hx_local_0(v):
            # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Signal.hx:78
            nonlocal immediate
            if ((condition is None) or condition(v)):
                # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Signal.hx:79
                ret.trigger(v)
                # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Signal.hx:80
                if (link is None):
                    immediate = True
                elif (link is not None):
                    link.cancel()
        link = this1.listen(_hx_local_0)
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Signal.hx:84
        if immediate:
            if (link is not None):
                link.cancel()
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Signal.hx:87
        return ret

    @staticmethod
    def until(this1,end):
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Signal.hx:92
        def _hx_local_0(_hx_yield):
            # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Signal.hx:92
            this2 = this1.listen(_hx_yield)
            if (this2 is None):
                return tink_core__Callback_CallbackLink_Impl_.noop
            else:
                return this2.cancel
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Signal.hx:91
        ret = tink_core__Signal_Suspendable(_hx_local_0)
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Signal.hx:94
        end.handle(tink_core__Callback_Callback_Impl_.fromNiladic(ret.kill))
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Signal.hx:95
        return ret

    @staticmethod
    def next(this1,condition = None):
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Signal.hx:100
        return tink_core__Signal_Signal_Impl_.nextTime(this1,condition)

    @staticmethod
    def noise(this1):
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Signal.hx:106
        def _hx_local_1():
            # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Signal.hx:106
            def _hx_local_0(_):
                # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Signal.hx:106
                return tink_core_Noise.Noise
            return tink_core__Signal_Signal_Impl_.map(this1,_hx_local_0)
        return _hx_local_1()

    @staticmethod
    def gather(this1):
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Signal.hx:114
        ret = tink_core__Signal_Signal_Impl_.trigger()
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Signal.hx:115
        def _hx_local_0(x):
            # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Signal.hx:115
            ret.handlers.invoke(x)
        this1.listen(_hx_local_0)
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Signal.hx:116
        return ret

    @staticmethod
    def generate(generator):
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Signal.hx:120
        ret = tink_core__Signal_Signal_Impl_.trigger()
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Signal.hx:121
        generator(ret.trigger)
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Signal.hx:122
        return ret

    @staticmethod
    def trigger():
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Signal.hx:129
        return tink_core_SignalTrigger()

    @staticmethod
    def create(create):
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Signal.hx:132
        return tink_core__Signal_Suspendable(create)

    @staticmethod
    def ofClassical(add,remove,gather = None):
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Signal.hx:138
        if (gather is None):
            gather = True
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Signal.hx:139
        def _hx_local_2(cb):
            # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Signal.hx:140
            def _hx_local_0(a):
                # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Signal.hx:140
                tink_core__Callback_Callback_Impl_.invoke(cb,a)
            f = _hx_local_0
            # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Signal.hx:141
            add(f)
            # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Signal.hx:142
            f1 = remove
            a1 = f
            def _hx_local_1():
                f1(a1)
            this2 = tink_core_SimpleLink(_hx_local_1)
            return this2
        this1 = tink_core__Signal_SimpleSignal(_hx_local_2)
        ret = this1
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Signal.hx:146
        if gather:
            return tink_core__Signal_Signal_Impl_.gather(ret)
        else:
            return ret
tink_core__Signal_Signal_Impl_._hx_class = tink_core__Signal_Signal_Impl_


class tink_core__Signal_SimpleSignal:
    _hx_class_name = "tink.core._Signal.SimpleSignal"
    _hx_is_interface = "False"
    __slots__ = ("f",)
    _hx_fields = ["f"]
    _hx_methods = ["listen"]
    _hx_interfaces = [tink_core_SignalObject]

    def __init__(self,f):
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Signal.hx:153
        self.f = f

    def listen(self,cb):
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Signal.hx:154
        return self.f(cb)

tink_core__Signal_SimpleSignal._hx_class = tink_core__Signal_SimpleSignal


class tink_core__Signal_Suspendable:
    _hx_class_name = "tink.core._Signal.Suspendable"
    _hx_is_interface = "False"
    __slots__ = ("trigger", "activate", "suspend", "check", "killed")
    _hx_fields = ["trigger", "activate", "suspend", "check", "killed"]
    _hx_methods = ["kill", "listen"]
    _hx_interfaces = [tink_core_SignalObject]

    def __init__(self,activate):
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Signal.hx:161
        self.check = None
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Signal.hx:160
        self.suspend = None
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Signal.hx:163
        self.killed = False
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Signal.hx:158
        self.trigger = tink_core_SignalTrigger()
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Signal.hx:172
        self.activate = activate

    def kill(self):
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Signal.hx:166
        if (not self.killed):
            # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Signal.hx:167
            self.killed = True
            # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Signal.hx:168
            self.trigger = None

    def listen(self,cb):
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Signal.hx:175
        _gthis = self
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Signal.hx:176
        if self.killed:
            return None
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Signal.hx:177
        if (self.trigger.handlers.used == 0):
            self.suspend = self.activate(self.trigger.trigger)
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Signal.hx:181
        _this = self.trigger.handlers
        node = tink_core__Callback_ListCell(cb,_this)
        _this1 = _this.cells
        _this1.append(node)
        _this.used = (_this.used + 1)
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Signal.hx:183
        def _hx_local_1():
            # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Signal.hx:183
            if (_gthis.trigger.handlers.used == 0):
                # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Signal.hx:184
                _gthis.suspend()
                # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Signal.hx:185
                _gthis.suspend = None
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Signal.hx:181
        this1 = tink_core_SimpleLink(_hx_local_1)
        return tink_core__Callback_LinkPair(node,this1)

tink_core__Signal_Suspendable._hx_class = tink_core__Signal_Suspendable


class tink_core_SignalTrigger:
    _hx_class_name = "tink.core.SignalTrigger"
    _hx_is_interface = "False"
    __slots__ = ("handlers",)
    _hx_fields = ["handlers"]
    _hx_methods = ["trigger", "getLength", "listen", "clear", "asSignal"]
    _hx_interfaces = [tink_core_SignalObject]

    def __init__(self):
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Signal.hx:191
        self.handlers = tink_core_CallbackList()

    def trigger(self,event):
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Signal.hx:198
        self.handlers.invoke(event)

    def getLength(self):
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Signal.hx:204
        return self.handlers.used

    def listen(self,cb):
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Signal.hx:207
        _this = self.handlers
        node = tink_core__Callback_ListCell(cb,_this)
        _this1 = _this.cells
        _this1.append(node)
        _this.used = (_this.used + 1)
        return node

    def clear(self):
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Signal.hx:213
        self.handlers.clear()

    def asSignal(self):
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Signal.hx:216
        return self

tink_core_SignalTrigger._hx_class = tink_core_SignalTrigger

# /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Math.hx:126
Math.NEGATIVE_INFINITY = float("-inf")
# /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Math.hx:127
Math.POSITIVE_INFINITY = float("inf")
# /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Math.hx:128
Math.NaN = float("nan")
# /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Math.hx:129
Math.PI = python_lib_Math.pi

def _hx_init_Sys_environ():
    # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Sys.hx:30
    def _hx_local_0():
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Sys.hx:31
        Sys.environ = haxe_ds_StringMap()
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Sys.hx:32
        env = python_lib_Os.environ
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Sys.hx:33
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Sys.hx:33
        key = python_HaxeIterator(iter(env.keys()))
        while key.hasNext():
            key1 = key.next()
            # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Sys.hx:34
            _this = Sys.environ
            value = env.get(key1,None)
            _this.h[key1] = value
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Sys.hx:36
        return Sys.environ
    return _hx_local_0()
Sys.environ = _hx_init_Sys_environ()
Sys._programPath = sys_FileSystem.fullPath(python_lib_Inspect.getsourcefile(Sys))
python_Lib.lineEnd = ("\r\n" if ((Sys.systemName() == "Windows")) else "\n")
def _hx_init_a8_GlobalScheduler_scheduler():
    # src/a8/GlobalScheduler.hx:9
    def _hx_local_0():
        # src/a8/GlobalScheduler.hx:10
        s = a8_PySched.scheduler()
        # src/a8/GlobalScheduler.hx:12
        def _hx_local_1():
            # src/a8/GlobalScheduler.hx:12
            while True:
                # src/a8/GlobalScheduler.hx:13
                s.run()
                # src/a8/GlobalScheduler.hx:14
                python_lib_Time.sleep(1)
        # src/a8/GlobalScheduler.hx:11
        a8_PyOps.spawn(_hx_local_1)
        # src/a8/GlobalScheduler.hx:17
        return s
    return _hx_local_0()
a8_GlobalScheduler.scheduler = _hx_init_a8_GlobalScheduler_scheduler()
a8_Logger.traceEnabled = False
a8_PlatformOps.instance = a8_PythonPlatform()
a8_UserConfig.repoConfig = a8_PathOps.readProperties(a8_PathOps.entry(a8_PathOps.userHome(),".a8/repo.properties"))
def _hx_init_a8_UserConfig_repo_url():
    # src/a8/UserConfig.hx:33
    def _hx_local_0():
        # src/a8/UserConfig.hx:34
        v = a8_UserConfig.getRepoProp("repo_url")
        # src/a8/UserConfig.hx:36
        u = a8_UserConfig.getRepoProp("repo_user")
        # src/a8/UserConfig.hx:37
        p = a8_UserConfig.getRepoProp("repo_password")
        # src/a8/UserConfig.hx:39
        separator = "://"
        # src/a8/UserConfig.hx:40
        split = (list(v) if ((separator == "")) else v.split(separator))
        # src/a8/UserConfig.hx:41
        url = ((((((HxOverrides.stringOrNull((split[0] if 0 < len(split) else None)) + ("null" if separator is None else separator)) + ("null" if u is None else u)) + ":") + ("null" if p is None else p)) + "@") + HxOverrides.stringOrNull((split[1] if 1 < len(split) else None)))
        # src/a8/UserConfig.hx:42
        return url
    return _hx_local_0()
a8_UserConfig.repo_url = _hx_init_a8_UserConfig_repo_url()
haxe_EntryPoint.pending = list()
haxe_EntryPoint.threadCount = 0
python_Boot.keywords = set(["and", "del", "from", "not", "with", "as", "elif", "global", "or", "yield", "assert", "else", "if", "pass", "None", "break", "except", "import", "raise", "True", "class", "exec", "in", "return", "False", "continue", "finally", "is", "try", "def", "for", "lambda", "while"])
python_Boot.prefixLength = len("_hx_")
sys_Http.PROXY = None
tink_core__Callback_Callback_Impl_.depth = 0
tink_core__Callback_Callback_Impl_.MAX_DEPTH = 200
tink_core__Future_NeverFuture.inst = tink_core__Future_NeverFuture()
tink_core__Future_Future_Impl_.NULL = tink_core__Future_SyncFuture(tink_core__Lazy_LazyConst(None))
tink_core__Future_Future_Impl_.NOISE = tink_core__Future_SyncFuture(tink_core__Lazy_LazyConst(tink_core_Noise.Noise))
tink_core__Future_Future_Impl_.NEVER = tink_core__Future_NeverFuture.inst
tink_core__Lazy_Lazy_Impl_.NULL = tink_core__Lazy_LazyConst(None)
def _hx_init_tink_core__Progress_Progress_Impl__INIT():
    # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Progress.hx:12
    def _hx_local_0():
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Progress.hx:12
        this1 = tink_core_MPair(0.0,haxe_ds_Option._hx_None)
        return this1
    return _hx_local_0()
tink_core__Progress_Progress_Impl_.INIT = _hx_init_tink_core__Progress_Progress_Impl__INIT()
tink_core__Promise_Promise_Impl_.NULL = tink_core__Future_SyncFuture(tink_core__Lazy_LazyConst(tink_core_Outcome.Success(None)))
tink_core__Promise_Promise_Impl_.NOISE = tink_core__Future_SyncFuture(tink_core__Lazy_LazyConst(tink_core_Outcome.Success(tink_core_Noise.Noise)))
def _hx_init_tink_core__Promise_Promise_Impl__NEVER():
    # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Promise.hx:14
    def _hx_local_0():
        # /usr/local/lib/haxe/lib/tink_core/1,26,0/src/tink/core/Promise.hx:14
        ret = tink_core__Future_Future_Impl_.NEVER.map(tink_core_Outcome.Success)
        return ret.gather()
    return _hx_local_0()
tink_core__Promise_Promise_Impl_.NEVER = _hx_init_tink_core__Promise_Promise_Impl__NEVER()

a8_launcher_Main.main()
haxe_EntryPoint.run()
